use std::str::str;
use std::libc::{ malloc, realloc, free };
use std::io::{ readfile_into_string, io};
use err::report::*;
use err::span::span;

enum tok_kind {
    tok_null,       # reserved
    tok_num,        # number literal
    tok_str,        # string literal
    tok_ch,         # character literal
    tok_id,         # identifier
    tok_true,       # keyword true
    tok_false,      # keyword false
    tok_use,        # keyword use
    tok_enum,       # keyword enum
    tok_for,        # keyword for
    tok_forindex,   # keyword forindex
    tok_foreach,    # keyword foreach
    tok_while,      # keyword while
    tok_var,        # keyword var
    tok_struct,     # keyword struct
    tok_pub,        # keyword pub
    tok_impl,       # keyword impl
    tok_func,       # keyword func
    tok_break,      # keyword break
    tok_continue,   # keyword continue
    tok_return,     # keyword return
    tok_if,         # keyword if
    tok_elsif,      # keyword elsif
    tok_else,       # keyword else
    tok_nil,        # keyword nil
    tok_lparen,     # (
    tok_rparen,     # )
    tok_lbracket,   # [
    tok_rbracket,   # ]
    tok_lbrace,     # {
    tok_rbrace,     # }
    tok_semi,       # ;
    tok_op_and,     # conditional binary operator and/&&
    tok_op_or,      # conditional binary operator or/||
    tok_comma,      # ,
    tok_dot,        # .
    tok_ellipsis,   # ...
    tok_quesmark,   # ?
    tok_colon,      # :
    tok_coloncolon, # ::
    tok_add,        # +
    tok_sub,        # -
    tok_mul,        # *
    tok_div,        # /
    tok_rem,        # %
    tok_floater,    # bitwise operator not '~'
    tok_bit_and,    # bitwise operator &
    tok_bit_or,     # bitwise operator |
    tok_bit_xor,    # bitwise operator ^
    tok_op_not,     # conditional binary operator !
    tok_eq,         # =
    tok_addeq,      # +=
    tok_subeq,      # -=
    tok_muleq,      # *=
    tok_diveq,      # /=
    tok_remeq,      # %=
    tok_floatereq,  # bitwise operator ~=
    tok_bit_and_eq, # bitwise operator &=
    tok_bit_or_eq,  # bitwise operator |=
    tok_bit_xor_eq, # bitwise operator ^=
    tok_cmp_eq,     # ==
    tok_neq,        # !=
    tok_less,       # <
    tok_leq,        # <=
    tok_grt,        # >
    tok_geq,        # >=
    tok_arrow,      # ->
    tok_wide_arrow, # =>
    tok_eof         # <eof> token
}

func tok_kind_to_str(kind: tok_kind) -> i8* {
    if (kind == tok_kind::tok_null) {
        return "[tok_null      ]";
    } elsif (kind == tok_kind::tok_num) {
        return "[tok_num       ]";
    } elsif (kind == tok_kind::tok_str) {
        return "[tok_str       ]";
    } elsif (kind == tok_kind::tok_ch) {
        return "[tok_ch        ]";
    } elsif (kind == tok_kind::tok_id) {
        return "[tok_id        ]";
    } elsif (kind == tok_kind::tok_true) {
        return "[tok_true      ]";
    } elsif (kind == tok_kind::tok_false) {
        return "[tok_false     ]";
    } elsif (kind == tok_kind::tok_use) {
        return "[tok_use       ]";
    } elsif (kind == tok_kind::tok_enum) {
        return "[tok_enum      ]";
    } elsif (kind == tok_kind::tok_for) {
        return "[tok_for       ]";
    } elsif (kind == tok_kind::tok_forindex) {
        return "[tok_forindex  ]";
    } elsif (kind == tok_kind::tok_foreach) {
        return "[tok_foreach   ]";
    } elsif (kind == tok_kind::tok_while) {
        return "[tok_while     ]";
    } elsif (kind == tok_kind::tok_var) {
        return "[tok_var       ]";
    } elsif (kind == tok_kind::tok_struct) {
        return "[tok_struct    ]";
    } elsif (kind == tok_kind::tok_pub) {
        return "[tok_pub       ]";
    } elsif (kind == tok_kind::tok_impl) {
        return "[tok_impl      ]";
    } elsif (kind == tok_kind::tok_func) {
        return "[tok_func      ]";
    } elsif (kind == tok_kind::tok_break) {
        return "[tok_break     ]";
    } elsif (kind == tok_kind::tok_continue) {
        return "[tok_continue  ]";
    } elsif (kind == tok_kind::tok_return) {
        return "[tok_return    ]";
    } elsif (kind == tok_kind::tok_if) {
        return "[tok_if        ]";
    } elsif (kind == tok_kind::tok_elsif) {
        return "[tok_elsif     ]";
    } elsif (kind == tok_kind::tok_else) {
        return "[tok_else      ]";
    } elsif (kind == tok_kind::tok_nil) {
        return "[tok_nil       ]";
    } elsif (kind == tok_kind::tok_lparen) {
        return "[tok_lparen    ]";
    } elsif (kind == tok_kind::tok_rparen) {
        return "[tok_rparen    ]";
    } elsif (kind == tok_kind::tok_lbracket) {
        return "[tok_lbracket  ]";
    } elsif (kind == tok_kind::tok_rbracket) {
        return "[tok_rbracket  ]";
    } elsif (kind == tok_kind::tok_lbrace) {
        return "[tok_lbrace    ]";
    } elsif (kind == tok_kind::tok_rbrace) {
        return "[tok_rbrace    ]";
    } elsif (kind == tok_kind::tok_semi) {
        return "[tok_semi      ]";
    } elsif (kind == tok_kind::tok_op_and) {
        return "[tok_op_and    ]";
    } elsif (kind == tok_kind::tok_op_or) {
        return "[tok_op_or     ]";
    } elsif (kind == tok_kind::tok_comma) {
        return "[tok_comma     ]";
    } elsif (kind == tok_kind::tok_dot) {
        return "[tok_dot       ]";
    } elsif (kind == tok_kind::tok_ellipsis) {
        return "[tok_ellipsis  ]";
    } elsif (kind == tok_kind::tok_quesmark) {
        return "[tok_quesmark  ]";
    } elsif (kind == tok_kind::tok_colon) {
        return "[tok_colon     ]";
    } elsif (kind == tok_kind::tok_coloncolon) {
        return "[tok_coloncolon]";
    } elsif (kind == tok_kind::tok_add) {
        return "[tok_add       ]";
    } elsif (kind == tok_kind::tok_sub) {
        return "[tok_sub       ]";
    } elsif (kind == tok_kind::tok_mul) {
        return "[tok_mul       ]";
    } elsif (kind == tok_kind::tok_div) {
        return "[tok_div       ]";
    } elsif (kind == tok_kind::tok_rem) {
        return "[tok_rem       ]";
    } elsif (kind == tok_kind::tok_floater) {
        return "[tok_floater   ]";
    } elsif (kind == tok_kind::tok_bit_and) {
        return "[tok_bit_and   ]";
    } elsif (kind == tok_kind::tok_bit_or) {
        return "[tok_bit_or    ]";
    } elsif (kind == tok_kind::tok_bit_xor) {
        return "[tok_bit_xor   ]";
    } elsif (kind == tok_kind::tok_op_not) {
        return "[tok_op_not    ]";
    } elsif (kind == tok_kind::tok_eq) {
        return "[tok_eq        ]";
    } elsif (kind == tok_kind::tok_addeq) {
        return "[tok_addeq     ]";
    } elsif (kind == tok_kind::tok_subeq) {
        return "[tok_subeq     ]";
    } elsif (kind == tok_kind::tok_muleq) {
        return "[tok_muleq     ]";
    } elsif (kind == tok_kind::tok_diveq) {
        return "[tok_diveq     ]";
    } elsif (kind == tok_kind::tok_remeq) {
        return "[tok_remeq     ]";
    } elsif (kind == tok_kind::tok_floatereq) {
        return "[tok_floatereq ]";
    } elsif (kind == tok_kind::tok_bit_and_eq) {
        return "[tok_bit_and_eq]";
    } elsif (kind == tok_kind::tok_bit_or_eq) {
        return "[tok_bit_or_eq ]";
    } elsif (kind == tok_kind::tok_bit_xor_eq) {
        return "[tok_bit_xor_eq]";
    } elsif (kind == tok_kind::tok_cmp_eq) {
        return "[tok_cmp_eq    ]";
    } elsif (kind == tok_kind::tok_neq) {
        return "[tok_neq       ]";
    } elsif (kind == tok_kind::tok_less) {
        return "[tok_less      ]";
    } elsif (kind == tok_kind::tok_leq) {
        return "[tok_leq       ]";
    } elsif (kind == tok_kind::tok_grt) {
        return "[tok_grt       ]";
    } elsif (kind == tok_kind::tok_geq) {
        return "[tok_geq       ]";
    } elsif (kind == tok_kind::tok_arrow) {
        return "[tok_arrow     ]";
    } elsif (kind == tok_kind::tok_wide_arrow) {
        return "[tok_wide_arrow]";
    } elsif (kind == tok_kind::tok_eof) {
        return "[tok_eof       ]";
    }

    return "[unknown token ]";
}

struct token {
    kind: tok_kind,
    content: str*,
    location: span*
}

impl token {
    func new(kind: tok_kind, content: str*, loc: span*) -> token* {
        var res = token::__alloc__();
        res->kind = kind;
        res->content = content;
        res->location = loc;
        return res;
    }

    func delete(self: token*) {
        self->content->delete();
        free(self->content => i8*);
        self->location->delete();
        free(self->location => i8*);
        return;
    }
}

struct vec_token {
    data: token*,
    size: u64,
    capacity: u64
}

impl vec_token {
    func new() -> vec_token* {
        var res = vec_token::__alloc__();
        var size_of_token = token::__size__();
        res->data = malloc((2048 => u64) * size_of_token) => token*;
        res->size = 0 => u64;
        res->capacity = 2048 => u64;
        return res;
    }

    func delete(self: vec_token*) {
        var index = 0 => u64;
        while(index < self->size) {
            self->data[index].delete();
            index += 1 => u64;
        }
        free(self->data => i8*);
        return;
    }

    func expand_capacity(self: vec_token*) {
        self->capacity *= 2 => u64;
        self->data = realloc(
            self->data => i8*,
            self->capacity * token::__size__()
        ) => token*;
        return;
    }

    func append(self: vec_token*, kind: tok_kind, content: str*, loc: span*) {
        if(self->size == self->capacity) {
            self->expand_capacity();
        }

        self->data[self->size].kind = kind;
        self->data[self->size].content = content;
        self->data[self->size].location = loc;
        self->size += 1 => u64;
        return;
    }
}

struct lexer {
    err: report*,
    toks: vec_token*,
    pos: u64,
    filename: str,
    line: i64,
    column: i64
}

impl lexer {
    func new(e: report*) -> lexer* {
        var res = lexer::__alloc__();
        res->err = e;
        res->toks = vec_token::new();
        res->pos = 0 => u64;
        res->filename.init();
        res->line = 0;
        res->column = 0;
        return res;
    }

    func delete(self: lexer*) {
        self->filename.delete();
        self->toks->delete();
        free(self->toks => i8*);
        return;
    }
}

impl lexer {
    func is_identifier_head(c: i8) -> bool {
        return ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z') || (c == '_');
    }

    func is_identifier_body(c: i8) -> bool {
        return lexer::is_identifier_head(c) || ('0' <= c && c <= '9');
    }

    func is_single_char_token(c: i8) -> bool {
        return c == '(' || c == ')' || c == '[' || c == ']' ||
               c == '{' || c == '}' || c == ';' || c == ',' ||
               c == '?';
    }

    func is_digit(c: i8) -> bool {
        return '0' <= c && c <= '9';
    }

    func is_hex(c: i8) -> bool {
        return ('a' <= c && c <= 'f') ||
               ('A' <= c && c <= 'F') ||
               lexer::is_digit(c);
    }

    func is_oct(c: i8) -> bool {
        return '0' <= c && c <= '7';
    }

    func need_lookahead_eq(c: i8) -> bool {
        return c == '+' || c == '-' || c == '*' || c == '/' ||
               c == '%' || c == '~' || c == '^' || c == '=' ||
               c == '<' || c == '>' || c == '!';
    }

    func need_lookahead_other(c: i8) -> bool {
        return c == '&' || c == '|';
    }

    func is_arrow(pos: u64, src: str*) -> bool {
        if (src->get(pos)!='-') {
            return false;
        }
        if (pos + 1 => u64 < src->size &&
            src->get(pos + 1 => u64)=='>') {
            return true;
        }
        return false;
    }

    func is_wide_arrow(pos: u64, src: str*) -> bool {
        if (src->get(pos)!='=') {
            return false;
        }
        if (pos + 1 => u64 < src->size &&
            src->get(pos + 1 => u64)=='>') {
            return true;
        }
        return false;
    }

    func is_str(c: i8) -> bool {
        return c == '"' || c == '\'';
    }

    func check_id_kind(src: str*) -> tok_kind {
        if (src->eq_const("true")) {
            return tok_kind::tok_true;
        } elsif (src->eq_const("false")) {
            return tok_kind::tok_false;
        } elsif (src->eq_const("use")) {
            return tok_kind::tok_use;
        } elsif (src->eq_const("enum")) {
            return tok_kind::tok_enum;
        } elsif (src->eq_const("for")) {
            return tok_kind::tok_for;
        } elsif (src->eq_const("forindex")) {
            return tok_kind::tok_forindex;
        } elsif (src->eq_const("foreach")) {
            return tok_kind::tok_foreach;
        } elsif (src->eq_const("while")) {
            return tok_kind::tok_while;
        } elsif (src->eq_const("var")) {
            return tok_kind::tok_var;
        } elsif (src->eq_const("struct")) {
            return tok_kind::tok_struct;
        } elsif (src->eq_const("pub")) {
            return tok_kind::tok_pub;
        } elsif (src->eq_const("impl")) {
            return tok_kind::tok_impl;
        } elsif (src->eq_const("func")) {
            return tok_kind::tok_func;
        } elsif (src->eq_const("break")) {
            return tok_kind::tok_break;
        } elsif (src->eq_const("continue")) {
            return tok_kind::tok_continue;
        } elsif (src->eq_const("return")) {
            return tok_kind::tok_return;
        } elsif (src->eq_const("if")) {
            return tok_kind::tok_if;
        } elsif (src->eq_const("elsif")) {
            return tok_kind::tok_elsif;
        } elsif (src->eq_const("else")) {
            return tok_kind::tok_else;
        } elsif (src->eq_const("nil")) {
            return tok_kind::tok_nil;
        } elsif (src->eq_const("and")) {
            return tok_kind::tok_op_and;
        } elsif (src->eq_const("or")) {
            return tok_kind::tok_op_or;
        }
        return tok_kind::tok_id;
    }
}

impl lexer {
    func generate_single_char_token(self: lexer*, src: str*) {
        var loc = span::new();
        loc->file.copy_const(self->filename.c_str);
        loc->begin_line = self->line;
        loc->begin_column = self->column;

        var tmp = str::new();
        var ch = src->get(self->pos);
        tmp->append_char(ch);

        self->pos += 1 => u64;
        self->column += 1;

        loc->end_line = self->line;
        loc->end_column = self->column;

        if (ch == '(') {
            self->toks->append(tok_kind::tok_lparen, tmp, loc);
        } elsif (ch == ')') {
            self->toks->append(tok_kind::tok_rparen, tmp, loc);
        } elsif (ch == '[') {
            self->toks->append(tok_kind::tok_lbracket, tmp, loc);
        } elsif (ch == ']') {
            self->toks->append(tok_kind::tok_rbracket, tmp, loc);
        } elsif (ch == '{') {
            self->toks->append(tok_kind::tok_lbrace, tmp, loc);
        } elsif (ch == '}') {
            self->toks->append(tok_kind::tok_rbrace, tmp, loc);
        } elsif (ch == ';') {
            self->toks->append(tok_kind::tok_semi, tmp, loc);
        } elsif (ch == ',') {
            self->toks->append(tok_kind::tok_comma, tmp, loc);
        } elsif (ch == '?') {
            self->toks->append(tok_kind::tok_quesmark, tmp, loc);
        }
        return;
    }

    func generate_maybe_need_eq_oprs(self: lexer*, src: str*) {
        var loc = span::new();
        loc->file.copy_const(self->filename.c_str);
        loc->begin_line = self->line;
        loc->begin_column = self->column;

        var tmp = str::new();
        tmp->append_char(src->get(self->pos));
        self->pos += 1 => u64;
        if (self->pos < src->size && src->get(self->pos) == '=') {
            tmp->append_char(src->get(self->pos));
            self->pos += 1 => u64;
        }

        self->column += tmp->size => i64;
        loc->end_line = self->line;
        loc->end_column = self->column;

        if (tmp->eq_const("+")) {
            self->toks->append(tok_kind::tok_add, tmp, loc);
        } elsif (tmp->eq_const("+=")) {
            self->toks->append(tok_kind::tok_addeq, tmp, loc);
        } elsif (tmp->eq_const("-")) {
            self->toks->append(tok_kind::tok_sub, tmp, loc);
        } elsif (tmp->eq_const("-=")) {
            self->toks->append(tok_kind::tok_subeq, tmp, loc);
        } elsif (tmp->eq_const("*")) {
            self->toks->append(tok_kind::tok_mul, tmp, loc);
        } elsif (tmp->eq_const("*=")) {
            self->toks->append(tok_kind::tok_muleq, tmp, loc);
        } elsif (tmp->eq_const("/")) {
            self->toks->append(tok_kind::tok_div, tmp, loc);
        } elsif (tmp->eq_const("/=")) {
            self->toks->append(tok_kind::tok_diveq, tmp, loc);
        } elsif (tmp->eq_const("%")) {
            self->toks->append(tok_kind::tok_rem, tmp, loc);
        } elsif (tmp->eq_const("%=")) {
            self->toks->append(tok_kind::tok_remeq, tmp, loc);
        } elsif (tmp->eq_const("~")) {
            self->toks->append(tok_kind::tok_floater, tmp, loc);
        } elsif (tmp->eq_const("~=")) {
            self->toks->append(tok_kind::tok_floatereq, tmp, loc);
        } elsif (tmp->eq_const("^")) {
            self->toks->append(tok_kind::tok_bit_xor, tmp, loc);
        } elsif (tmp->eq_const("^=")) {
            self->toks->append(tok_kind::tok_bit_xor_eq, tmp, loc);
        } elsif (tmp->eq_const("=")) {
            self->toks->append(tok_kind::tok_eq, tmp, loc);
        } elsif (tmp->eq_const("==")) {
            self->toks->append(tok_kind::tok_cmp_eq, tmp, loc);
        } elsif (tmp->eq_const("<")) {
            self->toks->append(tok_kind::tok_less, tmp, loc);
        } elsif (tmp->eq_const("<=")) {
            self->toks->append(tok_kind::tok_leq, tmp, loc);
        } elsif (tmp->eq_const(">")) {
            self->toks->append(tok_kind::tok_grt, tmp, loc);
        } elsif (tmp->eq_const(">=")) {
            self->toks->append(tok_kind::tok_geq, tmp, loc);
        } elsif (tmp->eq_const("!")) {
            self->toks->append(tok_kind::tok_op_not, tmp, loc);
        } elsif (tmp->eq_const("!=")) {
            self->toks->append(tok_kind::tok_neq, tmp, loc);
        }
        return;
    }

    func generate_lookahead_other(self: lexer*, src: str*) {
        var loc = span::new();
        loc->file.copy_const(self->filename.c_str);
        loc->begin_line = self->line;
        loc->begin_column = self->column;

        var tmp = str::new();
        var ch = src->get(self->pos);
        tmp->append_char(ch);
        self->pos += 1 => u64;
        if (ch == '&' && self->pos < src->size) {
            if (src->get(self->pos) == '&' ||
                src->get(self->pos) == '=') {
                tmp->append_char(src->get(self->pos));
                self->pos += 1 => u64;
            }
        } elsif (ch == '|' && self->pos < src->size) {
            if (src->get(self->pos) == '|' ||
                src->get(self->pos) == '=') {
                tmp->append_char(src->get(self->pos));
                self->pos += 1 => u64;
            }
        }

        self->column += tmp->size => i64;
        loc->end_line = self->line;
        loc->end_column = self->column;

        if (tmp->eq_const("&")) {
            self->toks->append(tok_kind::tok_bit_and, tmp, loc);
        } elsif (tmp->eq_const("&=")) {
            self->toks->append(tok_kind::tok_bit_and_eq, tmp, loc);
        } elsif (tmp->eq_const("&&")) {
            self->toks->append(tok_kind::tok_op_and, tmp, loc);
        } elsif (tmp->eq_const("|")) {
            self->toks->append(tok_kind::tok_bit_or, tmp, loc);
        } elsif (tmp->eq_const("|=")) {
            self->toks->append(tok_kind::tok_bit_or_eq, tmp, loc);
        } elsif (tmp->eq_const("||")) {
            self->toks->append(tok_kind::tok_op_or, tmp, loc);
        }
        return;
    }

    func generate_arrow(self: lexer*, src: str*) {
        var loc = span::new();
        loc->file.copy_const(self->filename.c_str);
        loc->begin_line = self->line;
        loc->begin_column = self->column;

        var tmp = str::new();
        tmp->append_char(src->get(self->pos));
        self->pos += 1 => u64;
        tmp->append_char(src->get(self->pos));
        self->pos += 1 => u64;

        self->column += 2;
        loc->end_line = self->line;
        loc->end_column = self->column;

        if (tmp->get(0 => u64)=='-') {
            self->toks->append(tok_kind::tok_arrow, tmp, loc);
        } else {
            self->toks->append(tok_kind::tok_wide_arrow, tmp, loc);
        }
        return;
    }

    func generate_identifier(self: lexer*, src: str*) {
        var loc = span::new();
        loc->file.copy_const(self->filename.c_str);
        loc->begin_line = self->line;
        loc->begin_column = self->column;

        var tmp = str::new();
        while(self->pos < src->size &&
              lexer::is_identifier_body(src->get(self->pos))) {
            tmp->append_char(src->get(self->pos));
            self->pos += 1 => u64;
        }

        self->column += tmp->size => i64;
        loc->end_line = self->line;
        loc->end_column = self->column;

        self->toks->append(lexer::check_id_kind(tmp), tmp, loc);
        return;
    }

    func generate_number(self: lexer*, src: str*) {
        var loc = span::new();
        loc->file.copy_const(self->filename.c_str);
        loc->begin_line = self->line;
        loc->begin_column = self->column;

        var tmp = str::new();
        if (src->get(self->pos)=='0' &&
            self->pos + (1 => u64) < src->size &&
            src->get(self->pos + (1 => u64)) == 'x') {
            tmp->append_i8_vec("0x");
            self->pos += 2 => u64;
            while(self->pos < src->size && lexer::is_hex(src->get(self->pos))) {
                tmp->append_char(src->get(self->pos));
                self->pos += 1 => u64;
            }
            if (tmp->size > 2 => u64) {
                self->column += tmp->size => i64;
                loc->end_line = self->line;
                loc->end_column = self->column;
                self->toks->append(tok_kind::tok_num, tmp, loc);
            } else {
                self->column += tmp->size => i64;
                loc->end_line = self->line;
                loc->end_column = self->column;
                self->err->error(loc, "invalid hex number.");
                loc->delete();
                free(loc => i8*);
            }
            return;
        }
        if (src->get(self->pos)=='0' &&
            self->pos + (1 => u64) < src->size &&
            src->get(self->pos + (1 => u64)) == 'o') {
            tmp->append_i8_vec("0o");
            self->pos += 2 => u64;
            while(self->pos < src->size && lexer::is_oct(src->get(self->pos))) {
                tmp->append_char(src->get(self->pos));
                self->pos += 1 => u64;
            }
            if (tmp->size > 2 => u64) {
                self->column += tmp->size => i64;
                loc->end_line = self->line;
                loc->end_column = self->column;
                self->toks->append(tok_kind::tok_num, tmp, loc);
            } else {
                self->column += tmp->size => i64;
                loc->end_line = self->line;
                loc->end_column = self->column;
                self->err->error(loc, "invalid oct number.");
                loc->delete();
                free(loc => i8*);
            }
            return;
        }

        # get integer part
        tmp->append_char(src->get(self->pos));
        self->pos += 1 => u64;
        while(self->pos < src->size && lexer::is_digit(src->get(self->pos))) {
            tmp->append_char(src->get(self->pos));
            self->pos += 1 => u64;
        }

        # get float part
        if (self->pos < src->size && src->get(self->pos) == '.') {
            var lookahead_pos = self->pos + (1 => u64);

            # just return, this dot is not part of number
            if (lookahead_pos >= src->size) {
                self->column += tmp->size => i64;
                loc->end_line = self->line;
                loc->end_column = self->column;
                self->toks->append(tok_kind::tok_num, tmp, loc);
                return;
            }

            var lookahead_ch = src->get(lookahead_pos);

            # just return, this dot is not part of number
            if (!lexer::is_digit(lookahead_ch)) {
                self->column += tmp->size => i64;
                loc->end_line = self->line;
                loc->end_column = self->column;
                self->toks->append(tok_kind::tok_num, tmp, loc);
                return;
            }

            tmp->append_char('.');
            self->pos += 1 => u64;
            while(self->pos < src->size && lexer::is_digit(src->get(self->pos))) {
                tmp->append_char(src->get(self->pos));
                self->pos += 1 => u64;
            }
        }

        # get F-E part
        if (self->pos < src->size &&
            (src->get(self->pos) == 'e' || src->get(self->pos) == 'E')) {
            # just return
            if (self->pos + (1 => u64) >= src->size) {
                self->column += tmp->size => i64;
                loc->end_line = self->line;
                loc->end_column = self->column;
                self->toks->append(tok_kind::tok_num, tmp, loc);
                return;
            }

            var lookahead_pos = self->pos + (1 => u64);

            if (lexer::is_digit(src->get(lookahead_pos))) {
                tmp->append_char(src->get(self->pos));
                self->pos += 1 => u64;
                while(self->pos < src->size && lexer::is_digit(src->get(self->pos))) {
                    tmp->append_char(src->get(self->pos));
                    self->pos += 1 => u64;
                }
                self->column += tmp->size => i64;
                loc->end_line = self->line;
                loc->end_column = self->column;
                self->toks->append(tok_kind::tok_num, tmp, loc);
                return;
            }

            if ((src->get(lookahead_pos)=='-' || src->get(lookahead_pos)=='+') &&
                lookahead_pos + (1 => u64) < src->size &&
                lexer::is_digit(src->get(lookahead_pos + (1 => u64)))) {
                tmp->append_char(src->get(self->pos));
                tmp->append_char(src->get(self->pos + (1 => u64)));
                self->pos += 2 => u64;
                while(self->pos < src->size && lexer::is_digit(src->get(self->pos))) {
                    tmp->append_char(src->get(self->pos));
                    self->pos += 1 => u64;
                }
                self->column += tmp->size => i64;
                loc->end_line = self->line;
                loc->end_column = self->column;
                self->toks->append(tok_kind::tok_num, tmp, loc);
                return;
            }
        }

        self->column += tmp->size => i64;
        loc->end_line = self->line;
        loc->end_column = self->column;
        self->toks->append(tok_kind::tok_num, tmp, loc);
        return;
    }

    func generate_string(self: lexer*, src: str*) {
        var loc = span::new();
        loc->file.copy_const(self->filename.c_str);
        loc->begin_line = self->line;
        loc->begin_column = self->column;

        var quote_type = src->get(self->pos);
        var tmp = str::new();
        tmp->append_char(quote_type);
        self->pos += 1 => u64;
        self->column += 1;

        while(self->pos < src->size && src->get(self->pos) != quote_type) {
            var this_ch = src->get(self->pos);
            if (this_ch=='\n') {
                self->line += 1;
                self->column = 0;
            } else {
                self->column += 1;
            }

            if (this_ch=='\\' && self->pos + (1 => u64) < src->size) {
                self->pos += 1 => u64;
                var next_ch = src->get(self->pos);
                if (next_ch=='0') {
                    tmp->append_char('\0');
                } elsif (next_ch=='a') {
                    tmp->append_char('\a');
                } elsif (next_ch=='b') {
                    tmp->append_char('\b');
                } elsif (next_ch=='e') {
                    tmp->append_char('\e');
                } elsif (next_ch=='t') {
                    tmp->append_char('\t');
                } elsif (next_ch=='n') {
                    tmp->append_char('\n');
                } elsif (next_ch=='v') {
                    tmp->append_char('\v');
                } elsif (next_ch=='f') {
                    tmp->append_char('\f');
                } elsif (next_ch=='r') {
                    tmp->append_char('\r');
                } elsif (next_ch=='?') {
                    tmp->append_char('\?');
                } elsif (next_ch=='\\') {
                    tmp->append_char('\\');
                } elsif (next_ch=='\'') {
                    tmp->append_char('\'');
                } elsif (next_ch=='\"') {
                    tmp->append_char('\"');
                } else {
                    tmp->append_char(next_ch);
                }
                if (next_ch=='\n') {
                    self->line += 1;
                    self->column = 0;
                } else {
                    self->column += 1;
                }
            } else {
                tmp->append_char(this_ch);
            }
            self->pos += 1 => u64;
        }
        if (self->pos >= src->size) {
            loc->end_line = self->line;
            loc->end_column = self->column;
            self->err->error(loc, "get <eof> when generating string.");
            loc->delete();
            free(loc => i8*);
            return;
        }

        # add last quote
        tmp->append_char(quote_type);
        self->pos += 1 => u64;
        self->column += 1;

        loc->end_line = self->line;
        loc->end_column = self->column;

        if (quote_type == '"') {
            self->toks->append(tok_kind::tok_str, tmp, loc);
        } else {
            if (tmp->size != 3 => u64) {
                self->err->error(loc, "should only contain one character.");
            }
            self->toks->append(tok_kind::tok_ch, tmp, loc);
        }
        return;
    }

    func generate_coloncolon(self: lexer*, src: str*) {
        var loc = span::new();
        loc->file.copy_const(self->filename.c_str);
        loc->begin_line = self->line;
        loc->begin_column = self->column;

        var tmp = str::new();
        tmp->append_char(':');
        self->pos += 1 => u64;
        self->column += 1;

        if (self->pos < src->size && src->get(self->pos) == ':') {
            tmp->append_char(':');
            self->pos += 1 => u64;
            self->column += 1;
            loc->end_line = self->line;
            loc->end_column = self->column;

            self->toks->append(tok_kind::tok_coloncolon, tmp, loc);
        } else {
            loc->end_line = self->line;
            loc->end_column = self->column;
            self->toks->append(tok_kind::tok_colon, tmp, loc);
        }
        return;
    }

    func generate_ellipsis(self: lexer*, src: str*) {
        var loc = span::new();
        loc->file.copy_const(self->filename.c_str);
        loc->begin_line = self->line;
        loc->begin_column = self->column;

        var tmp = str::new();
        tmp->append_char('.');
        self->pos += 1 => u64;
        self->column += 1;

        if (self->pos + (1 => u64) < src->size &&
            src->get(self->pos) == '.' &&
            src->get(self->pos + (1 => u64)) == '.') {
            tmp->append_char('.')->append_char('.');
            self->pos += 2 => u64;
            self->column += 2;
            loc->end_line = self->line;
            loc->end_column = self->column;

            self->toks->append(tok_kind::tok_ellipsis, tmp, loc);
        } else {
            loc->end_line = self->line;
            loc->end_column = self->column;

            self->toks->append(tok_kind::tok_dot, tmp, loc);
        }
        return;
    }

    func skip_note(self: lexer*, src: str*) {
        while(self->pos < src->size && src->get(self->pos) != '\n') {
            self->pos += 1 => u64;
            self->column += 1;
        }
        return;
    }

    func scan(self: lexer*, filename: i8*) {
        var src = str::new();
        self->filename.clear();
        self->filename.copy_const(filename);
        self->err->load_file_source(filename);
        readfile_into_string(filename, src);

        self->pos = 0 => u64;
        self->line = 0;
        self->column = 0;
        while(self->pos < src->size) {
            if (lexer::is_identifier_head(src->get(self->pos))) {
                self->generate_identifier(src);
            } elsif (lexer::is_digit(src->get(self->pos))) {
                self->generate_number(src);
            } elsif (lexer::is_str(src->get(self->pos))) {
                self->generate_string(src);
            } elsif (lexer::is_arrow(self->pos, src) ||
                     lexer::is_wide_arrow(self->pos, src)) {
                # need to be put before normal operator scan process
                # otherwise `=>` will be recognized as `=` `>`
                self->generate_arrow(src);
            } elsif (lexer::is_single_char_token(src->get(self->pos))) {
                self->generate_single_char_token(src);
            } elsif (lexer::need_lookahead_eq(src->get(self->pos))) {
                self->generate_maybe_need_eq_oprs(src);
            } elsif (lexer::need_lookahead_other(src->get(self->pos))) {
                self->generate_lookahead_other(src);
            } elsif (src->get(self->pos)==':') {
                self->generate_coloncolon(src);
            } elsif (src->get(self->pos)=='.') {
                self->generate_ellipsis(src);
            } elsif (src->get(self->pos)=='#') {
                self->skip_note(src);
            } else {
                if (src->get(self->pos)=='\n') {
                    self->line += 1;
                    self->column = 0;
                } else {
                    self->column += 1;
                }
                self->pos += 1 => u64;
            }
        }

        var eof_span = span::new();
        eof_span->file.copy_const(self->filename.c_str);
        eof_span->begin_line = self->line;
        eof_span->begin_column = self->column;
        eof_span->end_line = self->line;
        eof_span->end_column = self->column;
        self->toks->append(
            tok_kind::tok_eof,
            str::new()->append_i8_vec("<eof>"),
            eof_span
        );

        src->delete();
        free(src => i8*);
        return;
    }

    func dump(self: lexer*) {
        var index = 0 => u64;
        while(index < self->toks->size) {
            var loc = self->toks->data[index].location;
            io::stdlog()->out(tok_kind_to_str(self->toks->data[index].kind))
                        ->out(" [")
                        ->out(loc->file.c_str)
                        ->out(":")
                        ->out_i64(loc->begin_line + 1)
                        ->out(":")
                        ->out_i64(loc->begin_column + 1)
                        ->out(" -> ")
                        ->out(loc->file.c_str)
                        ->out(":")
                        ->out_i64(loc->end_line + 1)
                        ->out(":")
                        ->out_i64(loc->end_column + 1)
                        ->out("] \"")
                        ->out(self->toks->data[index].content->c_str)
                        ->out("\"")
                        ->endln();
            index += 1 => u64;
        }
        return;
    }
}
