use std::io::{ io };
use std::str::{ str };
use std::vec::{ vec };
use std::libc::{ free };
use std::panic::{ panic, unimplemented };

pub enum DI_kind {
    DI_null,
    DI_named_metadata,
    DI_ref_index,
    DI_list,
    DI_i32,
    DI_string,
    DI_file,
    DI_compile_unit,
    DI_basic_type,
    DI_structure_type,
    DI_union_type,
    DI_enum_type,
    DI_enumerator,
    DI_subprogram,
    DI_subroutine,
    DI_location,
    DW_TAG_pointer_type,
    DW_TAG_member
}

pub func DI_ERROR_INDEX() -> u64 {
    return 0xffffffffffffffff;
}

pub union(DI_kind) DI_node {
    DI_null: DI_null,
    DI_named_metadata: DI_named_metadata,
    DI_ref_index: DI_ref_index,
    DI_list: DI_list,
    DI_i32: DI_i32,
    DI_string: DI_string,
    DI_file: DI_file,
    DI_compile_unit: DI_compile_unit,
    DI_basic_type: DI_basic_type,
    DI_structure_type: DI_structure_type,
    DI_union_type: DI_union_type,
    DI_enum_type: DI_enum_type,
    DI_enumerator: DI_enumerator,
    DI_subprogram: DI_subprogram,
    DI_subroutine: DI_subroutine,
    DI_location: DI_location,
    DW_TAG_pointer_type: DW_TAG_pointer_type,
    DW_TAG_member: DW_TAG_member
}

impl DI_node {
    pub func add(self, n: DI_node*) {
        match (self) {
            DI_kind::DI_named_metadata => {
                self.DI_named_metadata.add(n);
            }
            DI_kind::DI_list => {
                self.DI_list.add(n);
            }
            _ => { panic("DI_node::add: invalid DI_node kind"); }
        }
    }

    pub func index(self) -> u64 {
        match (self) {
            DI_kind::DI_null => {}
            DI_kind::DI_named_metadata => return self.DI_named_metadata.index;
            DI_kind::DI_ref_index => {}
            DI_kind::DI_list => return self.DI_list.index;
            DI_kind::DI_i32 => {}
            DI_kind::DI_string => {}
            DI_kind::DI_file => return self.DI_file.index;
            DI_kind::DI_compile_unit => return self.DI_compile_unit.index;
            DI_kind::DI_basic_type => return self.DI_basic_type.index;
            DI_kind::DI_structure_type => return self.DI_structure_type.index;
            DI_kind::DI_union_type => return self.DI_union_type.index;
            DI_kind::DI_enum_type => return self.DI_enum_type.index;
            DI_kind::DI_enumerator => return self.DI_enumerator.index;
            DI_kind::DI_subprogram => return self.DI_subprogram.index;
            DI_kind::DI_subroutine => return self.DI_subroutine.index;
            DI_kind::DI_location => return self.DI_location.index;
            DI_kind::DW_TAG_pointer_type => return self.DW_TAG_pointer_type.index;
            DI_kind::DW_TAG_member => return self.DW_TAG_member.index;
        }
        return DI_ERROR_INDEX();
    }

    pub func dump(self, out: io&) {
        var index = self.index();
        if (index != DI_ERROR_INDEX()) {
            out.out("!").out_u64(index).out(" = ");
        }
        match (self) {
            DI_kind::DI_null => {
                out.out("null");
            }
            DI_kind::DI_named_metadata => {
                self.DI_named_metadata.dump(out);
            }
            DI_kind::DI_ref_index => {
                self.DI_ref_index.dump(out);
            }
            DI_kind::DI_list => {
                self.DI_list.dump(out);
            }
            DI_kind::DI_i32 => {
                self.DI_i32.dump(out);
            }
            DI_kind::DI_string => {
                self.DI_string.dump(out);
            }
            DI_kind::DI_file => {
                self.DI_file.dump(out);
            }
            DI_kind::DI_compile_unit => {
                self.DI_compile_unit.dump(out);
            }
            DI_kind::DI_basic_type => {
                self.DI_basic_type.dump(out);
            }
            DI_kind::DI_structure_type => {
                self.DI_structure_type.dump(out);
            }
            DI_kind::DI_union_type => {
                self.DI_union_type.dump(out);
            }
            DI_kind::DI_enum_type => {
                self.DI_enum_type.dump(out);
            }
            DI_kind::DI_enumerator => {
                self.DI_enumerator.dump(out);
            }
            DI_kind::DI_subprogram => {
                self.DI_subprogram.dump(out);
            }
            DI_kind::DI_subroutine => {
                self.DI_subroutine.dump(out);
            }
            DI_kind::DI_location => {
                self.DI_location.dump(out);
            }
            DI_kind::DW_TAG_pointer_type => {
                self.DW_TAG_pointer_type.dump(out);
            }
            DI_kind::DW_TAG_member => {
                self.DW_TAG_member.dump(out);
            }
        }
    }

    pub func delete(self) {
        match (self) {
            DI_kind::DI_null => {}
            DI_kind::DI_named_metadata => {
                self.DI_named_metadata.delete();
            }
            DI_kind::DI_ref_index => {}
            DI_kind::DI_list => {
                self.DI_list.delete();
            }
            DI_kind::DI_i32 => {}
            DI_kind::DI_string => {
                self.DI_string.delete();
            }
            DI_kind::DI_file => {
                self.DI_file.delete();
            }
            DI_kind::DI_compile_unit => {
                self.DI_compile_unit.delete();
            }
            DI_kind::DI_basic_type => {
                self.DI_basic_type.delete();
            }
            DI_kind::DI_structure_type => {
                self.DI_structure_type.delete();
            }
            DI_kind::DI_union_type => {
                self.DI_union_type.delete();
            }
            DI_kind::DI_enum_type => {
                self.DI_enum_type.delete();
            }
            DI_kind::DI_enumerator => {
                self.DI_enumerator.delete();
            }
            DI_kind::DI_subprogram => {
                self.DI_subprogram.delete();
            }
            DI_kind::DI_subroutine => {}
            DI_kind::DI_location => {
                self.DI_location.delete();
            }
            DI_kind::DW_TAG_pointer_type => {
                self.DW_TAG_pointer_type.delete();
            }
            DI_kind::DW_TAG_member => {
                self.DW_TAG_member.delete();
            }
        }
    }
}

impl DI_node {
    pub func get_DW_TAG_pointer_type(self) -> DW_TAG_pointer_type* {
        match (self) {
            DI_kind::DW_TAG_pointer_type => {
                return self.DW_TAG_pointer_type.__ptr__();
            }
            _ => {
                panic("get_pointer_type: not a DW_TAG_pointer_type");
            }
        }
        return nil;
    }

    pub func get_DI_enum_type(self) -> DI_enum_type* {
        match (self) {
            DI_kind::DI_enum_type => {
                return self.DI_enum_type.__ptr__();
            }
            _ => {
                panic("get_DI_enum_type: not a DI_enum_type");
            }
        }
        return nil;
    }

    pub func get_DI_structure_type(self) -> DI_structure_type* {
        match (self) {
            DI_kind::DI_structure_type => {
                return self.DI_structure_type.__ptr__();
            }
            _ => {
                panic("get_DI_structure_type: not a DI_structure_type");
            }
        }
        return nil;
    }

    pub func get_DI_union_type(self) -> DI_union_type* {
        match (self) {
            DI_kind::DI_union_type => {
                return self.DI_union_type.__ptr__();
            }
            _ => {
                panic("get_DI_union_type: not a DI_union_type");
            }
        }
        return nil;
    }

    pub func get_DI_compile_unit(self) -> DI_compile_unit* {
        match (self) {
            DI_kind::DI_compile_unit => {
                return self.DI_compile_unit.__ptr__();
            }
            _ => {
                panic("get_DI_compile_unit: not a DI_compile_unit");
            }
        }
        return nil;
    }
}

// for example:
//   null
// expect not to have an index
pub struct DI_null {}

impl DI_null {
    pub func new() -> DI_node* {
        var res = DI_node::__alloc__();
        res[0] = DI_node { DI_null: DI_null {} };
        return res;
    }
}

// for example:
//   !llvm.ident = !{!0}
//    ^^^^^^^^^^ named metadata uses identifier as the name, not index
pub struct DI_named_metadata {
    index: u64,
    name: str,
    nodes: vec<DI_node*>
}

impl DI_named_metadata {
    pub func new(name: i8*) -> DI_node* {
        var res = DI_node::__alloc__();
        res[0] = DI_node {
            DI_named_metadata: DI_named_metadata {
                index: DI_ERROR_INDEX(),
                name: str::from(name),
                nodes: vec<DI_node*>::instance()
            }
        };
        return res;
    }

    pub func delete(self) {
        self.name.delete();
        foreach (var i; self.nodes) {
            var n = i.get();
            n->delete();
            free(n => i8*);
        }
        self.nodes.delete();
    }

    pub func add(self, n: DI_node*) {
        self.nodes.push(n);
    }

    pub func dump(self, out: io&) {
        out.out("!").out(self.name.c_str).out(" = !{");
        foreach (var i; self.nodes) {
            i.get()->dump(out);
            if (i.index() != self.nodes.size - 1) {
                out.out(", ");
            }
        }
        out.out("}");
    }
}

// for example
//   !1
// expect not to have an index
pub struct DI_ref_index {
    ref_index: u64
}

impl DI_ref_index {
    pub func new(index: u64) -> DI_node* {
        var res = DI_node::__alloc__();
        res[0] = DI_node {
            DI_ref_index: DI_ref_index { ref_index: index }
        };
        return res;
    }

    pub func dump(self, out: io&) {
        out.out("!").out_u64(self.ref_index);
    }
}

// for example
//   !0 = !{ !1, !2, !3 }
pub struct DI_list {
    index: u64,
    nodes: vec<DI_node*>
}

impl DI_list {
    pub func new(i: u64) -> DI_node* {
        var res = DI_node::__alloc__();
        res[0] = DI_node {
            DI_list: DI_list {
                index: i,
                nodes: vec<DI_node*>::instance()
            }
        };
        return res;
    }

    pub func delete(self) {
        foreach (var i; self.nodes) {
            var n = i.get();
            n->delete();
            free(n => i8*);
        }
        self.nodes.delete();
    }

    pub func add(self, n: DI_node*) {
        self.nodes.push(n);
    }

    pub func dump(self, out: io&) {
        out.out("!{");
        foreach (var i; self.nodes) {
            i.get()->dump(out);
            if (i.index() != self.nodes.size - 1) {
                out.out(", ");
            }
        }
        out.out("}");
    }
}

// for example
//   i32 42
// expect not to have an index
pub struct DI_i32 {
    value: i32
}

impl DI_i32 {
    pub func new(value: i32) -> DI_node* {
        var res = DI_node::__alloc__();
        res[0] = DI_node {
            DI_i32: DI_i32 { value: value }
        };
        return res;
    }

    pub func dump(self, out: io&) {
        out.out("i32 ").out_i64(self.value => i64);
    }
}

// for example
//   !"foo"
// expect not to have an index
pub struct DI_string {
    value: str
}

impl DI_string {
    pub func new(value: i8*) -> DI_node* {
        var res = DI_node::__alloc__();
        res[0] = DI_node {
            DI_string: DI_string { value: str::from(value) }
        };
        return res;
    }

    pub func delete(self) {
        self.value.delete();
    }

    pub func dump(self, out: io&) {
        out.out("!\"").out(self.value.c_str).out("\"");
    }
}

// for example
//   !0 = !DIFile(filename: "src/std/libc.colgm", directory: "/usr/lib/colgm")
pub struct DI_file {
    index: u64,
    filename: str,
    directory: str
}

impl DI_file {
    pub func new(i: u64, f: i8*, d: i8*) -> DI_node* {
        var res = DI_node::__alloc__();
        res[0] = DI_node {
            DI_file: DI_file {
                index: i,
                filename: str::from(f),
                directory: str::from(d)
            }
        };
        return res;
    }

    pub func delete(self) {
        self.filename.delete();
        self.directory.delete();
    }

    pub func dump(self, out: io&) {
        out.out("!DIFile(filename: \"").out(self.filename.c_str);
        out.out("\", directory: \"").out(self.directory.c_str).out("\")");
    }
}

pub struct DI_compile_unit {
    index: u64,
    producer: str,
    file_index: u64,
    imports_index: u64,
    enums_index: u64
}

impl DI_compile_unit {
    pub func new(i: u64, p: i8*, fi: u64) -> DI_node* {
        var res = DI_node::__alloc__();
        res[0] = DI_node {
            DI_compile_unit: DI_compile_unit {
                index: i,
                producer: str::from(p),
                file_index: fi,
                imports_index: DI_ERROR_INDEX(),
                enums_index: DI_ERROR_INDEX()
            }
        };
        return res;
    }

    pub func delete(self) {
        self.producer.delete();
    }

    pub func dump(self, out: io&) {
        out.out("distinct !DICompileUnit(");
        out.out("language: DW_LANG_C99, ");
        out.out("file: !").out_u64(self.file_index).out(", ");
        out.out("producer: \"").out(self.producer.c_str).out("\", ");
        if (self.imports_index != DI_ERROR_INDEX()) {
            out.out("imports: !").out_u64(self.imports_index).out(", ");
        }
        if (self.enums_index != DI_ERROR_INDEX()) {
            out.out("enums: !").out_u64(self.enums_index).out(", ");
        }
        out.out("isOptimized: false, runtimeVersion: 0, emissionKind: FullDebug)");
    }
}

pub struct DI_basic_type {
    index: u64,
    name: str,
    size_in_bits: u64,
    encoding: str
}

impl DI_basic_type {
    pub func new(i: u64, n: i8*, s: u64, e: i8*) -> DI_node* {
        var res = DI_node::__alloc__();
        res[0] = DI_node {
            DI_basic_type: DI_basic_type {
                index: i,
                name: str::from(n),
                size_in_bits: s,
                encoding: str::from(e)
            }
        };
        return res;
    }

    pub func delete(self) {
        self.name.delete();
        self.encoding.delete();
    }

    pub func dump(self, out: io&) {
        out.out("!DIBasicType(name: \"").out(self.name.c_str);
        out.out("\", size: ").out_u64(self.size_in_bits).out(", encoding: ");
        out.out(self.encoding.c_str).out(")");
    }
}

pub struct DI_structure_type {
    index: u64,
    name: str,
    identifier: str,
    file_index: u64,
    line: i64,
    elements: u64
}

impl DI_structure_type {
    pub func new(i: u64, n: i8*, id: i8*, fi: u64, l: i64) -> DI_node* {
        var res = DI_node::__alloc__();
        res[0] = DI_node {
            DI_structure_type: DI_structure_type {
                index: i,
                name: str::from(n),
                identifier: str::from(id),
                file_index: fi,
                line: l,
                elements: DI_ERROR_INDEX()
            }
        };
        return res;
    }

    pub func delete(self) {
        self.name.delete();
        self.identifier.delete();
    }

    pub func dump(self, out: io&) {
        out.out("!DICompositeType(tag: DW_TAG_structure_type, ");
        out.out("name: \"").out(self.name.c_str).out("\", ");
        out.out("file: !").out_u64(self.file_index).out(", ");
        out.out("line: ").out_i64(self.line).out(", ");
        out.out("identifier: \"").out(self.identifier.c_str).out("\"");
        if (self.elements != DI_ERROR_INDEX()) {
            out.out(", elements: !").out_u64(self.elements);
        }
        out.out(")");
    }
}

pub struct DI_union_type {
    index: u64,
    name: str,
    identifier: str,
    file_index: u64,
    line: i64,
    elements: u64
}

impl DI_union_type {
    pub func new(i: u64, n: i8*, id: i8*, fi: u64, l: i64) -> DI_node* {
        var res = DI_node::__alloc__();
        res[0] = DI_node {
            DI_union_type: DI_union_type {
                index: i,
                name: str::from(n),
                identifier: str::from(id),
                file_index: fi,
                line: l,
                elements: DI_ERROR_INDEX()
            }
        };
        return res;
    }

    pub func delete(self) {
        self.name.delete();
        self.identifier.delete();
    }

    pub func dump(self, out: io&) {
        out.out("!DICompositeType(tag: DW_TAG_union_type, ");
        out.out("name: \"").out(self.name.c_str).out("\", ");
        out.out("file: !").out_u64(self.file_index).out(", ");
        out.out("line: ").out_i64(self.line).out(", ");
        out.out("identifier: \"").out(self.identifier.c_str).out("\"");
        if (self.elements != DI_ERROR_INDEX()) {
            out.out(", elements: !").out_u64(self.elements);
        }
        out.out(")");
    }
}

pub struct DI_enum_type {
    index: u64,
    name: str,
    identifier: str,
    file_index: u64,
    line: i64,
    base_type_index: u64,
    elements_index: u64
}

impl DI_enum_type {
    pub func new(i: u64, n: i8*, id: i8*, fi: u64, l: i64, bti: u64) -> DI_node* {
        var res = DI_node::__alloc__();
        res[0] = DI_node {
            DI_enum_type: DI_enum_type {
                index: i,
                name: str::from(n),
                identifier: str::from(id),
                file_index: fi,
                line: l,
                base_type_index: bti,
                elements_index: DI_ERROR_INDEX()
            }
        };
        return res;
    }

    pub func delete(self) {
        self.name.delete();
        self.identifier.delete();
    }

    pub func dump(self, out: io&) {
        out.out("!DICompositeType(tag: DW_TAG_enumeration_type, ");
        out.out("name: \"").out(self.name.c_str).out("\", ");
        out.out("file: !").out_u64(self.file_index).out(", ");
        out.out("line: ").out_i64(self.line).out(", ");
        out.out("baseType: !").out_u64(self.base_type_index).out(", ");
        if (self.elements_index != DI_ERROR_INDEX()) {
            out.out("elements: !").out_u64(self.elements_index).out(", ");
        }
        out.out("identifier: \"").out(self.identifier.c_str).out("\")");
    }
}

pub struct DI_enumerator {
    index: u64,
    name: str,
    value: i64
}

impl DI_enumerator {
    pub func new(i: u64, n: i8*, v: i64) -> DI_node* {
        var res = DI_node::__alloc__();
        res[0] = DI_node {
            DI_enumerator: DI_enumerator {
                index: i,
                name: str::from(n),
                value: v
            }
        };
        return res;
    }

    pub func delete(self) {
        self.name.delete();
    }

    pub func dump(self, out: io&) {
        out.out("!DIEnumerator(name: \"").out(self.name.c_str).out("\", ");
        out.out("value: ").out_i64(self.value).out(")");
    }
}

pub struct DI_subprogram {
    index: u64,
    name: str,
    file_index: u64,
    line: i64,
    type_index: u64,
    compile_unit_index: u64
}

impl DI_subprogram {
    pub func new(i: u64, n: i8*, fi: u64, l: i64, ti: u64, cu: u64) -> DI_node* {
        var res = DI_node::__alloc__();
        res[0] = DI_node {
            DI_subprogram: DI_subprogram {
                index: i,
                name: str::from(n),
                file_index: fi,
                line: l,
                type_index: ti,
                compile_unit_index: cu
            }
        };
        return res;
    }

    pub func delete(self) {
        self.name.delete();
    }

    pub func dump(self, out: io&) {
        out.out("distinct !DISubprogram(name: \"").out(self.name.c_str).out("\", ");
        out.out("file: !").out_u64(self.file_index).out(", ");
        out.out("line: ").out_i64(self.line).out(", ");
        out.out("type: !").out_u64(self.type_index).out(", ");
        out.out("unit: !").out_u64(self.compile_unit_index).out(")");
    }
}

pub struct DI_subroutine {
    index: u64,
    types_index: u64
}

impl DI_subroutine {
    pub func new(i: u64, ti: u64) -> DI_node* {
        var res = DI_node::__alloc__();
        res[0] = DI_node {
            DI_subroutine: DI_subroutine {
                index: i,
                types_index: ti
            }
        };
        return res;
    }

    pub func dump(self, out: io&) {
        out.out("!DISubroutineType(types: !").out_u64(self.types_index).out(")");
    }
}

pub struct DI_location {
    index: u64,
    file: str,
    line: i64,
    column: i64,
    scope_index: u64
}

impl DI_location {
    pub func new(i: u64, f: i8*, l: i64, c: i64, si: u64) -> DI_node* {
        var res = DI_node::__alloc__();
        res[0] = DI_node {
            DI_location: DI_location {
                index: i,
                file: str::from(f),
                line: l,
                column: c,
                scope_index: si
            }
        };
        return res;
    }

    pub func delete(self) {
        self.file.delete();
    }

    pub func dump(self, out: io&) {
        out.out("!DILocation(line: ").out_i64(self.line).out(", ");
        out.out("column: ").out_i64(self.column).out(", ");
        out.out("scope: !").out_u64(self.scope_index).out(")");
        if (!self.file.empty()) {
            out.out(" ; ").out(self.file.c_str);
        }
    }
}

pub struct DW_TAG_pointer_type {
    index: u64,
    base_type_index: u64,
    size: u64,
    name: str
}

impl DW_TAG_pointer_type {
    pub func new(i: u64, bti: u64, s: u64, n: i8*) -> DI_node* {
        var res = DI_node::__alloc__();
        res[0] = DI_node {
            DW_TAG_pointer_type: DW_TAG_pointer_type {
                index: i,
                base_type_index: bti,
                size: s,
                name: str::from(n)
            }
        };
        return res;
    }

    pub func delete(self) {
        self.name.delete();
    }

    pub func dump(self, out: io&) {
        out.out("!DIDerivedType(tag: DW_TAG_pointer_type, ");
        out.out("baseType: !").out_u64(self.base_type_index).out(", ");
        out.out("size: ").out_u64(self.size).out(") ; ").out(self.name.c_str);
    }
}

pub struct DW_TAG_member {
    index: u64,
    name: str,
    scope_index: u64,
    file_index: u64,
    line: i64,
    base_type_index: u64
}

impl DW_TAG_member {
    pub func new(i: u64, n: i8*, si: u64, fi: u64, l: i64, bti: u64) -> DI_node* {
        var res = DI_node::__alloc__();
        res[0] = DI_node {
            DW_TAG_member: DW_TAG_member {
                index: i,
                name: str::from(n),
                scope_index: si,
                file_index: fi,
                line: l,
                base_type_index: bti
            }
        };
        return res;
    }

    pub func delete(self) {
        self.name.delete();
    }

    pub func dump(self, out: io&) {
        out.out("!DIDerivedType(tag: DW_TAG_member, ");
        out.out("name: \"").out(self.name.c_str).out("\", ");
        out.out("scope: !").out_u64(self.scope_index).out(", ");
        out.out("file: !").out_u64(self.file_index).out(", ");
        out.out("line: ").out_i64(self.line).out(", ");
        out.out("baseType: !").out_u64(self.base_type_index).out(")");
    }
}