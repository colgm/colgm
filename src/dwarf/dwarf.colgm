use std::io::{ io };
use std::str::{ str };
use std::vec::{ primitive_vec };
use std::ptr::{ ptr };
use std::libc::{ free };

use err::panic::{ unimplemented };

pub enum DI_kind {
    DI_error, // reserved for errors
    DI_named_metadata,
    DI_ref_index,
    DI_list,
    DI_i32,
    DI_string,
    DI_file,
    DI_compile_unit,
    DI_basic_type,
    DI_structure_type,
    DI_enum_type,
    DI_enumerator,
    DI_subprogram,
    DI_location
}

pub func DI_ERROR_INDEX() -> u64 {
    return 0xffffffffffffffff;
}

pub struct DI_node {
    kind: DI_kind,
    index: u64
}

impl DI_node {
    pub func instance(k: DI_kind, i: u64) -> DI_node {
        return DI_node {
            kind: k,
            index: i
        };
    }

    pub func delete(self) {
        match (self->kind) {
            DI_kind::DI_named_metadata => {
                var n = self => DI_named_metadata*;
                n->delete();
            }
            DI_kind::DI_ref_index => {}
            DI_kind::DI_list => {
                var n = self => DI_list*;
                n->delete();
            }
            DI_kind::DI_i32 => {}
            DI_kind::DI_string => {
                var n = self => DI_string*;
                n->delete();
            }
            DI_kind::DI_file => {
                var n = self => DI_file*;
                n->delete();
            }
            DI_kind::DI_compile_unit => {
                var n = self => DI_compile_unit*;
                n->delete();
            }
            DI_kind::DI_basic_type => {
                var n = self => DI_basic_type*;
                n->delete();
            }
            DI_kind::DI_enum_type => {
                var n = self => DI_enum_type*;
                n->delete();
            }
            DI_kind::DI_enumerator => {
                var n = self => DI_enumerator*;
                n->delete();
            }
            _ => unimplemented();
        }
    }

    pub func dump_index(self, out: io) {
        if (self->index != DI_ERROR_INDEX()) {
            out.out("!").out_u64(self->index).out(" = ");
        }
    }

    pub func is(self, k: DI_kind) -> bool {
        return self->kind == k;
    }

    pub func dump(self, out: io) {
        if (self->index != DI_ERROR_INDEX()) {
            out.out("!").out_i64(self->index => i64).out(" = ");
        }
        match (self->kind) {
            DI_kind::DI_named_metadata => {
                var n = self => DI_named_metadata*;
                n->dump(out);
            }
            DI_kind::DI_ref_index => {
                var n = self => DI_ref_index*;
                n->dump(out);
            }
            DI_kind::DI_list => {
                var n = self => DI_list*;
                n->dump(out);
            }
            DI_kind::DI_i32 => {
                var n = self => DI_i32*;
                n->dump(out);
            }
            DI_kind::DI_string => {
                var n = self => DI_string*;
                n->dump(out);
            }
            DI_kind::DI_file => {
                var n = self => DI_file*;
                n->dump(out);
            }
            DI_kind::DI_compile_unit => {
                var n = self => DI_compile_unit*;
                n->dump(out);
            }
            DI_kind::DI_basic_type => {
                var n = self => DI_basic_type*;
                n->dump(out);
            }
            DI_kind::DI_enum_type => {
                var n = self => DI_enum_type*;
                n->dump(out);
            }
            DI_kind::DI_enumerator => {
                var n = self => DI_enumerator*;
                n->dump(out);
            }
            _ => unimplemented();
        }
    }
}

pub struct DI_named_metadata {
    base: DI_node,
    name: str,
    nodes: primitive_vec<ptr<DI_node>>
}

impl DI_named_metadata {
    pub func new(name: i8*) -> DI_named_metadata* {
        var res = DI_named_metadata::__alloc__();
        res->base = DI_node::instance(DI_kind::DI_named_metadata, DI_ERROR_INDEX());
        res->name = str::from(name);
        res->nodes = primitive_vec<ptr<DI_node>>::instance();
        return res;
    }

    pub func delete(self) {
        self->name.delete();
        for (var i = self->nodes.iter(); !i.is_end(); i = i.next()) {
            var n = i.get().unwrap();
            n->delete();
            free(n => i8*);
        }
        self->nodes.delete();
    }

    pub func add(self, n: DI_node*) {
        self->nodes.push(ptr<DI_node>::wrap(n));
    }

    pub func dump(self, out: io) {
        out.out("!").out(self->name.c_str).out(" = !{");
        for (var i = self->nodes.iter(); !i.is_end(); i = i.next()) {
            i.get().unwrap()->dump(out);
            if (i.index() != self->nodes.size - 1) {
                out.out(", ");
            }
        }
        out.out("}");
    }
}

pub struct DI_ref_index {
    base: DI_node,
    index: u64
}

impl DI_ref_index {
    pub func new(index: u64) -> DI_ref_index* {
        var res = DI_ref_index::__alloc__();
        res->base = DI_node::instance(DI_kind::DI_ref_index, DI_ERROR_INDEX());
        res->index = index;
        return res;
    }

    pub func dump(self, out: io) {
        out.out("!").out_u64(self->index);
    }
}

pub struct DI_list {
    base: DI_node,
    nodes: primitive_vec<ptr<DI_node>>
}

impl DI_list {
    pub func new(i: u64) -> DI_list* {
        var res = DI_list::__alloc__();
        res->base = DI_node::instance(DI_kind::DI_list, i);
        res->nodes = primitive_vec<ptr<DI_node>>::instance();
        return res;
    }

    pub func delete(self) {
        for (var i = self->nodes.iter(); !i.is_end(); i = i.next()) {
            var n = i.get().unwrap();
            n->delete();
            free(n => i8*);
        }
        self->nodes.delete();
    }

    pub func add(self, n: DI_node*) {
        self->nodes.push(ptr<DI_node>::wrap(n));
    }

    pub func dump(self, out: io) {
        out.out("!{");
        for (var i = self->nodes.iter(); !i.is_end(); i = i.next()) {
            i.get().unwrap()->dump(out);
            if (i.index() != self->nodes.size - 1) {
                out.out(", ");
            }
        }
        out.out("}");
    }
}

pub struct DI_i32 {
    base: DI_node,
    value: i32
}

impl DI_i32 {
    pub func new(value: i32) -> DI_i32* {
        var res = DI_i32::__alloc__();
        res->base = DI_node::instance(DI_kind::DI_i32, DI_ERROR_INDEX());
        res->value = value;
        return res;
    }

    pub func delete(self) {}

    pub func dump(self, out: io) {
        out.out("i32 ").out_i64(self->value => i64);
    }
}

pub struct DI_string {
    base: DI_node,
    value: str
}

impl DI_string {
    pub func new(value: i8*) -> DI_string* {
        var res = DI_string::__alloc__();
        res->base = DI_node::instance(DI_kind::DI_string, DI_ERROR_INDEX());
        res->value = str::from(value);
        return res;
    }

    pub func delete(self) {
        self->value.delete();
    }

    pub func dump(self, out: io) {
        out.out("!\"").out(self->value.c_str).out("\"");
    }
}

pub struct DI_file {
    base: DI_node,
    filename: str,
    directory: str
}

impl DI_file {
    pub func new(i: u64, f: i8*, d: i8*) -> DI_file* {
        var res = DI_file::__alloc__();
        res->base = DI_node::instance(DI_kind::DI_file, i);
        res->filename = str::from(f);
        res->directory = str::from(d);
        return res;
    }

    pub func delete(self) {
        self->filename.delete();
        self->directory.delete();
    }

    pub func dump(self, out: io) {
        out.out("!DIFile(filename: \"").out(self->filename.c_str);
        out.out("\", directory: \"").out(self->directory.c_str).out("\")");
    }
}

pub struct DI_compile_unit {
    base: DI_node,
    producer: str,
    file_index: u64,
    imports_index: u64
}

impl DI_compile_unit {
    pub func new(i: u64, p: i8*, fi: u64) -> DI_compile_unit* {
        var res = DI_compile_unit::__alloc__();
        res->base = DI_node::instance(DI_kind::DI_compile_unit, i);
        res->producer = str::from(p);
        res->file_index = fi;
        res->imports_index = DI_ERROR_INDEX();
        return res;
    }

    pub func delete(self) {
        self->producer.delete();
    }

    pub func dump(self, out: io) {
        out.out("distinct !DICompileUnit(");
        out.out("language: DW_LANG_C99, ");
        out.out("file: !").out_u64(self->file_index).out(", ");
        out.out("producer: \"").out(self->producer.c_str).out("\", ");
        if (self->imports_index != DI_ERROR_INDEX()) {
            out.out("imports: !").out_u64(self->imports_index).out(", ");
        }
        out.out("isOptimized: false)");
    }
}

pub struct DI_basic_type {
    base: DI_node,
    name: str,
    size_in_bits: u64,
    encoding: str
}

impl DI_basic_type {
    pub func new(i: u64, n: i8*, s: u64, e: i8*) -> DI_basic_type* {
        var res = DI_basic_type::__alloc__();
        res->base = DI_node::instance(DI_kind::DI_basic_type, i);
        res->name = str::from(n);
        res->size_in_bits = s;
        res->encoding = str::from(e);
        return res;
    }

    pub func delete(self) {
        self->name.delete();
        self->encoding.delete();
    }

    pub func dump(self, out: io) {
        out.out("!DIBasicType(name: \"").out(self->name.c_str);
        out.out("\", size: ").out_u64(self->size_in_bits).out(", encoding: ");
        out.out(self->encoding.c_str).out(")");
    }
}

pub struct DI_structure_type {
    base: DI_node,
    name: str,
    identifier: str,
    file_index: u64,
    line: u64
}

pub struct DI_enum_type {
    base: DI_node,
    name: str,
    identifier: str,
    file_index: u64,
    line: i64,
    base_type_index: u64,
    elements_index: u64
}

impl DI_enum_type {
    pub func new(i: u64, n: i8*, id: i8*, fi: u64, l: i64, bti: u64) -> DI_enum_type* {
        var res = DI_enum_type::__alloc__();
        res->base = DI_node::instance(DI_kind::DI_enum_type, i);
        res->name = str::from(n);
        res->identifier = str::from(id);
        res->file_index = fi;
        res->line = l;
        res->base_type_index = bti;
        res->elements_index = DI_ERROR_INDEX();
        return res;
    }

    pub func delete(self) {
        self->name.delete();
        self->identifier.delete();
    }

    pub func dump(self, out: io) {
        out.out("!DICompositeType(tag: DW_TAG_enumeration_type, ");
        out.out("name: \"").out(self->name.c_str).out("\", ");
        out.out("file: !").out_u64(self->file_index).out(", ");
        out.out("line: ").out_i64(self->line).out(", ");
        out.out("baseType: !").out_u64(self->base_type_index).out(", ");
        if (self->elements_index != DI_ERROR_INDEX()) {
            out.out("elements: !").out_u64(self->elements_index).out(", ");
        }
        out.out("identifier: \"").out(self->identifier.c_str).out("\")");
    }
}

pub struct DI_enumerator {
    base: DI_node,
    name: str,
    value: i64
}

impl DI_enumerator {
    pub func new(i: u64, n: i8*, v: i64) -> DI_enumerator* {
        var res = DI_enumerator::__alloc__();
        res->base = DI_node::instance(DI_kind::DI_enumerator, i);
        res->name = str::from(n);
        res->value = v;
        return res;
    }

    pub func delete(self) {
        self->name.delete();
    }

    pub func dump(self, out: io) {
        out.out("!DIEnumerator(name: \"").out(self->name.c_str).out("\", ");
        out.out("value: ").out_i64(self->value).out(")");
    }
}

pub struct DI_subprogram {
    base: DI_node,
    name: str,
    file_index: u64,
    line: u64,
    compile_unit_index: u64
}

pub struct DI_location {
    base: DI_node,
    line: u64,
    column: u64,
    scope_index: u64
}
