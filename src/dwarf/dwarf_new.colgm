use std::io::{ io };
use std::str::{ str };
use std::vec::{ vec };
use std::libc::{ free };
use std::panic::{ unimplemented };

use dwarf::dwarf::{ DI_kind, DI_ERROR_INDEX };

pub union(DI_kind) DI_node {
    DI_null: DI_null,
    DI_named_metadata: DI_named_metadata,
    DI_ref_index: DI_ref_index,
    DI_list: DI_list,
    DI_i32: DI_i32,
    DI_string: DI_string,
    DI_file: DI_file,
    DI_compile_unit: DI_compile_unit,
    DI_basic_type: DI_basic_type,
    DI_structure_type: DI_structure_type,
    DI_union_type: DI_union_type,
    DI_enum_type: DI_enum_type,
    DI_enumerator: DI_enumerator,
    DI_subprogram: DI_subprogram,
    DI_subroutine: DI_subroutine,
    DI_location: DI_location,
    DW_TAG_pointer_type: DI_tag_pointer_type,
    DW_TAG_member: DI_tag_member
}

impl DI_node {
    pub func dump(self, out: io) {
        match (self) {
            DI_kind::DI_null => {
                out.out("null");
            }
            DI_kind::DI_named_metadata => {
                self->DI_named_metadata.dump(out);
            }
            DI_kind::DI_ref_index => {
                self->DI_ref_index.dump(out);
            }
            DI_kind::DI_list => {
                self->DI_list.dump(out);
            }
            DI_kind::DI_i32 => {
                self->DI_i32.dump(out);
            }
            DI_kind::DI_string => {
                self->DI_string.dump(out);
            }
            DI_kind::DI_file => {
                self->DI_file.dump(out);
            }
            DI_kind::DI_compile_unit => {
                self->DI_compile_unit.dump(out);
            }
            _ => { unimplemented(); }
        }
    }

    pub func delete(self) {
        // TODO
        match (self) {
            DI_kind::DI_null => {}
            DI_kind::DI_named_metadata => {
                self->DI_named_metadata.delete();
            }
            DI_kind::DI_ref_index => {}
            DI_kind::DI_list => {
                self->DI_list.delete();
            }
            DI_kind::DI_i32 => {}
            DI_kind::DI_string => {
                self->DI_string.delete();
            }
            DI_kind::DI_file => {
                self->DI_file.delete();
            }
            DI_kind::DI_compile_unit => {
                self->DI_compile_unit.delete();
            }
            _ => { unimplemented(); }
        }
    }
}

// for example:
//   null
// expect not to have an index
struct DI_null {}

impl DI_null {
    pub func new() -> DI_node* {
        var res = DI_node::__alloc__();
        res[0] = DI_node { DI_null: DI_null {} };
        return res;
    }
}

// for example:
//   !llvm.ident = !{!0}
//    ^^^^^^^^^^ named metadata uses identifier as the name, not index
struct DI_named_metadata {
    index: u64,
    name: str,
    nodes: vec<DI_node*>
}

impl DI_named_metadata {
    pub func new(name: i8*) -> DI_node* {
        var res = DI_node::__alloc__();
        res[0] = DI_node {
            DI_named_metadata: DI_named_metadata {
                index: DI_ERROR_INDEX(),
                name: str::from(name),
                nodes: vec<DI_node*>::instance()
            }
        };
        return res;
    }

    pub func delete(self) {
        self->name.delete();
        foreach (var i; self->nodes) {
            var n = i.get();
            n->delete();
            free(n => i8*);
        }
        self->nodes.delete();
    }

    pub func add(self, n: DI_node*) {
        self->nodes.push(n);
    }

    pub func dump(self, out: io) {
        out.out("!").out(self->name.c_str).out(" = !{");
        foreach (var i; self->nodes) {
            i.get()->dump(out);
            if (i.index() != self->nodes.size - 1) {
                out.out(", ");
            }
        }
        out.out("}");
    }
}

// for example
//   !1
// expect not to have an index
struct DI_ref_index {
    ref_index: u64
}

impl DI_ref_index {
    pub func new(index: u64) -> DI_node* {
        var res = DI_node::__alloc__();
        res[0] = DI_node {
            DI_ref_index: DI_ref_index { ref_index: index }
        };
        return res;
    }

    pub func dump(self, out: io) {
        out.out("!").out_u64(self->ref_index);
    }
}

// for example
//   !0 = !{ !1, !2, !3 }
struct DI_list {
    index: u64,
    nodes: vec<DI_node*>
}

impl DI_list {
    pub func new(i: u64) -> DI_node* {
        var res = DI_node::__alloc__();
        res[0] = DI_node {
            DI_list: DI_list {
                index: i,
                nodes: vec<DI_node*>::instance()
            }
        };
        return res;
    }

    pub func delete(self) {
        foreach (var i; self->nodes) {
            var n = i.get();
            n->delete();
            free(n => i8*);
        }
        self->nodes.delete();
    }

    pub func add(self, n: DI_node*) {
        self->nodes.push(n);
    }

    pub func dump(self, out: io) {
        out.out("!{");
        foreach (var i; self->nodes) {
            i.get()->dump(out);
            if (i.index() != self->nodes.size - 1) {
                out.out(", ");
            }
        }
        out.out("}");
    }
}

// for example
//   i32 42
// expect not to have an index
struct DI_i32 {
    value: i32
}

impl DI_i32 {
    pub func new(value: i32) -> DI_node* {
        var res = DI_node::__alloc__();
        res[0] = DI_node {
            DI_i32: DI_i32 { value: value }
        };
        return res;
    }

    pub func dump(self, out: io) {
        out.out("i32 ").out_i64(self->value => i64);
    }
}

// for example
//   !"foo"
// expect not to have an index
struct DI_string {
    value: str
}

impl DI_string {
    pub func new(value: i8*) -> DI_node* {
        var res = DI_node::__alloc__();
        res[0] = DI_node {
            DI_string: DI_string { value: str::from(value) }
        };
        return res;
    }

    pub func delete(self) {
        self->value.delete();
    }

    pub func dump(self, out: io) {
        out.out("!\"").out(self->value.c_str).out("\"");
    }
}

// for example
//   !0 = !DIFile(filename: "src/std/libc.colgm", directory: "/usr/lib/colgm")
struct DI_file {
    index: u64,
    filename: str,
    directory: str
}

impl DI_file {
    pub func new(i: u64, f: i8*, d: i8*) -> DI_node* {
        var res = DI_node::__alloc__();
        res[0] = DI_node {
            DI_file: DI_file {
                index: i,
                filename: str::from(f),
                directory: str::from(d)
            }
        };
        return res;
    }

    pub func delete(self) {
        self->filename.delete();
        self->directory.delete();
    }

    pub func dump(self, out: io) {
        out.out("!DIFile(filename: \"").out(self->filename.c_str);
        out.out("\", directory: \"").out(self->directory.c_str).out("\")");
    }
}

struct DI_compile_unit {
    index: u64,
    producer: str,
    file_index: u64,
    imports_index: u64,
    enums_index: u64
}

impl DI_compile_unit {
    pub func new(i: u64, p: i8*, fi: u64) -> DI_node* {
        var res = DI_node::__alloc__();
        res[0] = DI_node {
            DI_compile_unit: DI_compile_unit {
                index: i,
                producer: str::from(p),
                file_index: fi,
                imports_index: DI_ERROR_INDEX(),
                enums_index: DI_ERROR_INDEX()
            }
        };
        return res;
    }

    pub func delete(self) {
        self->producer.delete();
    }

    pub func dump(self, out: io) {
        out.out("distinct !DICompileUnit(");
        out.out("language: DW_LANG_C99, ");
        out.out("file: !").out_u64(self->file_index).out(", ");
        out.out("producer: \"").out(self->producer.c_str).out("\", ");
        if (self->imports_index != DI_ERROR_INDEX()) {
            out.out("imports: !").out_u64(self->imports_index).out(", ");
        }
        if (self->enums_index != DI_ERROR_INDEX()) {
            out.out("enums: !").out_u64(self->enums_index).out(", ");
        }
        out.out("isOptimized: false, runtimeVersion: 0, emissionKind: FullDebug)");
    }
}

struct DI_basic_type {
    index: u64,
    name: str,
    size_in_bits: u64,
    encoding: str
}

struct DI_structure_type {
    index: u64,
    name: str,
    identifier: str,
    file_index: u64,
    line: i64,
    elements: u64
}

struct DI_union_type {
    index: u64,
    name: str,
    identifier: str,
    file_index: u64,
    line: i64,
    elements: u64
}

struct DI_enum_type {
    index: u64,
    name: str,
    identifier: str,
    file_index: u64,
    line: i64,
    base_type_index: u64,
    elements_index: u64
}

struct DI_enumerator {
    index: u64,
    name: str,
    value: i64
}

struct DI_subprogram {
    index: u64,
    name: str,
    file_index: u64,
    line: i64,
    type_index: u64,
    compile_unit_index: u64
}

struct DI_subroutine {
    index: u64,
    types_index: u64
}

struct DI_location {
    index: u64,
    file: str,
    line: i64,
    column: i64,
    scope_index: u64
}

struct DI_tag_pointer_type {
    index: u64,
    base_type_index: u64,
    size: u64,
    name: str
}

struct DI_tag_member {
    index: u64,
    name: str,
    scope_index: u64,
    file_index: u64,
    line: i64,
    base_type_index: u64
}