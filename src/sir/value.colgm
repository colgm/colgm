use std::str::{ str };
use std::io::{ io };

pub enum value_kind {
    null,
    variable,
    literal
}

pub struct value_t {
    kind: value_kind,
    content: str
}

impl value_t {
    pub func instance(kind: value_kind, content: const i8*) -> value_t {
        return value_t { kind: kind, content: str::from(content) };
    }

    pub func delete(self) {
        self.content.delete();
    }

    pub func clone(self) -> value_t {
        return value_t { kind: self.kind, content: self.content.clone() };
    }

    pub func dump(self, out: io&) {
        match (self.kind) {
            value_kind::null => {
                if (!self.content.empty()) {
                    out.out("<null: ").out(self.content.c_str).out(">");
                }
            }
            value_kind::variable => out.out("%").out(self.content.c_str);
            value_kind::literal => out.out(self.content.c_str);
        }
    }
}

impl value_t {
    pub func null(name: const i8*) -> value_t {
        if (name == nil) {
            return value_t::instance(value_kind::null, "");
        }
        return value_t::instance(value_kind::null, name);
    }

    pub func variable(name: str&) -> value_t {
        return value_t::instance(value_kind::variable, name.c_str);
    }

    pub func literal(name: str&) -> value_t {
        return value_t::instance(value_kind::literal, name.c_str);
    }
}