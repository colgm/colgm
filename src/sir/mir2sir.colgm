use std::pair::{ pair };
use std::map::{ hashmap };
use std::str::{ str };
use std::io::{ io };
use std::vec::{ vec };
use std::fs::{ fs };
use std::libc::{ streq };
use std::panic::{ panic, unreachable };

use mir::mir::*;
use mir::context::{ mir_context, mir_func };
use sir::ssa_name_gen::{ ssa_generator };
use sir::local_scope::{ local_table };
use sir::sir::*;
use sir::context::{ sir_tagged_union, sir_struct, sir_func, sir_context };
use sir::value::{ value_t };
use sir::pass::adjust_va_arg::{ adjust_va_arg };
use sir::pass::replace_call::{ replace_ptr_call, replace_size_call };
use sir::pass::size_calc::{ size_calc };
use sir::pass::detect_redef_extern::{ detect_redef_extern };
use sir::pass::remove_unused_func::{ remove_unused_func };
use sir::pass::remove_unused_string::{ remove_unused_string };
use sir::pass::remove_unused_ssa::{ remove_unused_ssa };
use sir::pass::simplify_cfg::{ simplify_cfg };
use sir::pass::inst_combine::{ inst_combine, replace_const_br, combine_load_store };
use sir::pass::variable_rename::{ variable_rename_to_form_ssa };

use dwarf::dwarf::*;
use dwarf::status::{ DWARF_status };

use sema::symbol_info::{ symbol_kind };
use sema::enumerate::{ colgm_enum };
use sema::structure::{ colgm_struct };
use sema::tagged_union::{ colgm_tagged_union };
use sema::context::{ sema_context };
use sema::type::{ type };

use err::span::{ span };
use err::report::{ report };

use util::package::{ package };
use util::platform::{ get_platform };
use util::cli::{ version };
use util::mangling::{
    mangle_struct_name,
    mangle_tagged_union_name,
    mangle_function_name
};
use util::timestamp::{ timestamp, maketimestamp };

enum mir_value_kind {
    null, // reserved
    nil_value,
    variable,
    literal,
    primitive,
    func_symbol,
    method,
    struct_symbol,
    tagged_union_symbol,
    enum_symbol
}

struct mir_value_t {
    value_kind: mir_value_kind,
    content: str,
    resolved_type: type
}

impl mir_value_t {
    pub func clone(self) -> mir_value_t {
        return mir_value_t {
            value_kind: self.value_kind,
            content: self.content.clone(),
            resolved_type: self.resolved_type.clone()
        };
    }

    pub func delete(self) {
        self.content.delete();
        self.resolved_type.delete();
    }

    pub func to_value_t(self) -> value_t {
        match (self.value_kind) {
            mir_value_kind::null => return value_t::null("null");
            mir_value_kind::nil_value => return value_t::literal(self.content);
            mir_value_kind::literal => return value_t::literal(self.content);
            mir_value_kind::variable => return value_t::variable(self.content);
            mir_value_kind::primitive => return value_t::null("primitive");
            mir_value_kind::func_symbol => return value_t::null("func");
            mir_value_kind::method => return value_t::null("method");
            mir_value_kind::struct_symbol => return value_t::null("struct");
            mir_value_kind::tagged_union_symbol => return value_t::null("tagged_union");
            mir_value_kind::enum_symbol => return value_t::null("enum");
        }
        // unreachable
        return value_t::null(nil);
    }

    func nil_value(ty: type&) -> mir_value_t {
        return mir_value_t {
            value_kind: mir_value_kind::nil_value,
            content: str::from("null"),
            resolved_type: ty.clone()
        };
    }

    func variable(name: str&, ty: type&) -> mir_value_t {
        return mir_value_t {
            value_kind: mir_value_kind::variable,
            content: name.clone(),
            resolved_type: ty.clone()
        };
    }

    func literal(value: str&, ty: type&) -> mir_value_t {
        return mir_value_t {
            value_kind: mir_value_kind::literal,
            content: value.clone(),
            resolved_type: ty.clone()
        };
    }

    func primitive(value: str&, ty: type&) -> mir_value_t {
        return mir_value_t {
            value_kind: mir_value_kind::primitive,
            content: value.clone(),
            resolved_type: ty.clone()
        };
    }

    func func_symbol(name: str&, ty: type&) -> mir_value_t {
        return mir_value_t {
            value_kind: mir_value_kind::func_symbol,
            content: name.clone(),
            resolved_type: ty.clone()
        };
    }

    func method(name: str&, ty: type&) -> mir_value_t {
        return mir_value_t {
            value_kind: mir_value_kind::method,
            content: name.clone(),
            resolved_type: ty.clone()
        };
    }

    func struct_symbol(name: str&, ty: type&) -> mir_value_t {
        return mir_value_t {
            value_kind: mir_value_kind::struct_symbol,
            content: name.clone(),
            resolved_type: ty.clone()
        };
    }

    func tagged_union_symbol(name: str&, ty: type&) -> mir_value_t {
        return mir_value_t {
            value_kind: mir_value_kind::tagged_union_symbol,
            content: name.clone(),
            resolved_type: ty.clone()
        };
    }

    func enum_symbol(name: str&, ty: type&) -> mir_value_t {
        return mir_value_t {
            value_kind: mir_value_kind::enum_symbol,
            content: name.clone(),
            resolved_type: ty.clone()
        };
    }
}

pub struct mir2sir {
    ctx: sema_context*,
    sctx: sir_context*,
    pkg: package*,
    err: report*,
    sc: size_calc,
    type_mapper: hashmap<str, symbol_kind>,
    basic_type_mapper: hashmap<str, str>,
    primitive_methods: hashmap<str, str>,

    func_block: sir_block*,
    alloca_block: sir_basic_block*,
    move_reg_block: sir_basic_block*,
    block: sir_basic_block*,
    ssa_gen: ssa_generator,
    array_ssa_gen: ssa_generator,
    var_ssa_suffix: u64,
    label_gen: ssa_generator,

    value_stack: vec<mir_value_t>,

    locals: local_table,

    continue_inst: vec<vec<sir_br*>>,
    break_inst: vec<vec<sir_br*>>,
    branch_jump_out: vec<vec<sir_br*>>,

    dwarf_status: DWARF_status
}

impl mir2sir {
    pub func instance(ctx: sema_context*,
                      sctx: sir_context*,
                      pkg: package*,
                      err: report*) -> mir2sir {
        var res = mir2sir {
            ctx: ctx,
            sctx: sctx,
            pkg: pkg,
            err: err,
            sc: size_calc::instance(pkg),
            type_mapper: hashmap<str, symbol_kind>::instance(),
            basic_type_mapper: hashmap<str, str>::instance(),
            primitive_methods: hashmap<str, str>::instance(),
            func_block: nil,
            alloca_block: nil,
            move_reg_block: nil,
            block: nil,
            ssa_gen: ssa_generator::instance(),
            array_ssa_gen: ssa_generator::instance(),
            var_ssa_suffix: 0,
            label_gen: ssa_generator::instance(),
            value_stack: vec<mir_value_t>::instance(),
            locals: local_table::instance(),
            continue_inst: vec<vec<sir_br*>>::instance(),
            break_inst: vec<vec<sir_br*>>::instance(),
            branch_jump_out: vec<vec<sir_br*>>::instance(),
            dwarf_status: DWARF_status::instance()
        };
        res.init_basic_type_mapper();
        res.init_primitive_size_methods();
        return res;
    }

    pub func delete(self) {
        self.sc.delete();
        self.type_mapper.delete();
        self.basic_type_mapper.delete();
        self.primitive_methods.delete();
        self.value_stack.delete();
        self.locals.delete();

        // do not need to delete ptr in them
        // all ptrs are inserted into sir_func's body
        self.continue_inst.delete();
        self.break_inst.delete();
        self.branch_jump_out.delete();

        self.dwarf_status.delete();
    }

    func init_basic_type_mapper(self) {
        var type_list = [
            "i64", "i32", "i16", "i8",
            "u64", "u32", "u16", "u8",
            "f64", "f32", "void", "bool",
            nil
        ];
        var real_type_list = [
            "i64", "i32", "i16", "i8",
            "i64", "i32", "i16", "i8",
            "double", "float", "void", "i1",
            nil
        ];
        for (var i = 0; type_list[i] != nil; i += 1) {
            var type_name = str::from(type_list[i]);
            var real_name = str::from(real_type_list[i]);
            defer {
                type_name.delete();
                real_name.delete();
            }
            self.basic_type_mapper.insert(type_name, real_name);
        }
    }

    func init_primitive_size_methods(self) {
        var type_list = [
            "i64", "i32", "i16", "i8",
            "u64", "u32", "u16", "u8",
            "f64", "f32", "bool", nil
        ];
        var size_list = [
            "8", "4", "2", "1",
            "8", "4", "2", "1",
            "8", "4", "1", nil
        ];
        for (var i = 0; type_list[i] != nil; i += 1) {
            var name = str::from(type_list[i]);
            name.append(".__size__");
            var size_str = str::from(size_list[i]);
            defer {
                name.delete();
                size_str.delete();
            }

            self.primitive_methods.insert(name, size_str);
        }
    }
}

impl mir2sir {
    func emit_tagged_union(self, mctx: mir_context&) {
        foreach (var i; mctx.tagged_unions) {
            var m_un = i.get();

            var s_ty = type::instance(m_un.name.c_str, m_un.location.file.c_str);
            defer s_ty.delete();

            var s_ty_name = s_ty.full_path_name(self.pkg);
            var s_ty_llvm_name = mangle_tagged_union_name(s_ty_name);
            defer {
                s_ty_name.delete();
                s_ty_llvm_name.delete();
            }

            var s_un = sir_tagged_union::instance(
                s_ty_llvm_name,
                m_un.location,
                m_un.total_size,
                m_un.align
            );
            defer s_un.delete();

            if (m_un.max_align_type.is_array) {
                var mapped_type = self.array_type_mapping(
                    m_un.max_align_type
                );
                defer mapped_type.delete();

                s_un.member_type.push(mapped_type);
            } else {
                var mapped_type = self.type_mapping(
                    m_un.max_align_type
                );
                defer mapped_type.delete();

                s_un.member_type.push(mapped_type);
            }

            if (m_un.union_size > m_un.max_align_type_size) {
                var char_arr_size =  m_un.union_size - m_un.max_align_type_size;
                var char_arr_ty = str::from("[");
                char_arr_ty.append_u64(char_arr_size);
                char_arr_ty.append(" x i8]");
                defer char_arr_ty.delete();

                s_un.member_type.push(char_arr_ty);
            }

            self.sctx->tagged_union_decls.push(s_un);
        }
    }

    func emit_struct(self, mctx: mir_context&) {
        foreach (var i; mctx.structs) {
            var m_stct = i.get();

            var s_ty = type::instance(m_stct.name.c_str, m_stct.location.file.c_str);
            defer s_ty.delete();

            var s_ty_name = s_ty.full_path_name(self.pkg);
            var s_ty_llvm_name = mangle_struct_name(s_ty_name);
            defer {
                s_ty_name.delete();
                s_ty_llvm_name.delete();
            }

            var s_stct = sir_struct::instance(
                s_ty_llvm_name,
                m_stct.location,
                m_stct.size,
                m_stct.align
            );
            defer s_stct.delete();

            foreach (var j; m_stct.field_type) {
                var m_field = j.get();
                if (m_field.is_array) {
                    var mapped_type = self.array_type_mapping(m_field);
                    defer mapped_type.delete();

                    s_stct.field_type.push(mapped_type);
                } else {
                    var mapped_type = self.type_mapping(m_field);
                    defer mapped_type.delete();

                    s_stct.field_type.push(mapped_type);
                }
            }

            self.sctx->struct_decls.push(s_stct);
        }
    }

    func emit_func_decl(self, mctx: mir_context&) {
        foreach (var i; mctx.decls) {
            var m_func = i.get();
            var s_func = sir_func::instance(m_func.name, m_func.location);
            s_func.set_attributes(m_func.attributes);
            s_func.with_va_args = m_func.with_va_args;
            defer s_func.delete();

            var ret_type_name = self.type_mapping(m_func.return_type);
            defer ret_type_name.delete();

            s_func.return_type.append_str(ret_type_name);

            foreach (var j; m_func.params) {
                var m_param = j.get();

                var mapped_type = self.type_mapping(m_param.value);
                defer mapped_type.delete();

                var p_pair = pair<str, str>::instance(m_param.key, mapped_type);
                defer p_pair.delete();

                s_func.params.push(p_pair);
            }

            self.sctx->func_decls.push(s_func);
        }
    }

    func process_print(self, curr: u64, total: u64, ts: timestamp&) {
        if (curr + 1 != total && (curr + 1) % 35 != 0) {
            return;
        }

        var elapsed_msec = ts.elapsed_msec();
        var remaining_sec = (
            elapsed_msec
            * ((total - curr - 1) => f64)
            / ((curr + 1) => f64)
            / 1000.0
        ) => i64;
        var percent = (curr => f64 + 1.0) * 100.0 / (total => f64);
        var stdout = io::stdout();

        stdout.out("\e[2K").green().out("   MIR2SIR ").reset();
        stdout.out("Generating function ");
        if (curr + 1 != total) {
            stdout.orange();
        } else {
            stdout.cyan();
        }
        stdout.out_u64(percent => u64).out("%").reset();
        if (curr + 1 != total) {
            stdout.out(" in ").cyan().out_i64(remaining_sec).reset().out(" s\r");
            return;
        }

        var generation_duration = ts.elapsed_msec();
        if (generation_duration < 1000.0) {
            stdout.out(" ").out_f64(generation_duration).out(" ms\n");
        } else {
            stdout.out(" ").out_f64(generation_duration / 1000.0).out(" s\n");
        }
    }

    func emit_func_impl(self, mctx: mir_context&) {
        var ts = maketimestamp();
        ts.stamp();

        foreach (var i; mctx.impls) {
            self.process_print(i.index(), mctx.impls.size, ts);
            var m_func = i.get();
            var m_mangled_name = mangle_function_name(m_func.name);
            defer m_mangled_name.delete();

            var s_func = sir_func::instance(m_mangled_name, m_func.location);
            s_func.set_attributes(m_func.attributes);
            defer s_func.delete();

            var ret_type_name = self.type_mapping(m_func.return_type);
            defer ret_type_name.delete();
            s_func.return_type.append_str(ret_type_name);

            // push local scope
            self.locals.push();

            foreach (var j; m_func.params) {
                var m_param = j.get();
                var mapped_type = self.type_mapping(m_param.value);
                defer mapped_type.delete();

                var param_name = m_param.key.clone();
                param_name.append(".param");
                defer param_name.delete();

                self.locals.insert(m_param.key, m_param.key);

                var p_pair = pair<str, str>::instance(param_name, mapped_type);
                defer p_pair.delete();

                s_func.params.push(p_pair);
            }

            // if debug mode is enabled, scope_index should not be DI_ERROR_INDEX
            if (self.dwarf_status.impl_debug_info.has(m_func.name)) {
                self.dwarf_status.scope_index = self.dwarf_status
                                                     .impl_debug_info
                                                     .get(m_func.name);
                s_func.debug_info_index = self.dwarf_status.scope_index;
            } else {
                self.dwarf_status.scope_index = DI_ERROR_INDEX();
            }

            // init ssa generator
            self.ssa_gen.clear();
            self.array_ssa_gen.clear();
            self.var_ssa_suffix = 0;
            self.label_gen.clear();

            // clear value stack
            self.value_stack.clear();

            // generate code block
            s_func.body = sir_block::new();
            self.func_block = s_func.body;
            self.alloca_block = sir_basic_block::new(self.label_gen.create_index(), "bb.alloca");
            self.move_reg_block = sir_basic_block::new(self.label_gen.create_index(), "bb.move_reg");
            self.block = sir_basic_block::new(self.label_gen.create_index(), "bb.entry");
            var entry = self.block->label;

            // insert basic blocks
            self.func_block->add_basic_block(self.alloca_block);
            self.func_block->add_basic_block(self.move_reg_block);
            self.func_block->add_basic_block(self.block);

            // generate code
            self.generate_func_impl_from_mir_func(m_func);

            // insert br inst
            self.alloca_block->add_stmt(sir_br::new(self.move_reg_block->label) => sir*);
            self.move_reg_block->add_stmt(sir_br::new(entry) => sir*);

            // clear block
            self.func_block = nil;
            self.alloca_block = nil;
            self.move_reg_block = nil;
            self.block = nil;

            self.sctx->func_impls.push(s_func);

            // pop local scope
            self.locals.pop();
        }
    }
}

impl mir2sir {
    func generate_type_mapper(self) {
        foreach (var i; self.ctx->global->domain) {
            var dm = i.value();
            foreach (var j; dm.enums) {
                var e_type = type::instance(j.value().name.c_str, j.value().location.file.c_str);
                defer e_type.delete();

                var e_name = e_type.full_path_name(self.pkg);
                defer e_name.delete();

                self.type_mapper.insert(e_name, symbol_kind::enum_kind);
            }
            foreach (var j; dm.structs) {
                var s_type = type::instance(j.value().name.c_str, j.value().location.file.c_str);
                defer s_type.delete();

                var s_name = s_type.full_path_name(self.pkg);
                defer s_name.delete();

                self.type_mapper.insert(s_name, symbol_kind::struct_kind);
            }
            foreach (var j; dm.tagged_unions) {
                var tu_type = type::instance(j.value().name.c_str, j.value().location.file.c_str);
                defer tu_type.delete();

                var tu_name = tu_type.full_path_name(self.pkg);
                defer tu_name.delete();

                self.type_mapper.insert(tu_name, symbol_kind::tagged_union_kind);
            }
        }
    }

    func type_mapping(self, t: type&) -> str {
        var copy = t.clone();
        defer copy.delete();

        // basic type mapping
        if (self.basic_type_mapper.has(copy.name)) {
            var replace = self.basic_type_mapper.get(copy.name);
            copy.name.clear();
            copy.name.append_str(replace);
            copy.loc_file.clear();

            var res = copy.llvm_type_name(self.pkg);
            // copy will delete here, do not merge definition with return statement
            return res;
        }

        var full_name = t.full_path_name(self.pkg);
        defer full_name.delete();

        // if not found, let it crash
        if (!self.type_mapper.has(full_name)) {
            var info = str::from("type not found: \"");
            defer info.delete();

            info.append_str(full_name).append("\"");
            panic(info.c_str);
        }

        match (self.type_mapper.get(full_name)) {
            symbol_kind::struct_kind => {
                var new_name = mangle_struct_name(full_name);
                defer new_name.delete();

                copy.name.clear();
                copy.name.append_str(new_name);
                // need to clear loc_file info
                // otherwise for example:
                // std::vec<data::foo>
                //
                // will be wrongly mapped to
                // std::%struct.std.vec<data::foo>
                // but expect to be
                // %struct.std.vec<data::foo>
                copy.loc_file.clear();
                // here we need to clear generic info
                // otherwise for example:
                // std::vec<data::foo>
                //
                // will be wrongly mapped to
                // %struct.std.vec<data::foo><data::foo>
                //         ^^^^^^^^^^^^^^^^^^ name
                //                           ^^^^^^^^^^^ generated from generics
                //
                // but expect to be
                // %struct.std.vec<data::foo>
                copy.generics.clear();
            }
            symbol_kind::tagged_union_kind => {
                var new_name = mangle_tagged_union_name(full_name);
                defer new_name.delete();

                copy.name.clear();
                copy.name.append_str(new_name);
                copy.loc_file.clear();
            }
            symbol_kind::enum_kind => {
                var i64_t = type::i64_type();
                defer i64_t.delete();

                // should copy pointer depth too
                i64_t.pointer_depth = copy.pointer_depth;
                copy.reset_with(i64_t);
            }
            _ => {
                panic("unsupported type kind");
            }
        }

        var res = copy.llvm_type_name(self.pkg);
        // copy will delete here, do not merge definition with return statement
        return res;
    }

    func array_type_mapping(self, t: type&) -> str {
        if (!t.is_array) {
            panic("not array type");
        }

        var copy = t.ref_copy();
        copy.is_array = false;
        defer copy.delete();

        var mapped_type = self.type_mapping(copy);
        defer mapped_type.delete();

        var array_name = str::from("[");
        array_name.append_u64(copy.array_length).append(" x ");
        array_name.append_str(mapped_type).append("]");
        return array_name;
    }
}

impl mir2sir {
    func generate_func_impl_from_mir_func(self, m_func: mir_func&) {
        foreach (var i; m_func.params) {
            var m_param = i.get();
            var mapped_type = self.type_mapping(m_param.value);
            defer mapped_type.delete();

            var param_name = m_param.key.clone();
            param_name.append(".param");
            defer param_name.delete();

            self.alloca_block->add_stmt(sir_alloca::new(m_param.key, mapped_type) => sir*);

            var source = value_t::variable(param_name);
            var target = value_t::variable(m_param.key);
            defer {
                source.delete();
                target.delete();
            }

            self.block->add_stmt(sir_store::new(
                mapped_type,
                source,
                target,
                DI_ERROR_INDEX()
            ) => sir*);
        }

        self.visit_mir_block(m_func.block);
    }
}

impl mir2sir {
    func push_mir_value_variable(self, name: str&, ty: type&) {
        var v = mir_value_t::variable(name, ty);
        defer v.delete();
        self.value_stack.push(v);
    }

    func push_mir_value_method(self, name: str&, ty: type&) {
        var v = mir_value_t::method(name, ty);
        defer v.delete();
        self.value_stack.push(v);
    }
}

impl mir2sir {
    func visit_mir_block(self, n: mir_block*) {
        // push local scope
        self.locals.push();

        foreach (var i; n->content) {
            self.visit(i.get());
        }

        // pop local scope
        self.locals.pop();
    }

    func visit_mir_unary(self, n: mir_unary*) {
        self.visit(n->value => mir*);

        var source = self.value_stack.back().clone();
        defer source.delete();
        self.value_stack.pop_back();

        var source_value = source.to_value_t();
        defer source_value.delete();
        var source_ty = self.type_mapping(source.resolved_type);
        defer source_ty.delete();

        var target_value = self.ssa_gen.create_variable();
        defer target_value.delete();

        if (n->op == mir_unary_opr::neg) {
            self.block->add_stmt(sir_neg::new(
                source_value,
                target_value,
                source.resolved_type.is_integer(),
                source_ty,
                self.generate_DI_location(n->base.location)
            ) => sir*);
        } else if (n->op == mir_unary_opr::bnot) {
            self.block->add_stmt(sir_bnot::new(
                source_value,
                target_value,
                source_ty,
                self.generate_DI_location(n->base.location)
            ) => sir*);
        } else if (n->op == mir_unary_opr::lnot) {
            self.block->add_stmt(sir_lnot::new(
                source_value,
                target_value,
                source_ty
            ) => sir*);
        }

        self.push_mir_value_variable(target_value.content, n->resolved_type);
    }

    func generate_and(self, n: mir_binary*) {
        var i1_name = str::from("i1");
        var temp_0 = self.ssa_gen.create_variable();
        defer {
            i1_name.delete();
            temp_0.delete();
        }

        self.move_reg_block->add_stmt(sir_alloca::new(temp_0.content, i1_name) => sir*);
        self.visit(n->left => mir*);

        var left_value = self.value_stack.back().to_value_t();
        defer left_value.delete();
        self.value_stack.pop_back();

        self.block->add_stmt(sir_store::new(
            i1_name,
            left_value,
            temp_0,
            self.generate_DI_location(n->left->location)
        ) => sir*);

        var true_label = self.label_gen.create_index();
        var br_cond = sir_br_cond::new(
            left_value,
            true_label,
            0
        );
        self.block->add_stmt(br_cond => sir*);

        var and_true_block = sir_basic_block::new(true_label, "and.true");
        self.func_block->add_basic_block(and_true_block);
        self.block = and_true_block;

        self.visit(n->right => mir*);

        var right_value = self.value_stack.back().to_value_t();
        defer right_value.delete();
        self.value_stack.pop_back();

        self.block->add_stmt(sir_store::new(
            i1_name,
            right_value,
            temp_0,
            self.generate_DI_location(n->right->location)
        ) => sir*);

        var false_label = self.label_gen.create_index();
        self.block->add_stmt(sir_br::new(false_label) => sir*);
        br_cond->label_false = false_label;

        var and_false_block = sir_basic_block::new(false_label, "and.false");
        self.func_block->add_basic_block(and_false_block);
        self.block = and_false_block;

        var temp_1 = self.ssa_gen.create_variable();
        defer temp_1.delete();

        and_false_block->add_stmt(sir_load::new(
            i1_name,
            temp_0,
            temp_1
        ) => sir*);

        self.push_mir_value_variable(temp_1.content, n->resolved_type);
    }

    func generate_or(self, n: mir_binary*) {
        var i1_name = str::from("i1");
        var temp_0 = self.ssa_gen.create_variable();
        defer {
            i1_name.delete();
            temp_0.delete();
        }

        self.move_reg_block->add_stmt(sir_alloca::new(temp_0.content, i1_name) => sir*);
        self.visit(n->left => mir*);

        var left_value = self.value_stack.back().to_value_t();
        defer left_value.delete();
        self.value_stack.pop_back();

        self.block->add_stmt(sir_store::new(
            i1_name,
            left_value,
            temp_0,
            self.generate_DI_location(n->left->location)
        ) => sir*);

        var false_label = self.label_gen.create_index();
        var br_cond = sir_br_cond::new(
            left_value,
            0,
            false_label
        );
        self.block->add_stmt(br_cond => sir*);

        var or_false_block = sir_basic_block::new(false_label, "or.false");
        self.func_block->add_basic_block(or_false_block);
        self.block = or_false_block;

        self.visit(n->right => mir*);

        var right_value = self.value_stack.back().to_value_t();
        defer right_value.delete();
        self.value_stack.pop_back();

        self.block->add_stmt(sir_store::new(
            i1_name,
            right_value,
            temp_0,
            self.generate_DI_location(n->right->location)
        ) => sir*);

        var true_label = self.label_gen.create_index();
        self.block->add_stmt(sir_br::new(true_label) => sir*);
        br_cond->label_true = true_label;

        var or_true_block = sir_basic_block::new(true_label, "or.true");
        self.func_block->add_basic_block(or_true_block);
        self.block = or_true_block;

        var temp_1 = self.ssa_gen.create_variable();
        defer temp_1.delete();

        or_true_block->add_stmt(sir_load::new(
            i1_name,
            temp_0,
            temp_1
        ) => sir*);

        self.push_mir_value_variable(temp_1.content, n->resolved_type);
    }

    func visit_mir_binary(self, n: mir_binary*) {
        if (n->op == mir_binary_opr::cmpand) {
            self.generate_and(n);
            return;
        } else if (n->op == mir_binary_opr::cmpor) {
            self.generate_or(n);
            return;
        }

        self.visit(n->left => mir*);
        var left = self.value_stack.back().clone();
        var left_value = left.to_value_t();
        var left_ty = self.type_mapping(left.resolved_type);
        defer {
            left.delete();
            left_value.delete();
            left_ty.delete();
        }
        self.value_stack.pop_back();

        self.visit(n->right => mir*);
        var right = self.value_stack.back().clone();
        var right_value = right.to_value_t();
        defer {
            right.delete();
            right_value.delete();
        }
        self.value_stack.pop_back();

        var target = self.ssa_gen.create_variable();
        defer target.delete();

        var flag_is_integer = left.resolved_type.is_integer() ||
                              left.resolved_type.is_pointer() ||
                              left.resolved_type.is_bool() ||
                              left_ty.eq_const("i64"); // enum type

        match (n->op) {
            mir_binary_opr::add => {
                if (left.resolved_type.is_integer()) {
                    self.block->add_stmt(sir_add::new(
                        left_value,
                        right_value,
                        target,
                        left_ty,
                        self.generate_DI_location(n->base.location),
                        "+"
                    ) => sir*);
                } else {
                    self.block->add_stmt(sir_fadd::new(
                        left_value,
                        right_value,
                        target,
                        left_ty,
                        self.generate_DI_location(n->base.location),
                        "+"
                    ) => sir*);
                }
            }
            mir_binary_opr::sub => {
                self.block->add_stmt(sir_sub::new(
                    left_value,
                    right_value,
                    target,
                    left.resolved_type.is_integer(),
                    left_ty
                ) => sir*);
            }
            mir_binary_opr::mul => {
                self.block->add_stmt(sir_mul::new(
                    left_value,
                    right_value,
                    target,
                    left.resolved_type.is_integer(),
                    left_ty
                ) => sir*);
            }
            mir_binary_opr::div => {
                self.block->add_stmt(sir_div::new(
                    left_value,
                    right_value,
                    target,
                    left.resolved_type.is_integer(),
                    !left.resolved_type.is_unsigned(),
                    left_ty
                ) => sir*);
            }
            mir_binary_opr::rem => {
                self.block->add_stmt(sir_rem::new(
                    left_value,
                    right_value,
                    target,
                    left.resolved_type.is_integer(),
                    !left.resolved_type.is_unsigned(),
                    left_ty
                ) => sir*);
            }
            mir_binary_opr::band => {
                self.block->add_stmt(sir_band::new(
                    left_value,
                    right_value,
                    target,
                    left_ty
                ) => sir*);
            }
            mir_binary_opr::bxor => {
                self.block->add_stmt(sir_bxor::new(
                    left_value,
                    right_value,
                    target,
                    left_ty
                ) => sir*);
            }
            mir_binary_opr::bor => {
                self.block->add_stmt(sir_bor::new(
                    left_value,
                    right_value,
                    target,
                    left_ty
                ) => sir*);
            }
            mir_binary_opr::cmpeq => {
                self.block->add_stmt(sir_cmp::new(
                    sir_cmp_kind::cmp_eq,
                    left_value,
                    right_value,
                    target,
                    flag_is_integer,
                    !left.resolved_type.is_unsigned(),
                    left_ty,
                    self.generate_DI_location(n->base.location)
                ) => sir*);
            }
            mir_binary_opr::cmpne => {
                self.block->add_stmt(sir_cmp::new(
                    sir_cmp_kind::cmp_neq,
                    left_value,
                    right_value,
                    target,
                    flag_is_integer,
                    !left.resolved_type.is_unsigned(),
                    left_ty,
                    self.generate_DI_location(n->base.location)
                ) => sir*);
            }
            mir_binary_opr::grt => {
                self.block->add_stmt(sir_cmp::new(
                    sir_cmp_kind::cmp_gt,
                    left_value,
                    right_value,
                    target,
                    left.resolved_type.is_integer(),
                    !left.resolved_type.is_unsigned(),
                    left_ty,
                    self.generate_DI_location(n->base.location)
                ) => sir*);
            }
            mir_binary_opr::geq => {
                self.block->add_stmt(sir_cmp::new(
                    sir_cmp_kind::cmp_ge,
                    left_value,
                    right_value,
                    target,
                    left.resolved_type.is_integer(),
                    !left.resolved_type.is_unsigned(),
                    left_ty,
                    self.generate_DI_location(n->base.location)
                ) => sir*);
            }
            mir_binary_opr::less => {
                self.block->add_stmt(sir_cmp::new(
                    sir_cmp_kind::cmp_lt,
                    left_value,
                    right_value,
                    target,
                    left.resolved_type.is_integer(),
                    !left.resolved_type.is_unsigned(),
                    left_ty,
                    self.generate_DI_location(n->base.location)
                ) => sir*);
            }
            mir_binary_opr::leq => {
                self.block->add_stmt(sir_cmp::new(
                    sir_cmp_kind::cmp_le,
                    left_value,
                    right_value,
                    target,
                    left.resolved_type.is_integer(),
                    !left.resolved_type.is_unsigned(),
                    left_ty,
                    self.generate_DI_location(n->base.location)
                ) => sir*);
            }
            _ => {}
        }

        self.push_mir_value_variable(target.content, n->resolved_type);
    }

    func visit_mir_type_convert(self, n: mir_type_convert*) {
        self.visit(n->source => mir*);

        var source = self.value_stack.back().clone();
        defer source.delete();
        self.value_stack.pop_back();

        var source_value = source.to_value_t();
        var temp_var = self.ssa_gen.create_variable();
        var source_ty = self.type_mapping(source.resolved_type);
        var n_ty = self.type_mapping(n->target);
        defer {
            source_value.delete();
            temp_var.delete();
            source_ty.delete();
            n_ty.delete();
        }

        self.block->add_stmt(sir_type_convert::new(
            source_value,
            temp_var,
            source_ty,
            n_ty,
            source.resolved_type.is_unsigned(),
            n->target.is_unsigned(),
            self.generate_DI_location(n->base.location)
        ) => sir*);

        self.push_mir_value_variable(temp_var.content, n->target);
    }

    func visit_mir_nil(self, n: mir_nil*) {
        var v = mir_value_t::nil_value(n->resolved_type);
        defer v.delete();
        self.value_stack.push(v);
    }

    func visit_mir_number(self, n: mir_number*) {
        var number_literal = n->value.clone();
        defer number_literal.delete();

        // add '.0' if is float type
        if (!n->resolved_type.is_integer() &&
            !number_literal.contains('.')) {
            number_literal.append(".0");
        }

        var value = mir_value_t::literal(number_literal, n->resolved_type);
        defer value.delete();
        self.value_stack.push(value);
    }

    func visit_mir_string(self, n: mir_string*) {
        var string_var = self.ssa_gen.create_variable();
        defer string_var.delete();

        // insert string with new index if not exists
        if (!self.sctx->const_strings.has(n->value)) {
            self.sctx->const_strings.insert(
                n->value,
                self.sctx->const_strings.size
            );
        }

        self.block->add_stmt(sir_str::new(
            self.sctx->const_strings.get(n->value),
            n->value.size + 1,
            string_var,
            self.generate_DI_location(n->base.location)
        ) => sir*);

        self.push_mir_value_variable(string_var.content, n->resolved_type);
    }

    func visit_mir_char(self, n: mir_char*) {
        var char_literal = str::from_i64(n->value.get(0) => i64);
        defer char_literal.delete();

        var value = mir_value_t::literal(char_literal, n->resolved_type);
        defer value.delete();
        self.value_stack.push(value);
    }

    func visit_mir_bool(self, n: mir_bool*) {
        var flag = str::instance();
        if (n->value) {
            flag.append("1");
        } else {
            flag.append("0");
        }
        defer flag.delete();

        var value = mir_value_t::literal(flag, n->resolved_type);
        defer value.delete();
        self.value_stack.push(value);
    }

    func visit_mir_array(self, n: mir_array*) {
        var index = self.array_ssa_gen.create_index();

        var temp_0 = str::from("arr.");
        defer temp_0.delete();
        var temp_1 = str::from("arr.");
        defer temp_1.delete();
        temp_0.append_i64(index).append(".ptr");
        temp_1.append_i64(index).append(".cast_ptr");

        var ref_copy = n->resolved_type.ref_copy();
        defer ref_copy.delete();

        var array_elem_type = self.type_mapping(ref_copy);
        defer array_elem_type.delete();

        var ati = array_type_t::instance(array_elem_type, n->size);
        defer ati.delete();

        var array_new = sir_alloca::new_array(temp_0, ati);
        self.alloca_block->add_stmt(array_new => sir*);

        var v_temp_0 = value_t::variable(temp_0);
        defer v_temp_0.delete();
        var v_temp_1 = value_t::variable(temp_1);
        defer v_temp_1.delete();

        var cv = sir_array_cast::new(
            v_temp_0,
            v_temp_1,
            array_elem_type,
            n->size,
            self.generate_DI_location(n->base.location)
        );
        self.block->add_stmt(cv => sir*);

        if (!n->value.empty()) {
            var i64_type = str::from("i64");
            defer i64_type.delete();

            foreach (var i; n->value) {
                var vn = i.get();

                var elem_value = self.ssa_gen.create_variable();
                defer elem_value.delete();

                var index_str = str::from_u64(i.index());
                defer index_str.delete();
                var index_value = value_t::literal(index_str);
                defer index_value.delete();

                self.block->add_stmt(sir_get_index::new(
                    v_temp_1,
                    elem_value,
                    index_value,
                    array_elem_type,
                    i64_type,
                    self.generate_DI_location(n->base.location)
                ) => sir*);

                self.visit(vn);
                var res = self.value_stack.back().clone();
                defer res.delete();

                var res_value = res.to_value_t();
                defer res_value.delete();

                self.value_stack.pop_back();
                self.block->add_stmt(sir_store::new(
                    array_elem_type,
                    res_value,
                    elem_value,
                    self.generate_DI_location(n->base.location)
                ) => sir*);
            }
        }

        self.push_mir_value_variable(temp_1, n->resolved_type);
    }

    func visit_mir_struct_init(self, n: mir_struct_init*) {
        var temp_var = self.ssa_gen.create_variable();
        defer temp_var.delete();

        var n_ty = self.type_mapping(n->resolved_type);
        defer n_ty.delete();

        self.move_reg_block->add_stmt(sir_alloca::new(temp_var.content, n_ty) => sir*);
        self.block->add_stmt(sir_zeroinitializer::new(
            temp_var,
            n_ty,
            self.generate_DI_location(n->base.location)
        ) => sir*);

        var name_for_search = n->resolved_type.generic_name(self.pkg);
        defer name_for_search.delete();

        var dm = self.ctx->get_domain(n->resolved_type.loc_file);

        if (dm.structs.has(name_for_search)) {
            var st = dm.structs.get(name_for_search);

            foreach (var i; n->fields) {
                var target_value = self.ssa_gen.create_variable();
                defer target_value.delete();

                var index = st.field_index(i.get().name);
                self.block->add_stmt(sir_get_field::new(
                    target_value,
                    temp_var,
                    n_ty,
                    index,
                    self.generate_DI_location(i.get().content->location)
                ) => sir*);

                // this mir_block should only contain one mir inside
                if (i.get().content->kind == mir_kind::mir_call) {
                    var val = i.get().content => mir_call*;
                    self.call_expr_gen(val, val->resolved_type.is_reference);
                } else {
                    self.visit(i.get().content => mir*);
                }

                var res = self.value_stack.back().clone();
                defer res.delete();
                self.value_stack.pop_back();

                var res_ty = self.type_mapping(res.resolved_type);
                defer res_ty.delete();

                var res_value = res.to_value_t();
                defer res_value.delete();

                self.block->add_stmt(sir_store::new(
                    res_ty,
                    res_value,
                    target_value,
                    self.generate_DI_location(i.get().content->location)
                ) => sir*);
            }

            var n_ptr = n->resolved_type.pointer_copy();
            defer n_ptr.delete();

            self.push_mir_value_variable(temp_var.content, n_ptr);
        } else if (dm.tagged_unions.has(name_for_search)) {
            var un = dm.tagged_unions.get(name_for_search);

            foreach (var i; n->fields) {
                var tag_value = self.ssa_gen.create_variable();
                defer tag_value.delete();

                self.block->add_stmt(sir_get_field::new(
                    tag_value,
                    temp_var,
                    n_ty,
                    0,
                    self.generate_DI_location(i.get().content->location)
                ) => sir*);

                var i64_t = str::from("i64");
                var tag_value_str = str::from_i64(un.member_int_map.get(i.get().name));
                var tag_value_v = value_t::literal(tag_value_str);
                defer i64_t.delete();
                defer tag_value_str.delete();
                defer tag_value_v.delete();
                self.block->add_stmt(sir_store::new(
                    i64_t,
                    tag_value_v,
                    tag_value,
                    self.generate_DI_location(i.get().content->location)
                ) => sir*);

                var source_value = self.ssa_gen.create_variable();
                var target_value = self.ssa_gen.create_variable();
                defer source_value.delete();
                defer target_value.delete();

                self.block->add_stmt(sir_get_field::new(
                    source_value,
                    temp_var,
                    n_ty,
                    1,
                    self.generate_DI_location(i.get().content->location)
                ) => sir*);

                // get max align type, it's the base type of union
                var un_full_path_name = n->resolved_type.full_path_name(self.pkg);
                defer un_full_path_name.delete();
                var base_type = self.sc.tagged_union_mapper.get(
                    un_full_path_name
                )->max_align_type.pointer_copy();
                defer base_type.delete();
                var base_type_name = self.type_mapping(base_type);
                defer base_type_name.delete();
                var target_type = un.members.get(i.get().name).pointer_copy();
                defer target_type.delete();
                var target_type_name = self.type_mapping(target_type);
                defer target_type_name.delete();

                self.block->add_stmt(sir_type_convert::new(
                    source_value,
                    target_value,
                    base_type_name,
                    target_type_name,
                    true,
                    true,
                    self.generate_DI_location(i.get().content->location)
                ) => sir*);

                self.visit(i.get().content => mir*);

                var res = self.value_stack.back().clone();
                defer res.delete();
                self.value_stack.pop_back();

                var res_ty = self.type_mapping(res.resolved_type);
                defer res_ty.delete();

                var res_value = res.to_value_t();
                defer res_value.delete();

                self.block->add_stmt(sir_store::new(
                    res_ty,
                    res_value,
                    target_value,
                    self.generate_DI_location(i.get().content->location)
                ) => sir*);
            }

            var n_ptr = n->resolved_type.pointer_copy();
            defer n_ptr.delete();

            self.push_mir_value_variable(temp_var.content, n_ptr);
        }
    }

    func de_reference(self) {
        if (self.value_stack.empty()) {
            return;
        }

        // only reference type need to de-reference
        if (!self.value_stack.back().resolved_type.is_reference) {
            return;
        }

        var source = self.value_stack.back().clone();
        defer source.delete();
        self.value_stack.pop_back();

        // need a de-referenced type, directly change is_reference to false
        var source_ref = source.resolved_type.clone();
        source_ref.is_reference = false;
        defer source_ref.delete();

        var source_ref_ty = self.type_mapping(source_ref);
        defer source_ref_ty.delete();
        var source_value = source.to_value_t();
        defer source_value.delete();

        var temp_var = self.ssa_gen.create_variable();
        defer temp_var.delete();

        self.block->add_stmt(sir_load::new(
            source_ref_ty,
            source_value,
            temp_var
        ) => sir*);

        self.push_mir_value_variable(temp_var.content, source_ref);
    }

    func call_expr_gen(self, n: mir_call*, need_address: bool) {
        foreach (var i; n->content) {
            self.visit(i.get());
        }
        self.de_reference();

        var source = self.value_stack.back().clone();
        defer source.delete();

        // for enum member
        if (!source.resolved_type.is_pointer()) {
            return;
        }
        if (source.resolved_type.is_void()) {
            self.value_stack.pop_back();
            return;
        }

        // left-value for assignment will not need to load value from address
        // reference type also does not need to load value
        // both of them are pointer type actually
        if (need_address) {
            return;
        }

        self.value_stack.pop_back();

        var temp_var = self.ssa_gen.create_variable();
        var source_ref = source.resolved_type.ref_copy();
        var source_ref_ty = self.type_mapping(source_ref);
        var source_value = source.to_value_t();
        defer {
            temp_var.delete();
            source_ref.delete();
            source_ref_ty.delete();
            source_value.delete();
        }

        if (source.resolved_type.is_array) {
            var source_ref_ref = source_ref.ref_copy();
            defer source_ref_ref.delete();

            var source_ref_ref_ty = self.type_mapping(source_ref_ref);
            defer source_ref_ref_ty.delete();

            // for example:
            //   var a: [i8; 8] = [];
            // `a` in fact is `i8*`
            // so we need to:
            //   %0 = bitcast [8 x i8]* %arr.a.ptr to i8*
            self.block->add_stmt(sir_array_cast::new(
                source_value,
                temp_var,
                source_ref_ref_ty,
                source.resolved_type.array_length,
                self.generate_DI_location(n->base.location)
            ) => sir*);
        } else {
            // load value from pointer
            self.block->add_stmt(sir_load::new(
                source_ref_ty,
                source_value,
                temp_var
            ) => sir*);
        }

        self.push_mir_value_variable(temp_var.content, source_ref);
    }

    func visit_mir_call(self, n: mir_call*) {
        self.call_expr_gen(n, false);
    }

    func visit_mir_call_id(self, n: mir_call_id*) {
        if (!n->resolved_type.is_global_sym) {
            var name = self.locals.get_local(n->name);
            defer name.delete();

            var ty = n->resolved_type.pointer_copy();
            // should make is_array to false
            // then [4096 x i8]* can be treated as i8**
            // which is exacty the type of local variable
            ty.is_array = false;
            defer ty.delete();

            self.push_mir_value_variable(name, ty);
            return;
        }

        var loc_file: str& = n->resolved_type.loc_file;
        if (loc_file.empty()) {
            if (!self.ctx->global->primitives.has(n->name)) {
                panic("empty location for global symbol");
            } else {
                var v = mir_value_t::primitive(n->name, n->resolved_type);
                defer v.delete();

                self.value_stack.push(v);
            }
            return;
        }

        var dm = self.ctx->get_domain(loc_file);
        var name_for_search = n->resolved_type.generic_name(self.pkg);
        defer name_for_search.delete();

        var full_path_name = n->resolved_type.full_path_name(self.pkg);
        defer full_path_name.delete();

        if (dm.functions.has(name_for_search)) {
            var v = mir_value_t::func_symbol(full_path_name, n->resolved_type);
            defer v.delete();

            // extern function remain raw name
            if (dm.functions.get(name_for_search).is_extern) {
                v.content.clear();
                v.content.append_str(name_for_search);
            }
            self.value_stack.push(v);
        } else if (dm.structs.has(name_for_search)) {
            var v = mir_value_t::struct_symbol(full_path_name, n->resolved_type);
            defer v.delete();

            self.value_stack.push(v);
        } else if (dm.tagged_unions.has(name_for_search)) {
            var v = mir_value_t::tagged_union_symbol(full_path_name, n->resolved_type);
            defer v.delete();

            self.value_stack.push(v);
        } else if (dm.enums.has(name_for_search)) {
            var v = mir_value_t::enum_symbol(name_for_search, n->resolved_type);
            defer v.delete();

            self.value_stack.push(v);
        } else {
            var info = str::from("cannot get global symbol ");
            info.append_str(name_for_search)
                .append(" from ")
                .append_str(loc_file);
            defer info.delete();

            panic(info.c_str);
        }
    }

    func visit_mir_call_index(self, n: mir_call_index*) {
        self.de_reference();

        var prev = self.value_stack.back().clone();
        defer prev.delete();
        self.value_stack.pop_back();

        self.visit(n->index => mir*);

        var index = self.value_stack.back().clone();
        defer index.delete();
        self.value_stack.pop_back();

        var prev_ref = prev.resolved_type.ref_copy();
        defer prev_ref.delete();

        var prev_ref_ty = self.type_mapping(prev_ref);
        defer prev_ref_ty.delete();

        var prev_value = prev.to_value_t();
        defer prev_value.delete();

        var temp_var = self.ssa_gen.create_variable();
        defer temp_var.delete();

        if (prev.resolved_type.is_array) {
            var prev_ref_ref = prev_ref.ref_copy();
            defer prev_ref_ref.delete();

            var prev_ref_ref_ty = self.type_mapping(prev_ref_ref);
            defer prev_ref_ref_ty.delete();

            self.block->add_stmt(sir_array_cast::new(
                prev_value,
                temp_var,
                prev_ref_ref_ty,
                prev.resolved_type.array_length,
                self.generate_DI_location(n->base.location)
            ) => sir*);
        } else {
            self.block->add_stmt(sir_load::new(
                prev_ref_ty,
                prev_value,
                temp_var
            ) => sir*);
        }

        var target_value = self.ssa_gen.create_variable();
        defer target_value.delete();

        var index_value = index.to_value_t();
        defer index_value.delete();

        var prev_ref_ref = prev_ref.ref_copy();
        defer prev_ref_ref.delete();

        var prev_ref_ref_ty = self.type_mapping(prev_ref_ref);
        defer prev_ref_ref_ty.delete();

        var index_ty = self.type_mapping(index.resolved_type);
        defer index_ty.delete();

        self.block->add_stmt(sir_get_index::new(
            temp_var,
            target_value,
            index_value,
            prev_ref_ref_ty,
            index_ty,
            self.generate_DI_location(n->base.location)
        ) => sir*);

        var n_ptr = n->resolved_type.pointer_copy();
        defer n_ptr.delete();

        self.push_mir_value_variable(target_value.content, n_ptr);
    }

    func visit_mir_call_func(self, n: mir_call_func*) {
        var prev = self.value_stack.back().clone();
        defer prev.delete();
        self.value_stack.pop_back();

        // if is primitive size method call, replace with number literal
        if (self.primitive_methods.has(prev.content)) {
            var size = self.primitive_methods.get(prev.content);
            var v = mir_value_t::literal(size, n->resolved_type);
            defer v.delete();

            self.value_stack.push(v);
            return;
        }

        var args = vec<mir_value_t>::instance();
        defer args.delete();

        // load "self" argument
        if (prev.value_kind == mir_value_kind::method) {
            self.de_reference();
            args.push(self.value_stack.back());
            self.value_stack.pop_back();
        }
        // load arguments
        foreach (var i; n->args) {
            if (i.get()->kind == mir_kind::mir_call && n->args_is_ref.get(i.index())) {
                self.call_expr_gen(i.get() => mir_call*, true);
            } else {
                self.visit(i.get());
            }
            args.push(self.value_stack.back());
            self.value_stack.pop_back();
        }

        var target = str::instance();
        defer target.delete();

        var sir_function_call: sir_call* = nil;
        if (!n->resolved_type.is_void()) {
            var temp = self.ssa_gen.create();
            defer temp.delete();

            target.append_str(temp);

            var n_ty = self.type_mapping(n->resolved_type);
            var target_value = value_t::variable(target);
            var mangled_name = mangle_function_name(prev.content);
            defer {
                n_ty.delete();
                target_value.delete();
                mangled_name.delete();
            }

            sir_function_call = sir_call::new(
                mangled_name,
                n_ty,
                target_value,
                self.generate_DI_location(n->base.location)
            );
        } else {
            var n_ty = self.type_mapping(n->resolved_type);
            var target_value = value_t::null(nil);
            var mangled_name = mangle_function_name(prev.content);
            defer {
                n_ty.delete();
                target_value.delete();
                mangled_name.delete();
            }

            sir_function_call = sir_call::new(
                mangled_name,
                n_ty,
                target_value,
                self.generate_DI_location(n->base.location)
            );
        }

        // load args
        foreach (var i; args) {
            var arg = i.get();
            var arg_val = arg.to_value_t();
            defer arg_val.delete();

            var arg_ty = self.type_mapping(arg.resolved_type);
            defer arg_ty.delete();

            sir_function_call->add_arg(arg_val, arg_ty);
        }
        self.block->add_stmt(sir_function_call => sir*);

        if (n->resolved_type.is_void()) {
            self.push_mir_value_variable(target, n->resolved_type);
        } else {
            var temp_var = self.ssa_gen.create_variable();
            defer temp_var.delete();

            var n_ty = self.type_mapping(n->resolved_type);
            var target_value = value_t::variable(target);
            defer {
                n_ty.delete();
                target_value.delete();
            }

            self.move_reg_block->add_stmt(sir_alloca::new(temp_var.content, n_ty) => sir*);
            self.block->add_stmt(sir_store::new(
                n_ty,
                target_value,
                temp_var,
                self.generate_DI_location(n->base.location)
            ) => sir*);

            var n_ref = n->resolved_type.pointer_copy();
            defer n_ref.delete();

            self.push_mir_value_variable(temp_var.content, n_ref);
        }
    }

    func visit_mir_get_field(self, n: mir_get_field*) {
        self.de_reference();
        var prev = self.value_stack.back().clone();
        defer prev.delete();

        var prev_name_for_search = prev.resolved_type.generic_name(self.pkg);
        defer prev_name_for_search.delete();

        self.value_stack.pop_back();

        // primitive type does not have loc_file
        if (prev.resolved_type.loc_file.empty()) {
            var pm = self.ctx->global->primitives.get(prev_name_for_search);
            if (pm.method.has(n->name)) {
                // push self into stack
                self.value_stack.push(prev);
                var method_name = prev.resolved_type.full_path_name(self.pkg);
                method_name.append_char('.').append_str(n->name);
                defer method_name.delete();

                self.push_mir_value_method(method_name, n->resolved_type);
                return;
            }
            unreachable();
            return;
        }

        var dm = self.ctx->get_domain(prev.resolved_type.loc_file);

        if (dm.structs.has(prev_name_for_search)) {
            var st = dm.structs.get(prev_name_for_search);

            // get method
            if (st.method.has(n->name)) {
                // push self into stack
                self.value_stack.push(prev);
                var method_name = prev.resolved_type.full_path_name(self.pkg);
                method_name.append_char('.').append_str(n->name);
                defer method_name.delete();

                self.push_mir_value_method(method_name, n->resolved_type);
                return;
            }

            var target_value = self.ssa_gen.create_variable();
            defer target_value.delete();

            var index = st.field_index(n->name);

            var prev_value = prev.to_value_t();
            var prev_ref = prev.resolved_type.ref_copy();
            var prev_ref_ty = self.type_mapping(prev_ref);
            defer {
                prev_value.delete();
                prev_ref.delete();
                prev_ref_ty.delete();
            }

            self.block->add_stmt(sir_get_field::new(
                target_value,
                prev_value,
                prev_ref_ty,
                index,
                self.generate_DI_location(n->base.location)
            ) => sir*);

            var n_ty = n->resolved_type.pointer_copy();
            defer n_ty.delete();

            self.push_mir_value_variable(target_value.content, n_ty);
        } else if (dm.tagged_unions.has(prev_name_for_search)) {
            var un = dm.tagged_unions.get(prev_name_for_search);

            // get method
            if (un.method.has(n->name)) {
                // push self into stack
                self.value_stack.push(prev);
                var method_name = prev.resolved_type.full_path_name(self.pkg);
                method_name.append_char('.').append_str(n->name);
                defer method_name.delete();

                self.push_mir_value_method(method_name, n->resolved_type);
                return;
            }

            var source_value = self.ssa_gen.create_variable();
            var target_value = self.ssa_gen.create_variable();
            defer {
                source_value.delete();
                target_value.delete();
            }

            var prev_value = prev.to_value_t();
            var prev_ref = prev.resolved_type.ref_copy();
            var prev_ref_ty = self.type_mapping(prev_ref);
            defer {
                prev_value.delete();
                prev_ref.delete();
                prev_ref_ty.delete();
            }

            self.block->add_stmt(sir_get_field::new(
                source_value,
                prev_value,
                prev_ref_ty,
                1,
                self.generate_DI_location(n->base.location)
            ) => sir*);

            // get max align type, it's the base type of union
            var un_full_path_name = prev.resolved_type.full_path_name(self.pkg);
            defer un_full_path_name.delete();
            var base_type = self.sc.tagged_union_mapper.get(
                un_full_path_name
            )->max_align_type.pointer_copy();
            defer base_type.delete();
            var base_type_name = self.type_mapping(base_type);
            defer base_type_name.delete();

            var target_type = un.members.get(n->name).pointer_copy();
            defer target_type.delete();
            var target_type_name = self.type_mapping(target_type);
            defer target_type_name.delete();

            self.block->add_stmt(sir_type_convert::new(
                source_value,
                target_value,
                base_type_name,
                target_type_name,
                true,
                true,
                self.generate_DI_location(n->base.location)
            ) => sir*);

            var n_ty = n->resolved_type.pointer_copy();
            defer n_ty.delete();

            self.push_mir_value_variable(target_value.content, n_ty);
        }
    }

    func visit_mir_ptr_get_field(self, n: mir_ptr_get_field*) {
        self.de_reference();

        var prev = self.value_stack.back().clone();
        defer prev.delete();

        var prev_name_for_search = prev.resolved_type.generic_name(self.pkg);
        defer prev_name_for_search.delete();

        self.value_stack.pop_back();

        // primitive type does not have loc_file
        if (prev.resolved_type.loc_file.empty()) {
            var pm = self.ctx->global->primitives.get(prev_name_for_search);
            if (pm.method.has(n->name)) {
                var temp_var = self.ssa_gen.create();
                var temp_var_value = value_t::variable(temp_var);
                var prev_ref = prev.resolved_type.ref_copy();
                var prev_ref_ty = self.type_mapping(prev_ref);
                var prev_value = prev.to_value_t();
                defer {
                    temp_var.delete();
                    temp_var_value.delete();
                    prev_ref.delete();
                    prev_ref_ty.delete();
                    prev_value.delete();
                }
                self.block->add_stmt(sir_load::new(
                    prev_ref_ty,
                    prev_value,
                    temp_var_value
                ) => sir*);

                // push self into stack
                self.push_mir_value_variable(temp_var, prev_ref);

                var method_name = prev.resolved_type.full_path_name(self.pkg);
                method_name.append_char('.').append_str(n->name);
                defer method_name.delete();

                self.push_mir_value_method(method_name, n->resolved_type);
                return;
            }
            unreachable();
            return;
        }

        var dm = self.ctx->get_domain(prev.resolved_type.loc_file);

        if (dm.structs.has(prev_name_for_search)) {
            var st = dm.structs.get(prev_name_for_search);

            // get method
            if (st.method.has(n->name)) {
                var temp_var = self.ssa_gen.create();
                var temp_var_value = value_t::variable(temp_var);
                var prev_ref = prev.resolved_type.ref_copy();
                var prev_ref_ty = self.type_mapping(prev_ref);
                var prev_value = prev.to_value_t();
                defer {
                    temp_var.delete();
                    temp_var_value.delete();
                    prev_ref.delete();
                    prev_ref_ty.delete();
                    prev_value.delete();
                }
                self.block->add_stmt(sir_load::new(
                    prev_ref_ty,
                    prev_value,
                    temp_var_value
                ) => sir*);

                // push self into stack
                self.push_mir_value_variable(temp_var, prev_ref);

                var method_name = prev.resolved_type.full_path_name(self.pkg);
                method_name.append_char('.').append_str(n->name);
                defer method_name.delete();

                self.push_mir_value_method(method_name, n->resolved_type);
                return;
            }

            var index = st.field_index(n->name);
            var temp_0_value = self.ssa_gen.create_variable();
            var temp_1_value = self.ssa_gen.create_variable();
            defer {
                temp_0_value.delete();
                temp_1_value.delete();
            }

            var prev_value = prev.to_value_t();
            var prev_ref = prev.resolved_type.ref_copy();
            var prev_ref_ty = self.type_mapping(prev_ref);
            var prev_ref_ref = prev_ref.ref_copy();
            var prev_ref_ref_ty = self.type_mapping(prev_ref_ref);
            defer {
                prev_value.delete();
                prev_ref.delete();
                prev_ref_ty.delete();
                prev_ref_ref.delete();
                prev_ref_ref_ty.delete();
            }

            self.block->add_stmt(sir_load::new(
                prev_ref_ty,
                prev_value,
                temp_0_value
            ) => sir*);

            self.block->add_stmt(sir_get_field::new(
                temp_1_value,
                temp_0_value,
                prev_ref_ref_ty,
                index,
                self.generate_DI_location(n->base.location)
            ) => sir*);

            var n_ty = n->resolved_type.pointer_copy();
            defer n_ty.delete();

            self.push_mir_value_variable(temp_1_value.content, n_ty);
        } else if (dm.tagged_unions.has(prev_name_for_search)) {
            var un = dm.tagged_unions.get(prev_name_for_search);

            // get method
            if (un.method.has(n->name)) {
                var temp_var_value = self.ssa_gen.create_variable();
                var prev_ref = prev.resolved_type.ref_copy();
                var prev_ref_ty = self.type_mapping(prev_ref);
                var prev_value = prev.to_value_t();
                defer {
                    temp_var_value.delete();
                    prev_ref.delete();
                    prev_ref_ty.delete();
                    prev_value.delete();
                }
                self.block->add_stmt(sir_load::new(
                    prev_ref_ty,
                    prev_value,
                    temp_var_value
                ) => sir*);

                // push self into stack
                self.push_mir_value_variable(temp_var_value.content, prev_ref);

                var method_name = prev.resolved_type.full_path_name(self.pkg);
                method_name.append_char('.').append_str(n->name);
                defer method_name.delete();

                self.push_mir_value_method(method_name, n->resolved_type);
                return;
            }

            var temp_0_value = self.ssa_gen.create_variable();
            var temp_1_value = self.ssa_gen.create_variable();
            var target_value = self.ssa_gen.create_variable();
            defer {
                temp_0_value.delete();
                temp_1_value.delete();
                target_value.delete();
            }

            var prev_value = prev.to_value_t();
            var prev_ref = prev.resolved_type.ref_copy();
            var prev_ref_ty = self.type_mapping(prev_ref);
            var prev_ref_ref = prev_ref.ref_copy();
            var prev_ref_ref_ty = self.type_mapping(prev_ref_ref);
            defer {
                prev_value.delete();
                prev_ref.delete();
                prev_ref_ty.delete();
                prev_ref_ref.delete();
                prev_ref_ref_ty.delete();
            }

            self.block->add_stmt(sir_load::new(
                prev_ref_ty,
                prev_value,
                temp_0_value
            ) => sir*);

            self.block->add_stmt(sir_get_field::new(
                temp_1_value,
                temp_0_value,
                prev_ref_ref_ty,
                1,
                self.generate_DI_location(n->base.location)
            ) => sir*);

            // get max align type, it's the base type of union
            var un_full_path_name = prev.resolved_type.full_path_name(self.pkg);
            defer un_full_path_name.delete();
            var base_type = self.sc.tagged_union_mapper.get(
                un_full_path_name
            )->max_align_type.pointer_copy();
            defer base_type.delete();
            var base_type_name = self.type_mapping(base_type);
            defer base_type_name.delete();

            var target_type = un.members.get(n->name).pointer_copy();
            defer target_type.delete();
            var target_type_name = self.type_mapping(target_type);
            defer target_type_name.delete();

            self.block->add_stmt(sir_type_convert::new(
                temp_1_value,
                target_value,
                base_type_name,
                target_type_name,
                true,
                true,
                self.generate_DI_location(n->base.location)
            ) => sir*);

            var n_ty = n->resolved_type.pointer_copy();
            defer n_ty.delete();

            self.push_mir_value_variable(target_value.content, n_ty);
        }
    }

    func visit_mir_get_path(self, n: mir_get_path*) {
        var prev = self.value_stack.back().clone();
        defer prev.delete();
        self.value_stack.pop_back();

        match (prev.value_kind) {
            mir_value_kind::primitive => {
                var name = prev.resolved_type.full_path_name(self.pkg);
                name.append(".").append_str(n->name);
                defer name.delete();

                var v = mir_value_t::func_symbol(name, n->resolved_type);
                defer v.delete();

                self.value_stack.push(v);
            }
            mir_value_kind::struct_symbol => {
                var name = prev.resolved_type.full_path_name(self.pkg);
                name.append(".").append_str(n->name);
                defer name.delete();

                var v = mir_value_t::func_symbol(name, n->resolved_type);
                defer v.delete();

                self.value_stack.push(v);
            }
            mir_value_kind::tagged_union_symbol => {
                var name = prev.resolved_type.full_path_name(self.pkg);
                name.append(".").append_str(n->name);
                defer name.delete();

                var v = mir_value_t::func_symbol(name, n->resolved_type);
                defer v.delete();

                self.value_stack.push(v);
            }
            mir_value_kind::enum_symbol => {
                var dm = self.ctx->get_domain(prev.resolved_type.loc_file);
                var em = dm.enums.get(prev.resolved_type.name);
                var index = em.members.get(n->name);

                var index_str = str::from_i64(index);
                defer index_str.delete();

                var v = mir_value_t::literal(index_str, n->resolved_type);
                defer v.delete();

                self.value_stack.push(v);
            }
            _ => { unreachable(); }
        }
    }

    func visit_mir_define(self, n: mir_define*) {
        var name = n->name.clone();
        name.append(".").append_u64(self.var_ssa_suffix);
        self.var_ssa_suffix += 1;
        defer name.delete();

        // real name of the local variable
        self.locals.insert(n->name, name);

        var n_ty = n->resolved_type.clone();
        n_ty.is_array = false;
        defer n_ty.delete();

        var type_name = self.type_mapping(n_ty);
        defer type_name.delete();

        self.alloca_block->add_stmt(sir_alloca::new(name, type_name) => sir*);

        if (n->init_value->kind == mir_kind::mir_call) {
            self.call_expr_gen(
                n->init_value => mir_call*,
                n->resolved_type.is_reference
            );
        } else {
            self.visit(n->init_value => mir*);
        }

        var source = self.value_stack.back().clone();
        defer source.delete();
        self.value_stack.pop_back();

        var source_value = source.to_value_t();
        defer source_value.delete();

        var name_value = value_t::variable(name);
        defer name_value.delete();

        self.block->add_stmt(sir_store::new(
            type_name,
            source_value,
            name_value,
            self.generate_DI_location(n->base.location)
        ) => sir*);
    }

    func visit_mir_assign(self, n: mir_assign*) {
        self.call_expr_gen(n->left => mir_call*, true);
        var left = self.value_stack.back().clone();
        var left_value = left.to_value_t();
        self.value_stack.pop_back();
        defer {
            left.delete();
            left_value.delete();
        }

        self.visit(n->right => mir*);
        var right = self.value_stack.back().clone();
        var right_value = right.to_value_t();
        var right_ty = self.type_mapping(right.resolved_type);
        self.value_stack.pop_back();
        defer {
            right.delete();
            right_value.delete();
            right_ty.delete();
        }

        match (n->opr) {
            mir_assign_opr::addeq => {
                var temp_0_value = self.ssa_gen.create_variable();
                var temp_1_value = self.ssa_gen.create_variable();
                defer {
                    temp_0_value.delete();
                    temp_1_value.delete();
                }

                self.block->add_stmt(sir_load::new(
                    right_ty,
                    left_value,
                    temp_0_value
                ) => sir*);
                if (right.resolved_type.is_integer()) {
                    self.block->add_stmt(sir_add::new(
                        temp_0_value,
                        right_value,
                        temp_1_value,
                        right_ty,
                        self.generate_DI_location(n->base.location),
                        "+="
                    ) => sir*);
                } else {
                    self.block->add_stmt(sir_fadd::new(
                        temp_0_value,
                        right_value,
                        temp_1_value,
                        right_ty,
                        self.generate_DI_location(n->base.location),
                        "+="
                    ) => sir*);
                }
                self.block->add_stmt(sir_store::new(
                    right_ty,
                    temp_1_value,
                    left_value,
                    self.generate_DI_location(n->base.location)
                ) => sir*);
            }
            mir_assign_opr::subeq => {
                var temp_0_value = self.ssa_gen.create_variable();
                var temp_1_value = self.ssa_gen.create_variable();
                defer {
                    temp_0_value.delete();
                    temp_1_value.delete();
                }

                self.block->add_stmt(sir_load::new(
                    right_ty,
                    left_value,
                    temp_0_value
                ) => sir*);
                self.block->add_stmt(sir_sub::new(
                    temp_0_value,
                    right_value,
                    temp_1_value,
                    right.resolved_type.is_integer(),
                    right_ty
                ) => sir*);
                self.block->add_stmt(sir_store::new(
                    right_ty,
                    temp_1_value,
                    left_value,
                    self.generate_DI_location(n->base.location)
                ) => sir*);
            }
            mir_assign_opr::muleq => {
                var temp_0_value = self.ssa_gen.create_variable();
                var temp_1_value = self.ssa_gen.create_variable();
                defer {
                    temp_0_value.delete();
                    temp_1_value.delete();
                }

                self.block->add_stmt(sir_load::new(
                    right_ty,
                    left_value,
                    temp_0_value
                ) => sir*);
                self.block->add_stmt(sir_mul::new(
                    temp_0_value,
                    right_value,
                    temp_1_value,
                    right.resolved_type.is_integer(),
                    right_ty
                ) => sir*);
                self.block->add_stmt(sir_store::new(
                    right_ty,
                    temp_1_value,
                    left_value,
                    self.generate_DI_location(n->base.location)
                ) => sir*);
            }
            mir_assign_opr::diveq => {
                var temp_0_value = self.ssa_gen.create_variable();
                var temp_1_value = self.ssa_gen.create_variable();
                defer {
                    temp_0_value.delete();
                    temp_1_value.delete();
                }

                self.block->add_stmt(sir_load::new(
                    right_ty,
                    left_value,
                    temp_0_value
                ) => sir*);
                self.block->add_stmt(sir_div::new(
                    temp_0_value,
                    right_value,
                    temp_1_value,
                    right.resolved_type.is_integer(),
                    !right.resolved_type.is_unsigned(),
                    right_ty
                ) => sir*);
                self.block->add_stmt(sir_store::new(
                    right_ty,
                    temp_1_value,
                    left_value,
                    self.generate_DI_location(n->base.location)
                ) => sir*);
            }
            mir_assign_opr::remeq => {
                var temp_0_value = self.ssa_gen.create_variable();
                var temp_1_value = self.ssa_gen.create_variable();
                defer {
                    temp_0_value.delete();
                    temp_1_value.delete();
                }

                self.block->add_stmt(sir_load::new(
                    right_ty,
                    left_value,
                    temp_0_value
                ) => sir*);
                self.block->add_stmt(sir_rem::new(
                    temp_0_value,
                    right_value,
                    temp_1_value,
                    right.resolved_type.is_integer(),
                    !right.resolved_type.is_unsigned(),
                    right_ty
                ) => sir*);
                self.block->add_stmt(sir_store::new(
                    right_ty,
                    temp_1_value,
                    left_value,
                    self.generate_DI_location(n->base.location)
                ) => sir*);
            }
            mir_assign_opr::eq => {
                self.block->add_stmt(sir_store::new(
                    right_ty,
                    right_value,
                    left_value,
                    self.generate_DI_location(n->base.location)
                ) => sir*);
            }
            mir_assign_opr::andeq => {
                var temp_0_value = self.ssa_gen.create_variable();
                var temp_1_value = self.ssa_gen.create_variable();
                defer {
                    temp_0_value.delete();
                    temp_1_value.delete();
                }

                self.block->add_stmt(sir_load::new(
                    right_ty,
                    left_value,
                    temp_0_value
                ) => sir*);
                self.block->add_stmt(sir_band::new(
                    temp_0_value,
                    right_value,
                    temp_1_value,
                    right_ty
                ) => sir*);
                self.block->add_stmt(sir_store::new(
                    right_ty,
                    temp_1_value,
                    left_value,
                    self.generate_DI_location(n->base.location)
                ) => sir*);
            }
            mir_assign_opr::xoreq => {
                var temp_0_value = self.ssa_gen.create_variable();
                var temp_1_value = self.ssa_gen.create_variable();
                defer {
                    temp_0_value.delete();
                    temp_1_value.delete();
                }

                self.block->add_stmt(sir_load::new(
                    right_ty,
                    left_value,
                    temp_0_value
                ) => sir*);
                self.block->add_stmt(sir_bxor::new(
                    temp_0_value,
                    right_value,
                    temp_1_value,
                    right_ty
                ) => sir*);
                self.block->add_stmt(sir_store::new(
                    right_ty,
                    temp_1_value,
                    left_value,
                    self.generate_DI_location(n->base.location)
                ) => sir*);
            }
            mir_assign_opr::oreq => {
                var temp_0_value = self.ssa_gen.create_variable();
                var temp_1_value = self.ssa_gen.create_variable();
                defer {
                    temp_0_value.delete();
                    temp_1_value.delete();
                }

                self.block->add_stmt(sir_load::new(
                    right_ty,
                    left_value,
                    temp_0_value
                ) => sir*);
                self.block->add_stmt(sir_bor::new(
                    temp_0_value,
                    right_value,
                    temp_1_value,
                    right_ty
                ) => sir*);
                self.block->add_stmt(sir_store::new(
                    right_ty,
                    temp_1_value,
                    left_value,
                    self.generate_DI_location(n->base.location)
                ) => sir*);
            }
        }
    }

    func visit_mir_if(self, n: mir_if*) {
        var br_cond: sir_br_cond* = nil;

        if (n->condition != nil) {
            self.visit(n->condition => mir*);

            var cond = self.value_stack.back().clone();
            defer cond.delete();
            self.value_stack.pop_back();

            var cond_value = cond.to_value_t();
            defer cond_value.delete();

            var cond_true_label = self.label_gen.create_index();
            br_cond = sir_br_cond::new(
                cond_value,
                cond_true_label,
                0
            );
            self.block->add_stmt(br_cond => sir*);

            var cond_true_block = sir_basic_block::new(cond_true_label, "cond.true");
            self.func_block->add_basic_block(cond_true_block);
            self.block = cond_true_block;
        }

        self.visit(n->content => mir*);

        // for block ends with ret instruction, another basic block is needed
        // because ret instruction is the terminator instruction
        if (self.block->back_is_ret_stmt()) {
            var block_end_ret = sir_basic_block::new(self.label_gen.create_index(), "block.end.ret");
            self.func_block->add_basic_block(block_end_ret);
            self.block = block_end_ret;
        }

        var jump_out = sir_br::new(0);
        self.block->add_stmt(jump_out => sir*);
        self.branch_jump_out.back().push(jump_out);

        if (br_cond != nil) {
            var cond_false_label = self.label_gen.create_index();
            br_cond->label_false = cond_false_label;
            var cond_false_block = sir_basic_block::new(cond_false_label, "cond.false");
            self.func_block->add_basic_block(cond_false_block);
            self.block = cond_false_block;
        }
    }

    func visit_mir_branch(self, n: mir_branch*) {
        var new_table = vec<sir_br*>::instance();
        self.branch_jump_out.push(new_table);
        new_table.delete();

        var branch_end_label = self.label_gen.create_index();
        foreach (var i; n->branch) {
            self.visit(i.get() => mir*);
            if (i.get()->condition != nil && i.index() == n->branch.size - 1) {
                self.block->add_stmt(sir_br::new(branch_end_label) => sir*);
            }
        }

        // set jump out
        foreach (var i; self.branch_jump_out.back()) {
            i.get()->label = branch_end_label;
        }
        self.branch_jump_out.pop_back();

        var branch_end_block = sir_basic_block::new(branch_end_label, "branch.end");
        self.func_block->add_basic_block(branch_end_block);
        self.block = branch_end_block;
    }

    func visit_mir_switch_case(self, n: mir_switch_case*) {
        self.visit(n->content => mir*);
    }

    func visit_mir_switch(self, n: mir_switch*) {
        self.visit(n->condition => mir*);
        var value = self.value_stack.back().clone();
        self.value_stack.pop_back();
        defer value.delete();

        var value_val = value.to_value_t();
        defer value_val.delete();

        var name_for_search = value.resolved_type.generic_name(self.pkg);
        defer name_for_search.delete();

        var dm = self.ctx->get_domain(value.resolved_type.loc_file);
        var switch_inst: sir_switch* = nil;
        if (dm.tagged_unions.has(name_for_search)) {
            var tag_v = self.ssa_gen.create_variable();
            var tag_value_v = self.ssa_gen.create_variable();
            defer tag_v.delete();
            defer tag_value_v.delete();
            // if value type is not a pointer, means the value is tagged union value
            // not a tagged union reference, so there must be a sir_load before it
            // if value is pointer type, we could directly get the tag value
            if (!value.resolved_type.is_pointer() &&
                !self.block->stmts.empty() &&
                self.block->stmts.back()->kind == sir_kind::sir_load) {
                // TODO: this load inst should be deleted
                var load_inst = self.block->stmts.back() => sir_load*;
                var value_type_name = self.type_mapping(value.resolved_type);
                defer value_type_name.delete();
                self.block->add_stmt(sir_get_field::new(
                    tag_v,
                    load_inst->source,
                    value_type_name,
                    0,
                    self.generate_DI_location(n->condition->location)
                ) => sir*);
            } else {
                var value_type_ref = value.resolved_type.ref_copy();
                defer value_type_ref.delete();
                var value_type_ref_name = self.type_mapping(value_type_ref);
                defer value_type_ref_name.delete();

                self.block->add_stmt(sir_get_field::new(
                    tag_v,
                    value_val,
                    value_type_ref_name,
                    0,
                    self.generate_DI_location(n->condition->location)
                ) => sir*);
            }

            var i64_t = str::from("i64");
            defer i64_t.delete();
            self.block->add_stmt(sir_load::new(
                i64_t,
                tag_v,
                tag_value_v,
            ) => sir*);
            switch_inst = sir_switch::new(
                tag_value_v,
                self.generate_DI_location(n->base.location)
            );
        } else {
            switch_inst = sir_switch::new(
                value_val,
                self.generate_DI_location(n->base.location)
            );
        }

        self.block->add_stmt(switch_inst => sir*);

        var jmp_exits = vec<sir_br*>::instance();
        defer jmp_exits.delete();

        foreach (var i; n->cases) {
            var case_label = self.label_gen.create_index();
            var label_comment = str::from("switch.case ");
            label_comment.append_i64(i.get()->value);
            defer label_comment.delete();

            var case_block = sir_basic_block::new(
                case_label,
                label_comment.c_str
            );

            self.func_block->add_basic_block(case_block);
            self.block = case_block;

            switch_inst->add_case(i.get()->value, case_label);

            self.visit(i.get()->content => mir*);

            // if block ends with ret instruction, do not generate
            // switch jump exit instruction
            if (self.block->back_is_ret_stmt()) {
                continue;
            }

            var jmp_exit = sir_br::new(0);
            self.block->add_stmt(jmp_exit => sir*);
            jmp_exits.push(jmp_exit);
        }

        var default_label = self.label_gen.create_index();
        var default_block = sir_basic_block::new(default_label, "switch.default");
        self.func_block->add_basic_block(default_block);
        self.block = default_block;

        switch_inst->default_label = default_label;

        if (n->default_case != nil) {
            self.visit(n->default_case => mir*);

            // if block ends with ret instruction, do not generate
            // switch jump exit instruction
            if (!self.block->back_is_ret_stmt()) {
                var jmp_exit = sir_br::new(0);
                self.block->add_stmt(jmp_exit => sir*);
                jmp_exits.push(jmp_exit);
            }

            var exit_label = self.label_gen.create_index();
            var switch_end_block = sir_basic_block::new(exit_label, "switch.end");
            self.func_block->add_basic_block(switch_end_block);
            self.block = switch_end_block;

            foreach (var i; jmp_exits) {
                i.get()->label = exit_label;
            }
        } else {
            foreach (var i; jmp_exits) {
                i.get()->label = default_label;
            }
        }
    }

    func visit_mir_break(self) {
        var break_br = sir_br::new(0);
        self.break_inst.back().push(break_br);

        self.block->add_stmt(break_br => sir*);

        var break_block = sir_basic_block::new(
            self.label_gen.create_index(),
            "break.end"
        );
        self.func_block->add_basic_block(break_block);
        self.block = break_block;
    }

    func visit_mir_continue(self) {
        var continue_br = sir_br::new(0);
        self.continue_inst.back().push(continue_br);

        self.block->add_stmt(continue_br => sir*);

        var continue_block = sir_basic_block::new(
            self.label_gen.create_index(),
            "continue.end"
        );
        self.func_block->add_basic_block(continue_block);
        self.block = continue_block;
    }

    func visit_mir_loop(self, n: mir_loop*) {
        var new_break_continue_table = vec<sir_br*>::instance();
        self.continue_inst.push(new_break_continue_table);
        self.break_inst.push(new_break_continue_table);
        new_break_continue_table.delete();

        // mir loop will generate llvm ir in this form:
        //
        // %loop.entry:
        //   ... ; condition
        //   br i1 %cond %loop.cond.true, %loop.exit
        // %loop.cond.true:
        //   ... ; content
        // br %loop.continue
        // %loop.continue:   ; continue jumps here
        //   ... ; update
        // br %loop.entry
        // %loop.exit:       ; break jumps here
        //
        var entry_label = self.label_gen.create_index();
        self.block->add_stmt(sir_br::new(entry_label) => sir*);

        var loop_entry_block = sir_basic_block::new(entry_label, "loop.entry");
        self.func_block->add_basic_block(loop_entry_block);
        self.block = loop_entry_block;

        self.visit(n->condition => mir*);
        var cond = self.value_stack.back().clone();
        defer cond.delete();
        self.value_stack.pop_back();

        var cond_value = cond.to_value_t();
        defer cond_value.delete();

        var cond_true_label = self.label_gen.create_index();
        var cond_inst = sir_br_cond::new(
            cond_value,
            cond_true_label,
            0
        );
        self.block->add_stmt(cond_inst => sir*);

        var cond_true_block = sir_basic_block::new(
            cond_true_label,
            "loop.cond.true"
        );
        self.func_block->add_basic_block(cond_true_block);
        self.block = cond_true_block;

        self.visit(n->content => mir*);

        // if the last sir is ret, br behind it will let llvm generating
        // a numberic label implicitly, so we need to add a label to avoid
        // this error
        // example:
        //   label.10:	; branch.end
        //     ret i32 0
        //     br label %label.13
        // expect:
        //   label.10:	; branch.end
        //     ret i32 0
        //   label.12:	; loop.ret_end_avoid_error
        //     br label %label.13
        if (self.block->back_is_ret_stmt()) {
            var ret_block = sir_basic_block::new(
                self.label_gen.create_index(),
                "loop.ret_end_avoid_error"
            );
            self.func_block->add_basic_block(ret_block);
            self.block = ret_block;
        }

        var continue_label = self.label_gen.create_index();
        self.block->add_stmt(sir_br::new(continue_label) => sir*);

        var continue_block = sir_basic_block::new(continue_label, "loop.continue");
        self.func_block->add_basic_block(continue_block);
        self.block = continue_block;
        foreach (var i; self.continue_inst.back()) {
            i.get()->label = continue_label;
        }

        if (n->update != nil) {
            self.visit(n->update => mir*);
        }

        self.block->add_stmt(sir_br::new(entry_label) => sir*);

        var exit_label = self.label_gen.create_index();
        cond_inst->label_false = exit_label;

        var exit_block = sir_basic_block::new(exit_label, "loop.exit");
        self.func_block->add_basic_block(exit_block);
        self.block = exit_block;
        foreach (var i; self.break_inst.back()) {
            i.get()->label = exit_label;
        }

        self.continue_inst.pop_back();
        self.break_inst.pop_back();
    }

    func visit_mir_return(self, n: mir_return*) {
        if (n->value == nil) {
            var void_name = str::from("void");
            defer void_name.delete();

            var null_val = value_t::null(nil);
            defer null_val.delete();

            self.block->add_stmt(sir_ret::new(
                void_name,
                null_val,
                self.generate_DI_location(n->base.location)
            ) => sir*);
            return;
        }

        if (n->value->kind == mir_kind::mir_call) {
            self.call_expr_gen(n->value => mir_call*, n->return_ref_type);
        } else {
            self.visit(n->value => mir*);
        }

        var ret = self.value_stack.back().clone();
        self.value_stack.pop_back();
        defer ret.delete();

        var ret_ty = self.type_mapping(ret.resolved_type);
        defer ret_ty.delete();

        var ret_val = ret.to_value_t();
        defer ret_val.delete();

        self.block->add_stmt(sir_ret::new(
            ret_ty,
            ret_val,
            self.generate_DI_location(n->base.location)
        ) => sir*);
    }

    func visit(self, n: mir*) {
        match (n->kind) {
            mir_kind::mir_block => self.visit_mir_block(n => mir_block*);
            mir_kind::mir_unary => self.visit_mir_unary(n => mir_unary*);
            mir_kind::mir_binary => self.visit_mir_binary(n => mir_binary*);
            mir_kind::mir_type_convert => self.visit_mir_type_convert(n => mir_type_convert*);
            mir_kind::mir_nil => self.visit_mir_nil(n => mir_nil*);
            mir_kind::mir_number => self.visit_mir_number(n => mir_number*);
            mir_kind::mir_string => self.visit_mir_string(n => mir_string*);
            mir_kind::mir_char => self.visit_mir_char(n => mir_char*);
            mir_kind::mir_bool => self.visit_mir_bool(n => mir_bool*);
            mir_kind::mir_array => self.visit_mir_array(n => mir_array*);
            mir_kind::mir_struct_init => self.visit_mir_struct_init(n => mir_struct_init*);
            mir_kind::mir_call => self.visit_mir_call(n => mir_call*);
            mir_kind::mir_call_id => self.visit_mir_call_id(n => mir_call_id*);
            mir_kind::mir_call_index => self.visit_mir_call_index(n => mir_call_index*);
            mir_kind::mir_call_func => self.visit_mir_call_func(n => mir_call_func*);
            mir_kind::mir_get_field => self.visit_mir_get_field(n => mir_get_field*);
            mir_kind::mir_ptr_get_field => self.visit_mir_ptr_get_field(n => mir_ptr_get_field*);
            mir_kind::mir_get_path => self.visit_mir_get_path(n => mir_get_path*);
            mir_kind::mir_define => self.visit_mir_define(n => mir_define*);
            mir_kind::mir_assign => self.visit_mir_assign(n => mir_assign*);
            mir_kind::mir_if => self.visit_mir_if(n => mir_if*);
            mir_kind::mir_branch => self.visit_mir_branch(n => mir_branch*);
            mir_kind::mir_switch_case => self.visit_mir_switch_case(n => mir_switch_case*);
            mir_kind::mir_switch => self.visit_mir_switch(n => mir_switch*);
            mir_kind::mir_break => self.visit_mir_break();
            mir_kind::mir_continue => self.visit_mir_continue();
            mir_kind::mir_loop => self.visit_mir_loop(n => mir_loop*);
            mir_kind::mir_return => self.visit_mir_return(n => mir_return*);
            _ => unreachable();
        }
    }
}

impl mir2sir {
    func generate_DI_type_if_not_exists(self, n: str&) {
        var temp = n.clone();
        defer temp.delete();

        // recursively generate DI type for pointer type
        var p: DI_node* = nil;
        while (temp.back() == '*' || temp.back() == '&') {
            if (self.sctx->DI_type_map.has(temp) && p != nil) {
                p->get_DW_TAG_pointer_type()->base_type_index = self.sctx->DI_type_map.get(temp);
                break;
            }
            if (p != nil) {
                p->get_DW_TAG_pointer_type()->base_type_index = self.dwarf_status.DI_counter;
            }

            if (temp.back() == '*') {
                p = DW_TAG_pointer_type::new(
                    self.dwarf_status.DI_counter,
                    DI_ERROR_INDEX(), // base type index is set to error index now
                    64,
                    temp.c_str
                );
            } else {
                p = DW_TAG_reference_type::new(
                    self.dwarf_status.DI_counter,
                    DI_ERROR_INDEX(), // base type index is set to error index now
                    64,
                    temp.c_str
                );
            }
            self.sctx->debug_info.push(p);
            self.sctx->add_DI_type(temp.c_str, self.dwarf_status.DI_counter);
            self.dwarf_status.DI_counter += 1;
            temp.pop_back();
        }

        if (self.sctx->DI_type_map.has(temp) && p != nil) {
            if (p->is_DW_TAG_pointer_type()) {
                p->get_DW_TAG_pointer_type()->base_type_index = self.sctx->DI_type_map.get(temp);
            } else if (p->is_DW_TAG_reference_type()) {
                p->get_DW_TAG_reference_type()->base_type_index = self.sctx->DI_type_map.get(temp);
            }
        } else {
            var info = str::from("cannot generate DI_type for \"");
            info.append(n.c_str).append("\"");
            defer info.delete();

            panic(info.c_str);
        }
    }

    func find_DI_type(self, ty: type&) -> DI_node* {
        if (ty.is_void() && !ty.is_pointer()) {
            return DI_null::new();
        }

        var n = ty.full_path_name_with_pointer(self.pkg);
        defer n.delete();

        if (!self.sctx->DI_type_map.has(n)) {
            self.generate_DI_type_if_not_exists(n);
        }
        var index = self.sctx->DI_type_map.get(n);
        return DI_ref_index::new(index);
    }

    func find_DI_type_index(self, ty: type&) -> u64 {
        if (ty.is_void() && !ty.is_pointer()) {
            return DI_ERROR_INDEX();
        }

        var n = ty.full_path_name_with_pointer(self.pkg);
        defer n.delete();

        if (!self.sctx->DI_type_map.has(n)) {
            self.generate_DI_type_if_not_exists(n);
        }
        var index = self.sctx->DI_type_map.get(n);
        return index;
    }

    func generate_DI_location(self, loc: span&) -> u64 {
        // if scope index is invalid, we can't add location info
        // if debug mode is not enabled, scope_index must be DI_ERROR_INDEX
        if (self.dwarf_status.scope_index == DI_ERROR_INDEX()) {
            return DI_ERROR_INDEX();
        }

        // check if location is already generated
        if (self.dwarf_status.has_DI_location(loc)) {
            return self.dwarf_status.get_DI_location_index(loc);
        }

        // will do DI_counter + 1 here
        var DI_loc = self.dwarf_status.new_DI_location(loc);
        self.sctx->debug_info.push(DI_loc);
        return DI_loc->index();
    }

    func generate_llvm_ident(self) {
        var ident = DI_named_metadata::new("llvm.ident");
        self.sctx->named_metadata.push(ident);

        var version_str = str::from("colgm compiler version ");
        version_str.append(version());
        defer version_str.delete();

        var ver_list = DI_list::new(self.dwarf_status.DI_counter);
        ver_list->add(DI_string::new(version_str.c_str));
        ident->add(DI_ref_index::new(self.dwarf_status.DI_counter));
        self.sctx->debug_info.push(ver_list);

        self.dwarf_status.DI_counter += 1;
    }

    func generate_llvm_module_flags(self) {
        var module_flags = DI_named_metadata::new("llvm.module.flags");
        self.sctx->named_metadata.push(module_flags);

        var dwarf_version = DI_list::new(self.dwarf_status.DI_counter);
        dwarf_version->add(DI_i32::new(7));
        dwarf_version->add(DI_string::new("Dwarf Version"));
        dwarf_version->add(DI_i32::new(4));
        self.sctx->debug_info.push(dwarf_version);
        module_flags->add(DI_ref_index::new(self.dwarf_status.DI_counter));
        self.dwarf_status.DI_counter += 1;

        var debug_info_version = DI_list::new(self.dwarf_status.DI_counter);
        debug_info_version->add(DI_i32::new(2));
        debug_info_version->add(DI_string::new("Debug Info Version"));
        debug_info_version->add(DI_i32::new(3));
        self.sctx->debug_info.push(debug_info_version);
        module_flags->add(DI_ref_index::new(self.dwarf_status.DI_counter));
        self.dwarf_status.DI_counter += 1;

        var wchar_size = DI_list::new(self.dwarf_status.DI_counter);
        wchar_size->add(DI_i32::new(1));
        wchar_size->add(DI_string::new("wchar_size"));
        wchar_size->add(DI_i32::new(4));
        self.sctx->debug_info.push(wchar_size);
        module_flags->add(DI_ref_index::new(self.dwarf_status.DI_counter));
        self.dwarf_status.DI_counter += 1;

        if (streq(get_platform(), "macos")) {
            var pic_level = DI_list::new(self.dwarf_status.DI_counter);
            pic_level->add(DI_i32::new(8));
            pic_level->add(DI_string::new("PIC level"));
            pic_level->add(DI_i32::new(2));
            self.sctx->debug_info.push(pic_level);
            module_flags->add(DI_ref_index::new(self.dwarf_status.DI_counter));
            self.dwarf_status.DI_counter += 1;
        }

        var uwtable = DI_list::new(self.dwarf_status.DI_counter);
        uwtable->add(DI_i32::new(7));
        uwtable->add(DI_string::new("uwtable"));
        uwtable->add(DI_i32::new(1));
        self.sctx->debug_info.push(uwtable);
        module_flags->add(DI_ref_index::new(self.dwarf_status.DI_counter));
        self.dwarf_status.DI_counter += 1;

        var frame_pointer = DI_list::new(self.dwarf_status.DI_counter);
        frame_pointer->add(DI_i32::new(7));
        frame_pointer->add(DI_string::new("frame-pointer"));
        frame_pointer->add(DI_i32::new(1));
        self.sctx->debug_info.push(frame_pointer);
        module_flags->add(DI_ref_index::new(self.dwarf_status.DI_counter));
        self.dwarf_status.DI_counter += 1;
    }

    func generate_DI_file(self) {
        self.sctx->DI_file_map.clear();

        // empty file name maybe used for auto-generated functions
        var empty_file_name = str::instance();
        defer empty_file_name.delete();

        self.sctx->debug_info.push(
            DI_file::new(self.dwarf_status.DI_counter, "", "")
        );
        self.sctx->DI_file_map.insert(
            empty_file_name,
            self.dwarf_status.DI_counter
        );
        self.dwarf_status.DI_counter += 1;

        // if DIFile is a single filename and the directory is empty
        // dsymutil may report no debug symbol
        // so directory must be set here
        // !DIFile(filename: "main.colgm", directory: "")
        //                                            ^^ should not be empty
        var cwd = fs::getcwd();
        defer cwd.delete();

        foreach (var i; self.ctx->global->domain) {
            self.sctx->debug_info.push(DI_file::new(
                self.dwarf_status.DI_counter,
                i.key().c_str,
                cwd.c_str
            ));
            self.sctx->DI_file_map.insert(
                i.key(),
                self.dwarf_status.DI_counter
            );
            self.dwarf_status.DI_counter += 1;
        }
    }

    func generate_llvm_dbg_cu(self) -> DI_node* {
        var llvm_dbg_cu = DI_named_metadata::new("llvm.dbg.cu");
        self.sctx->named_metadata.push(llvm_dbg_cu);

        var main_entry_index = self.sctx->DI_file_map.get(
            self.ctx->global->main_entry_file
        );
        self.dwarf_status.compile_unit_index = self.dwarf_status.DI_counter;

        var version_str = str::from("colgm compiler version ");
        version_str.append(version());
        defer version_str.delete();

        var cu = DI_compile_unit::new(
            self.dwarf_status.DI_counter,
            version_str.c_str,
            main_entry_index
        );
        llvm_dbg_cu->add(DI_ref_index::new(self.dwarf_status.DI_counter));
        self.sctx->debug_info.push(cu);
        self.dwarf_status.DI_counter += 1;

        return cu;
    }

    func generate_basic_type(self) {
        self.sctx->debug_info.push(DI_basic_type::new(
            self.dwarf_status.DI_counter,
            "i8",
            8,
            "DW_ATE_signed"
        ));
        self.sctx->add_DI_type("i8", self.dwarf_status.DI_counter);
        self.dwarf_status.DI_counter += 1;

        self.sctx->debug_info.push(DI_basic_type::new(
            self.dwarf_status.DI_counter,
            "i16",
            16,
            "DW_ATE_signed"
        ));
        self.sctx->add_DI_type("i16", self.dwarf_status.DI_counter);
        self.dwarf_status.DI_counter += 1;

        self.sctx->debug_info.push(DI_basic_type::new(
            self.dwarf_status.DI_counter,
            "i32",
            32,
            "DW_ATE_signed"
        ));
        self.sctx->add_DI_type("i32", self.dwarf_status.DI_counter);
        self.dwarf_status.DI_counter += 1;

        self.sctx->debug_info.push(DI_basic_type::new(
            self.dwarf_status.DI_counter,
            "i64",
            64,
            "DW_ATE_signed"
        ));
        self.sctx->add_DI_type("i64", self.dwarf_status.DI_counter);
        self.dwarf_status.DI_counter += 1;

        self.sctx->debug_info.push(DI_basic_type::new(
            self.dwarf_status.DI_counter,
            "u8",
            8,
            "DW_ATE_unsigned"
        ));
        self.sctx->add_DI_type("u8", self.dwarf_status.DI_counter);
        self.dwarf_status.DI_counter += 1;

        self.sctx->debug_info.push(DI_basic_type::new(
            self.dwarf_status.DI_counter,
            "u16",
            16,
            "DW_ATE_unsigned"
        ));
        self.sctx->add_DI_type("u16", self.dwarf_status.DI_counter);
        self.dwarf_status.DI_counter += 1;

        self.sctx->debug_info.push(DI_basic_type::new(
            self.dwarf_status.DI_counter,
            "u32",
            32,
            "DW_ATE_unsigned"
        ));
        self.sctx->add_DI_type("u32", self.dwarf_status.DI_counter);
        self.dwarf_status.DI_counter += 1;

        self.sctx->debug_info.push(DI_basic_type::new(
            self.dwarf_status.DI_counter,
            "u64",
            64,
            "DW_ATE_unsigned"
        ));
        self.sctx->add_DI_type("u64", self.dwarf_status.DI_counter);
        self.dwarf_status.DI_counter += 1;

        self.sctx->debug_info.push(DI_basic_type::new(
            self.dwarf_status.DI_counter,
            "f32",
            32,
            "DW_ATE_float"
        ));
        self.sctx->add_DI_type("f32", self.dwarf_status.DI_counter);
        self.dwarf_status.DI_counter += 1;

        self.sctx->debug_info.push(DI_basic_type::new(
            self.dwarf_status.DI_counter,
            "f64",
            64,
            "DW_ATE_float"
        ));
        self.sctx->add_DI_type("f64", self.dwarf_status.DI_counter);
        self.dwarf_status.DI_counter += 1;

        self.sctx->debug_info.push(DI_basic_type::new(
            self.dwarf_status.DI_counter,
            "bool",
            1,
            "DW_ATE_boolean"
        ));
        self.sctx->add_DI_type("bool", self.dwarf_status.DI_counter);
        self.dwarf_status.DI_counter += 1;
    }

    func generate_single_DI_enum(self, e: colgm_enum&) -> u64 {
        var ty = type::instance(e.name.c_str, e.location.file.c_str);
        defer ty.delete();

        var id = ty.full_path_name(self.pkg);
        defer id.delete();

        var i64_s = str::from("i64");
        defer i64_s.delete();

        var tmp = DI_enum_type::new(
            self.dwarf_status.DI_counter,
            e.name.c_str,
            id.c_str,
            self.sctx->DI_file_map.get(e.location.file),
            e.location.begin_line,
            self.sctx->DI_type_map.get(i64_s)
        );
        self.sctx->add_DI_type(id.c_str, self.dwarf_status.DI_counter);
        self.sctx->debug_info.push(tmp);
        self.dwarf_status.DI_counter += 1;

        var enum_list = DI_list::new(self.dwarf_status.DI_counter);
        self.sctx->debug_info.push(enum_list);
        tmp->get_DI_enum_type()->elements_index = self.dwarf_status.DI_counter;
        self.dwarf_status.DI_counter += 1;

        foreach (var i; e.ordered_member) {
            self.sctx->debug_info.push(DI_enumerator::new(
                self.dwarf_status.DI_counter,
                i.get().c_str,
                e.members.get(i.get())
            ));
            enum_list->add(DI_ref_index::new(self.dwarf_status.DI_counter));
            self.dwarf_status.DI_counter += 1;
        }

        return tmp->index();
    }

    func generate_DI_enum_type(self) -> u64 {
        var enums_list = DI_list::new(self.dwarf_status.DI_counter);
        self.sctx->debug_info.push(enums_list);
        self.dwarf_status.DI_counter += 1;

        foreach (var i; self.ctx->global->domain) {
            foreach (var j; i.value().enums) {
                var index = self.generate_single_DI_enum(j.value());
                enums_list->add(DI_ref_index::new(index));
            }
        }

        return enums_list->index();
    }

    func generate_single_DI_struct(self, s: colgm_struct&) {
        var ty = type::instance(s.name.c_str, s.location.file.c_str);
        defer ty.delete();

        var id = ty.full_path_name(self.pkg);
        defer id.delete();

        var tmp = DI_structure_type::new(
            self.dwarf_status.DI_counter,
            s.name.c_str,
            id.c_str,
            self.sctx->DI_file_map.get(s.location.file),
            s.location.begin_line
        );
        self.sctx->add_DI_type(id.c_str, self.dwarf_status.DI_counter);
        self.sctx->add_DI_struct(id.c_str, tmp);
        self.sctx->debug_info.push(tmp);
        self.dwarf_status.DI_counter += 1;
    }

    func generate_DI_structure_type(self) {
        foreach (var i; self.ctx->global->domain) {
            foreach (var j; i.value().structs) {
                self.generate_single_DI_struct(j.value());
            }
        }
    }

    func generate_single_DI_tagged_union(self, u: colgm_tagged_union&) {
        var ty = type::instance(u.name.c_str, u.location.file.c_str);
        defer ty.delete();

        var id = ty.full_path_name(self.pkg);
        defer id.delete();

        var tmp = DI_union_type::new(
            self.dwarf_status.DI_counter,
            u.name.c_str,
            id.c_str,
            self.sctx->DI_file_map.get(u.location.file),
            u.location.begin_line
        );
        self.sctx->add_DI_type(id.c_str, self.dwarf_status.DI_counter);
        self.sctx->add_DI_union(id.c_str, tmp);
        self.sctx->debug_info.push(tmp);
        self.dwarf_status.DI_counter += 1;
    }

    func generate_DI_tagged_union_type(self) {
        foreach (var i; self.ctx->global->domain) {
            foreach (var j; i.value().tagged_unions) {
                self.generate_single_DI_tagged_union(j.value());
            }
        }
    }

    func generate_single_struct_member_dwarf(self, s: colgm_struct&) {
        var ty = type::instance(s.name.c_str, s.location.file.c_str);
        defer ty.delete();

        var id = ty.full_path_name(self.pkg);
        defer id.delete();

        var s_node = self.sctx->DI_struct_map.get(id);

        var element = DI_list::new(self.dwarf_status.DI_counter);
        s_node->get_DI_structure_type()->elements = self.dwarf_status.DI_counter;
        self.sctx->debug_info.push(element);
        self.dwarf_status.DI_counter += 1;

        foreach (var i; s.ordered_fields) {
            var member = i.get();
            var member_type = s.fields.get(member);
            var member_span = s.fields_span.get(member);
            var member_type_index = self.find_DI_type_index(member_type);
            var field_node = DW_TAG_member::new(
                self.dwarf_status.DI_counter,
                member.c_str,
                s_node->index(),
                self.sctx->DI_file_map.get(member_span.file),
                member_span.begin_line + 1,
                member_type_index
            );
            self.sctx->debug_info.push(field_node);
            element->add(DI_ref_index::new(self.dwarf_status.DI_counter));
            self.dwarf_status.DI_counter += 1;
        }
    }

    func generate_structure_member_dwarf(self) {
        foreach (var i; self.ctx->global->domain) {
            foreach (var j; i.value().structs) {
                self.generate_single_struct_member_dwarf(j.value());
            }
        }
    }

    func generate_single_tagged_union_member_dwarf(self, u: colgm_tagged_union&) {
        var ty = type::instance(u.name.c_str, u.location.file.c_str);
        defer ty.delete();

        var id = ty.full_path_name(self.pkg);
        defer id.delete();

        var u_node = self.sctx->DI_union_map.get(id);

        var element = DI_list::new(self.dwarf_status.DI_counter);
        u_node->get_DI_union_type()->elements = self.dwarf_status.DI_counter;
        self.sctx->debug_info.push(element);
        self.dwarf_status.DI_counter += 1;

        foreach (var i; u.ordered_members) {
            var member = i.get();
            var member_type = u.members.get(member);
            var member_span = u.members_span.get(member);
            var member_type_index = self.find_DI_type_index(member_type);
            var field_node = DW_TAG_member::new(
                self.dwarf_status.DI_counter,
                member.c_str,
                u_node->index(),
                self.sctx->DI_file_map.get(member_span.file),
                member_span.begin_line + 1,
                member_type_index
            );
            self.sctx->debug_info.push(field_node);
            element->add(DI_ref_index::new(self.dwarf_status.DI_counter));
            self.dwarf_status.DI_counter += 1;
        }
    }

    func generate_tagged_union_member_dwarf(self) {
        foreach (var i; self.ctx->global->domain) {
            foreach (var j; i.value().tagged_unions) {
                self.generate_single_tagged_union_member_dwarf(j.value());
            }
        }
    }

    func generate_single_DI_subprogram(self, f: mir_func&) {
        // auto added libc functions may not have location
        if (!self.sctx->DI_file_map.has(f.location.file)) {
            return;
        }

        var tmp = DI_subprogram::new(
            self.dwarf_status.DI_counter,
            f.name.c_str,
            self.sctx->DI_file_map.get(f.location.file),
            f.location.begin_line,
            self.dwarf_status.DI_counter + 1,    // `type` field, DISubroutineType
            self.dwarf_status.compile_unit_index // `unit` field, DICompileUnit
        );
        self.sctx->debug_info.push(tmp);
        if (f.block != nil) {
            self.dwarf_status.impl_debug_info.insert(
                f.name,
                self.dwarf_status.DI_counter
            );
        }
        self.dwarf_status.DI_counter += 1;

        // DISubprogram must have DISubroutineType as `type` field
        // otherwise segfault will happen when using llc or clang
        // issue: https://github.com/llvm/llvm-project/issues/59471
        var subroutine = DI_subroutine::new(
            self.dwarf_status.DI_counter,    // self index
            self.dwarf_status.DI_counter + 1 // DI_list index
        );
        self.sctx->debug_info.push(subroutine);
        self.dwarf_status.DI_counter += 1;

        var ty_list = DI_list::new(self.dwarf_status.DI_counter);
        self.sctx->debug_info.push(ty_list);
        self.dwarf_status.DI_counter += 1;

        ty_list->add(self.find_DI_type(f.return_type));
        foreach (var i; f.params) {
            ty_list->add(self.find_DI_type(i.get().value));
        }
    }

    func generate_DI_subprogram(self, mctx: mir_context&) {
        // only generate subprogram for impls
        foreach (var i; mctx.impls) {
            self.generate_single_DI_subprogram(i.get());
        }
    }

    func generate_DWARF(self, mctx: mir_context&) {
        self.generate_llvm_ident();
        self.generate_llvm_module_flags();
        self.generate_DI_file();
        var cu = self.generate_llvm_dbg_cu();

        // generate info for base types
        self.generate_basic_type();
        cu->get_DI_compile_unit()->enums_index = self.generate_DI_enum_type();
        self.generate_DI_structure_type();
        self.generate_DI_tagged_union_type();

        // generate after all base types are registered
        self.generate_structure_member_dwarf();
        self.generate_tagged_union_member_dwarf();
        self.generate_DI_subprogram(mctx);
    }
}

impl mir2sir {
    func run_sir_pass(self, view_unused_func: bool, with_opt: bool, verbose: bool) {
        adjust_va_arg(self.sctx, verbose);
        replace_ptr_call(self.sctx, verbose);
        replace_size_call(self.sctx, verbose);
        detect_redef_extern(self.sctx, self.err, verbose);

        if (with_opt) {
            remove_unused_func(self.sctx, view_unused_func, verbose);
            inst_combine(self.sctx, verbose);
            replace_const_br(self.sctx, verbose);
            combine_load_store(self.sctx, verbose);

            simplify_cfg(self.sctx, verbose);

            remove_unused_string(self.sctx, verbose);
            remove_unused_ssa(self.sctx, verbose);
        }

        variable_rename_to_form_ssa(self.sctx, verbose);
    }

    pub func generate(self, mctx: mir_context&,
                            view_unused_func: bool,
                            with_opt: bool,
                            verbose: bool,
                            debug_mode: bool) {
        // debug mode is enabled by '-g'
        if (debug_mode) {
            self.dwarf_status.clear();
            self.generate_DWARF(mctx);
        }

        self.generate_type_mapper();
        self.sc.calculate(mctx, verbose);
        self.emit_tagged_union(mctx);
        self.emit_struct(mctx);
        self.emit_func_decl(mctx);
        self.emit_func_impl(mctx);

        self.run_sir_pass(view_unused_func, with_opt, verbose);
    }
}