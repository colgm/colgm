use std::map::{ hashmap, pair };
use std::str::{ str };
use std::ptr::{ ptr, basic };
use std::io::{ io };
use std::vec::{ vec };

use mir::mir::*;
use mir::context::{ mir_context, mir_func };
use sir::ssa_name_gen::{ ssa_generator };
use sir::local_scope::{ local_table };
use sir::sir::*;
use sir::context::{ sir_struct, sir_func, sir_context };
use sir::value::{ value_t };
use sir::adjust_va_arg::{ adjust_va_arg };
use sir::replace_ptr_call::{ replace_struct_ptr_call };

use dwarf::dwarf::*;

use sema::symbol_info::{ symbol_kind };
use sema::context::{ sema_context };
use sema::type::{ type };

use err::panic::{ panic, unreachable };
use package::{ package };
use util::mangling::{ mangle_struct_name, mangle_function_name };

enum mir_value_kind {
    null, // reserved
    nil_value,
    variable,
    literal,
    primitive,
    func_symbol,
    method,
    struct_symbol,
    enum_symbol
}

struct mir_value_t {
    value_kind: mir_value_kind,
    content: str,
    resolved_type: type
}

impl mir_value_t {
    pub func copy(self) -> mir_value_t* {
        var res = mir_value_t::__alloc__();
        res->value_kind = self->value_kind;
        res->content = self->content.copy_instance();
        res->resolved_type = self->resolved_type.copy_instance();
        return res;
    }

    pub func copy_instance(self) -> mir_value_t {
        return mir_value_t {
            value_kind: self->value_kind,
            content: self->content.copy_instance(),
            resolved_type: self->resolved_type.copy_instance()
        };
    }

    pub func delete(self) {
        self->content.delete();
        self->resolved_type.delete();
    }

    pub func to_value_t(self) -> value_t {
        match (self->value_kind) {
            mir_value_kind::null => {
                var name = str::from("null");
                var res = value_t::null(name.__ptr__());
                name.delete();
                return res;
            }
            mir_value_kind::nil_value => {
                return value_t::literal(self->content.__ptr__());
            }
            mir_value_kind::literal => {
                return value_t::literal(self->content.__ptr__());
            }
            mir_value_kind::variable => {
                return value_t::variable(self->content.__ptr__());
            }
            mir_value_kind::primitive => {
                var name = str::from("primitive");
                var res = value_t::null(name.__ptr__());
                name.delete();
                return res;
            }
            mir_value_kind::func_symbol => {
                var name = str::from("func");
                var res = value_t::null(name.__ptr__());
                name.delete();
                return res;
            }
            mir_value_kind::method => {
                var name = str::from("method");
                var res = value_t::null(name.__ptr__());
                name.delete();
                return res;
            }
            mir_value_kind::struct_symbol => {
                var name = str::from("struct");
                var res = value_t::null(name.__ptr__());
                name.delete();
                return res;
            }
            mir_value_kind::enum_symbol => {
                var name = str::from("enum");
                var res = value_t::null(name.__ptr__());
                name.delete();
                return res;
            }
        }
        // unreachable
        return value_t::null(nil);
    }

    func nil_value(ty: type*) -> mir_value_t {
        return mir_value_t {
            value_kind: mir_value_kind::nil_value,
            content: str::from("null"),
            resolved_type: ty->copy_instance()
        };
    }

    func variable(name: str*, ty: type*) -> mir_value_t {
        return mir_value_t {
            value_kind: mir_value_kind::variable,
            content: name->copy_instance(),
            resolved_type: ty->copy_instance()
        };
    }

    func literal(value: str*, ty: type*) -> mir_value_t {
        return mir_value_t {
            value_kind: mir_value_kind::literal,
            content: value->copy_instance(),
            resolved_type: ty->copy_instance()
        };
    }

    func primitive(value: str*, ty: type*) -> mir_value_t {
        return mir_value_t {
            value_kind: mir_value_kind::primitive,
            content: value->copy_instance(),
            resolved_type: ty->copy_instance()
        };
    }

    func func_symbol(name: str*, ty: type*) -> mir_value_t {
        return mir_value_t {
            value_kind: mir_value_kind::func_symbol,
            content: name->copy_instance(),
            resolved_type: ty->copy_instance()
        };
    }

    func method(name: str*, ty: type*) -> mir_value_t {
        return mir_value_t {
            value_kind: mir_value_kind::method,
            content: name->copy_instance(),
            resolved_type: ty->copy_instance()
        };
    }

    func struct_symbol(name: str*, ty: type*) -> mir_value_t {
        return mir_value_t {
            value_kind: mir_value_kind::struct_symbol,
            content: name->copy_instance(),
            resolved_type: ty->copy_instance()
        };
    }

    func enum_symbol(name: str*, ty: type*) -> mir_value_t {
        return mir_value_t {
            value_kind: mir_value_kind::enum_symbol,
            content: name->copy_instance(),
            resolved_type: ty->copy_instance()
        };
    }
}

pub struct mir2sir {
    ctx: sema_context*,
    sctx: sir_context*,
    pkg: package*,
    type_mapper: hashmap<str, basic<symbol_kind>>,
    basic_type_mapper: hashmap<str, str>,
    primitive_methods: hashmap<str, str>,

    block: sir_block*,
    ssa_gen: ssa_generator,
    array_ssa_gen: ssa_generator,
    
    value_stack: vec<mir_value_t>,

    locals: local_table,

    continue_inst: vec<vec<ptr<sir_br>>>,
    break_inst: vec<vec<ptr<sir_br>>>,
    branch_jump_out: vec<vec<ptr<sir_br>>>
}

impl mir2sir {
    pub func instance(ctx: sema_context*,
                      sctx: sir_context*,
                      pkg: package*) -> mir2sir {
        var res = mir2sir {
            ctx: ctx,
            sctx: sctx,
            pkg: pkg,
            type_mapper: hashmap<str, basic<symbol_kind>>::instance(),
            basic_type_mapper: hashmap<str, str>::instance(),
            primitive_methods: hashmap<str, str>::instance(),
            block: nil,
            ssa_gen: ssa_generator::instance(),
            array_ssa_gen: ssa_generator::instance(),
            value_stack: vec<mir_value_t>::instance(),
            locals: local_table::instance(),
            continue_inst: vec<vec<ptr<sir_br>>>::instance(),
            break_inst: vec<vec<ptr<sir_br>>>::instance(),
            branch_jump_out: vec<vec<ptr<sir_br>>>::instance()
        };
        res.init_basic_type_mapper();
        res.init_primitive__size_methods();
        return res;
    }

    pub func delete(self) {
        self->type_mapper.delete();
        self->basic_type_mapper.delete();
        self->primitive_methods.delete();
        self->value_stack.delete();
        self->locals.delete();

        // do not need to delete ptr in them
        // all ptrs are inserted into sir_func's body
        self->continue_inst.delete();
        self->break_inst.delete();
        self->branch_jump_out.delete();
    }

    func init_basic_type_mapper(self) {
        var i64_s = str::from("i64");
        var i32_s = str::from("i32");
        var i16_s = str::from("i16");
        var i8_s = str::from("i8");
        var i1_s = str::from("i1");
        var u64_s = str::from("u64");
        var u32_s = str::from("u32");
        var u16_s = str::from("u16");
        var u8_s = str::from("u8");
        var f64_s = str::from("f64");
        var f32_s = str::from("f32");
        var void_s = str::from("void");
        var bool_s = str::from("bool");

        var double_s = str::from("double");
        var float_s = str::from("float");

        self->basic_type_mapper.insert(i64_s.__ptr__(), i64_s.__ptr__());
        self->basic_type_mapper.insert(i32_s.__ptr__(), i32_s.__ptr__());
        self->basic_type_mapper.insert(i16_s.__ptr__(), i16_s.__ptr__());
        self->basic_type_mapper.insert(i8_s.__ptr__(), i8_s.__ptr__());
        self->basic_type_mapper.insert(u64_s.__ptr__(), i64_s.__ptr__());
        self->basic_type_mapper.insert(u32_s.__ptr__(), i32_s.__ptr__());
        self->basic_type_mapper.insert(u16_s.__ptr__(), i16_s.__ptr__());
        self->basic_type_mapper.insert(u8_s.__ptr__(), i8_s.__ptr__());
        self->basic_type_mapper.insert(f64_s.__ptr__(), double_s.__ptr__());
        self->basic_type_mapper.insert(f32_s.__ptr__(), float_s.__ptr__());
        self->basic_type_mapper.insert(void_s.__ptr__(), void_s.__ptr__());
        self->basic_type_mapper.insert(bool_s.__ptr__(), i1_s.__ptr__());

        i64_s.delete();
        i32_s.delete();
        i16_s.delete();
        i8_s.delete();
        i1_s.delete();
        u64_s.delete();
        u32_s.delete();
        u16_s.delete();
        u8_s.delete();
        f64_s.delete();
        f32_s.delete();
        void_s.delete();
        bool_s.delete();
        double_s.delete();
        float_s.delete();
    }

    func init_primitive__size_methods(self) {
        var size_1 = str::from("1");
        var size_2 = str::from("2");
        var size_4 = str::from("4");
        var size_8 = str::from("8");

        var i64_s = str::from("i64.__size__");
        var i32_s = str::from("i32.__size__");
        var i16_s = str::from("i16.__size__");
        var i8_s = str::from("i8.__size__");
        var i1_s = str::from("i1.__size__");
        var u64_s = str::from("u64.__size__");
        var u32_s = str::from("u32.__size__");
        var u16_s = str::from("u16.__size__");
        var u8_s = str::from("u8.__size__");
        var f64_s = str::from("f64.__size__");
        var f32_s = str::from("f32.__size__");
        var bool_s = str::from("bool.__size__");

        self->primitive_methods.insert(i64_s.__ptr__(), size_8.__ptr__());
        self->primitive_methods.insert(i32_s.__ptr__(), size_4.__ptr__());
        self->primitive_methods.insert(i16_s.__ptr__(), size_2.__ptr__());
        self->primitive_methods.insert(i8_s.__ptr__(), size_1.__ptr__());
        self->primitive_methods.insert(u64_s.__ptr__(), size_8.__ptr__());
        self->primitive_methods.insert(u32_s.__ptr__(), size_4.__ptr__());
        self->primitive_methods.insert(u16_s.__ptr__(), size_2.__ptr__());
        self->primitive_methods.insert(u8_s.__ptr__(), size_1.__ptr__());
        self->primitive_methods.insert(f64_s.__ptr__(), size_8.__ptr__());
        self->primitive_methods.insert(f32_s.__ptr__(), size_4.__ptr__());
        self->primitive_methods.insert(bool_s.__ptr__(), size_1.__ptr__());

        size_1.delete();
        size_2.delete();
        size_4.delete();
        size_8.delete();
        i64_s.delete();
        i32_s.delete();
        i16_s.delete();
        i8_s.delete();
        i1_s.delete();
        u64_s.delete();
        u32_s.delete();
        u16_s.delete();
        u8_s.delete();
        f64_s.delete();
        f32_s.delete();
        bool_s.delete();
    }
}

impl mir2sir {
    func emit_struct(self, mctx: mir_context*) {
        for (var i = mctx->structs.iter(); !i.is_end(); i = i.next()) {
            var m_stct = i.get();

            var s_ty = type::instance();
            s_ty.name.append_str(m_stct->name.__ptr__());
            s_ty.loc_file.append_str(m_stct->location.file.__ptr__());
            
            var s_ty_name = s_ty.full_path_name(self->pkg, false);
            var s_ty_llvm_name = mangle_struct_name(s_ty_name.__ptr__());

            var s_stct = sir_struct::instance(
                s_ty_llvm_name.__ptr__(),
                m_stct->location.__ptr__()
            );
            s_ty_name.delete();
            s_ty_llvm_name.delete();

            for (var j = m_stct->field_type.iter(); !j.is_end(); j = j.next()) {
                var m_field = j.get();
                var mapped_type = self->type_mapping(m_field);

                s_stct.field_type.push(mapped_type.__ptr__());

                mapped_type.delete();
            }

            self->sctx->struct_decls.push(s_stct.__ptr__());
            s_stct.delete();
        }
    }

    func emit_func_decl(self, mctx: mir_context*) {
        for (var i = mctx->decls.iter(); !i.is_end(); i = i.next()) {
            var m_func = i.get();
            var s_func = sir_func::instance(m_func->name.__ptr__());
            s_func.set_attributes(m_func->attributes.__ptr__());
            s_func.with_va_args = m_func->with_va_args;

            var ret_type_name = self->type_mapping(m_func->return_type.__ptr__());
            s_func.return_type.append_str(ret_type_name.__ptr__());
            ret_type_name.delete();

            for (var j = m_func->params.iter(); !j.is_end(); j = j.next()) {
                var m_param = j.get();
                var mapped_type = self->type_mapping(m_param->value);
                var p_pair = pair<str, str>::instance(m_param->key, mapped_type.__ptr__());

                s_func.params.push(p_pair.__ptr__());

                mapped_type.delete();
                p_pair.delete();
            }

            self->sctx->func_decls.push(s_func.__ptr__());
            s_func.delete();
        }
    }

    func process_print(self, curr: u64, total: u64) {
        io::stdout().green().out("[mir2sir] ").reset();
        io::stdout().out("generating function (").out_u64(curr + 1);
        io::stdout().out("/").out_u64(total).out(")\r");
    }

    func emit_func_impl(self, mctx: mir_context*) {
        for (var i = mctx->impls.iter(); !i.is_end(); i = i.next()) {
            self->process_print(i.index(), mctx->impls.size);
            var m_func = i.get();
            var m_mangled_name = mangle_function_name(m_func->name.__ptr__());
            var s_func = sir_func::instance(m_mangled_name.__ptr__());
            m_mangled_name.delete();
            
            s_func.set_attributes(m_func->attributes.__ptr__());

            var ret_type_name = self->type_mapping(m_func->return_type.__ptr__());
            s_func.return_type.append_str(ret_type_name.__ptr__());
            ret_type_name.delete();

            // push local scope
            self->locals.push();
            self->locals.local_scope_depth = 0;

            for (var j = m_func->params.iter(); !j.is_end(); j = j.next()) {
                var m_param = j.get();
                var mapped_type = self->type_mapping(m_param->value);

                var param_name = m_param->key->copy_instance();
                param_name.append_i8_vec(".param");

                self->locals.elem.back()->insert(m_param->key, m_param->key);

                var p_pair = pair<str, str>::instance(
                    param_name.__ptr__(),
                    mapped_type.__ptr__()
                );

                s_func.params.push(p_pair.__ptr__());

                param_name.delete();
                mapped_type.delete();
                p_pair.delete();
            }

            self->ssa_gen.clear();
            self->array_ssa_gen.clear();
            self->value_stack.clear();
            s_func.body = sir_block::new();
            self->block = s_func.body;
            self->generate_func_impl_from_mir_func(m_func);
            self->block = nil;

            self->sctx->func_impls.push(s_func.__ptr__());
            s_func.delete();

            // pop local scope
            self->locals.pop();
        }
        io::stdout().endln();
    }
}

impl mir2sir {
    func generate_type_mapper(self) {
        for (var i = self->ctx->global->domain.iter(); !i.is_end(); i = i.next()) {
            var dm = i.value();
            for (var j = dm->enums.iter(); !j.is_end(); j = j.next()) {
                var e_type = type::instance();
                e_type.name.append_str(j.value()->name.__ptr__());
                e_type.loc_file.append_str(j.value()->location.file.__ptr__());
                
                var e_name = e_type.full_path_name(self->pkg, false);
                var e_kind = basic<symbol_kind>::wrap(symbol_kind::enum_kind);

                self->type_mapper.insert(e_name.__ptr__(), e_kind.__ptr__());
                
                e_type.delete();
                e_name.delete();
            }
            for (var j = dm->structs.iter(); !j.is_end(); j = j.next()) {
                var s_type = type::instance();
                s_type.name.append_str(j.value()->name.__ptr__());
                s_type.loc_file.append_str(j.value()->location.file.__ptr__());
                
                var s_name = s_type.full_path_name(self->pkg, false);
                var s_kind = basic<symbol_kind>::wrap(symbol_kind::struct_kind);

                self->type_mapper.insert(s_name.__ptr__(), s_kind.__ptr__());
                
                s_type.delete();
                s_name.delete();
            }
        }
    }

    func type_mapping(self, t: type*) -> str {
        var copy = t->copy_instance();
        // basic type mapping
        if (self->basic_type_mapper.has(copy.name.__ptr__())) {
            var replace = self->basic_type_mapper.get(copy.name.__ptr__());
            copy.name.clear();
            copy.name.append_str(replace);
            copy.loc_file.clear();

            var res = copy.full_path_name(self->pkg, true);
            copy.delete();
            return res;
        }

        var full_name = t->full_path_name(self->pkg, false);
        // if not found, let it crash
        if (!self->type_mapper.has(full_name.__ptr__())) {
            var info = str::from("type not found: ");
            info.append_str(full_name.__ptr__());
            panic(info.c_str);
            info.delete();
        }

        match (self->type_mapper.get(full_name.__ptr__())->unwrap()) {
            symbol_kind::struct_kind => {
                var new_name = mangle_struct_name(full_name.__ptr__());
                copy.name.clear();
                copy.name.append_str(new_name.__ptr__());
                // need to clear loc_file info
                // otherwise for example:
                // std::vec<data::foo>
                //
                // will be wrongly mapped to
                // std::%struct.std.vec<data::foo>
                // but expect to be
                // %struct.std.vec<data::foo>
                copy.loc_file.clear();
                // here we need to clear generic info
                // otherwise for example:
                // std::vec<data::foo>
                //
                // will be wrongly mapped to
                // %struct.std.vec<data::foo><data::foo>
                //         ^^^^^^^^^^^^^^^^^^ name
                //                           ^^^^^^^^^^^ generated from generics
                //
                // but expect to be
                // %struct.std.vec<data::foo>
                copy.generics.clear();

                new_name.delete();
            }
            symbol_kind::enum_kind => {
                var i64_t = type::i64_type();

                // should copy pointer depth too
                i64_t.pointer_depth = copy.pointer_depth;
                copy.reset_with(i64_t.__ptr__());

                i64_t.delete();
            }
            _ => {
                unreachable();
            }
        }

        var res = copy.full_path_name(self->pkg, true);
        copy.delete();
        full_name.delete();
        return res;
    }
}

impl mir2sir {
    func generate_func_impl_from_mir_func(self, m_func: mir_func*) {
        for (var i = m_func->params.iter(); !i.is_end(); i = i.next()) {
            var m_param = i.get();
            var mapped_type = self->type_mapping(m_param->value);

            var param_name = m_param->key->copy_instance();
            param_name.append_i8_vec(".param");

            self->block->add_alloca(
                sir_alloca::new(m_param->key, mapped_type.__ptr__())
            );

            var source = value_t::variable(param_name.__ptr__());
            var target = value_t::variable(m_param->key);
            self->block->add_stmt(sir_store::new(
                mapped_type.__ptr__(),
                source.__ptr__(),
                target.__ptr__()
            ) => sir*);

            param_name.delete();
            mapped_type.delete();
            source.delete();
            target.delete();
        }

        self->visit_mir_block(m_func->block);
    }
}

impl mir2sir {
    func visit_mir_block(self, n: mir_block*) {
        // push local scope
        self->locals.push();

        for (var i = n->content.iter(); !i.is_end(); i = i.next()) {
            self->visit(i.get().unwrap());
        }

        // pop local scope
        self->locals.pop();
    }

    func visit_mir_unary(self, n: mir_unary*) {
        self->visit(n->value => mir*);

        var source = self->value_stack.back()->copy_instance();
        self->value_stack.pop_back();
        var source_value = source.to_value_t();
        var source_ty = self->type_mapping(source.resolved_type.__ptr__());

        var temp_var = self->ssa_gen.create();
        var temp_var_value = value_t::variable(temp_var.__ptr__());
        if (n->op == mir_unary_opr::neg) {
            self->block->add_stmt(sir_neg::new(
                source_value.__ptr__(),
                temp_var_value.__ptr__(),
                source.resolved_type.is_integer(),
                source_ty.__ptr__()
            ) => sir*);
        } else if (n->op == mir_unary_opr::bnot) {
            self->block->add_stmt(sir_bnot::new(
                source_value.__ptr__(),
                temp_var_value.__ptr__(),
                source_ty.__ptr__()
            ) => sir*);
        } else if (n->op == mir_unary_opr::lnot) {
            self->block->add_stmt(sir_lnot::new(
                source_value.__ptr__(),
                temp_var_value.__ptr__(),
                source_ty.__ptr__()
            ) => sir*);
        }

        var v = mir_value_t::variable(temp_var.__ptr__(), n->resolved_type.__ptr__());
        self->value_stack.push(v.__ptr__());
        
        source.delete();
        source_value.delete();
        source_ty.delete();
        temp_var.delete();
        temp_var_value.delete();
        v.delete();
    }

    func generate_and(self, n: mir_binary*) {
        var i1_name = str::from("i1");
        var temp_0 = self->ssa_gen.create();
        var temp_0_value = value_t::variable(temp_0.__ptr__());
        var temp_0_real = str::from("_");
        temp_0_real.append_str(temp_0.__ptr__())->append_i8_vec(".real");
        self->block->add_move_register(sir_alloca::new(
            temp_0_real.__ptr__(),
            i1_name.__ptr__()
        ));
        self->block->add_stmt(sir_temp_ptr::new(
            temp_0.__ptr__(),
            temp_0_real.__ptr__(),
            i1_name.__ptr__(),
            ""
        ) => sir*);

        self->visit(n->left => mir*);
        var left = self->value_stack.back()->copy_instance();
        var left_value = left.to_value_t();
        self->value_stack.pop_back();
        self->block->add_stmt(sir_store::new(
            i1_name.__ptr__(),
            left_value.__ptr__(),
            temp_0_value.__ptr__()
        ) => sir*);

        var true_label_index = self->block->stmts.size + 1;
        var br = sir_br_cond::new(
            left_value.__ptr__(),
            true_label_index,
            0
        );
        self->block->add_stmt(br => sir*);
        self->block->add_stmt(sir_label::new(true_label_index, "and.true") => sir*);

        self->visit(n->right => mir*);
        var right = self->value_stack.back()->copy_instance();
        var right_value = right.to_value_t();
        self->value_stack.pop_back();
        self->block->add_stmt(sir_store::new(
            i1_name.__ptr__(),
            right_value.__ptr__(),
            temp_0_value.__ptr__()
        ) => sir*);

        var next_label_index = self->block->stmts.size + 1;
        self->block->add_stmt(sir_br::new(next_label_index) => sir*);

        var false_label_index = self->block->stmts.size;
        br->label_false = false_label_index;
        self->block->add_stmt(sir_label::new(next_label_index, "and.false") => sir*);

        var temp_1 = self->ssa_gen.create();
        var temp_1_value = value_t::variable(temp_1.__ptr__());
        self->block->add_stmt(sir_load::new(
            i1_name.__ptr__(),
            temp_0_value.__ptr__(),
            temp_1_value.__ptr__()
        ) => sir*);

        var v = mir_value_t::variable(temp_1.__ptr__(), n->resolved_type.__ptr__());
        self->value_stack.push(v.__ptr__());

        i1_name.delete();
        temp_0.delete();
        temp_0_value.delete();
        temp_0_real.delete();
        left.delete();
        left_value.delete();
        right.delete();
        right_value.delete();
        temp_1.delete();
        temp_1_value.delete();
        v.delete();
    }

    func generate_or(self, n: mir_binary*) {
        var i1_name = str::from("i1");
        var temp_0 = self->ssa_gen.create();
        var temp_0_value = value_t::variable(temp_0.__ptr__());
        var temp_0_real = str::from("_");
        temp_0_real.append_str(temp_0.__ptr__())->append_i8_vec(".real");
        self->block->add_move_register(sir_alloca::new(
            temp_0_real.__ptr__(),
            i1_name.__ptr__()
        ));
        self->block->add_stmt(sir_temp_ptr::new(
            temp_0.__ptr__(),
            temp_0_real.__ptr__(),
            i1_name.__ptr__(),
            ""
        ) => sir*);

        self->visit(n->left => mir*);
        var left = self->value_stack.back()->copy_instance();
        var left_value = left.to_value_t();
        self->value_stack.pop_back();
        self->block->add_stmt(sir_store::new(
            i1_name.__ptr__(),
            left_value.__ptr__(),
            temp_0_value.__ptr__()
        ) => sir*);

        var false_label_index = self->block->stmts.size + 1;
        var br = sir_br_cond::new(
            left_value.__ptr__(),
            0,
            false_label_index
        );
        self->block->add_stmt(br => sir*);
        self->block->add_stmt(sir_label::new(false_label_index, "or.false") => sir*);

        self->visit(n->right => mir*);
        var right = self->value_stack.back()->copy_instance();
        var right_value = right.to_value_t();
        self->value_stack.pop_back();
        self->block->add_stmt(sir_store::new(
            i1_name.__ptr__(),
            right_value.__ptr__(),
            temp_0_value.__ptr__()
        ) => sir*);

        var next_label_index = self->block->stmts.size + 1;
        self->block->add_stmt(sir_br::new(next_label_index) => sir*);

        var true_label_index = self->block->stmts.size;
        br->label_true = true_label_index;
        self->block->add_stmt(sir_label::new(next_label_index, "or.true") => sir*);

        var temp_1 = self->ssa_gen.create();
        var temp_1_value = value_t::variable(temp_1.__ptr__());
        self->block->add_stmt(sir_load::new(
            i1_name.__ptr__(),
            temp_0_value.__ptr__(),
            temp_1_value.__ptr__()
        ) => sir*);

        var v = mir_value_t::variable(temp_1.__ptr__(), n->resolved_type.__ptr__());
        self->value_stack.push(v.__ptr__());

        i1_name.delete();
        temp_0.delete();
        temp_0_value.delete();
        temp_0_real.delete();
        left.delete();
        left_value.delete();
        right.delete();
        right_value.delete();
        temp_1.delete();
        temp_1_value.delete();
        v.delete();
    }

    func visit_mir_binary(self, n: mir_binary*) {
        if (n->op == mir_binary_opr::cmpand) {
            self->generate_and(n);
            return;
        } else if (n->op == mir_binary_opr::cmpor) {
            self->generate_or(n);
            return;
        }

        self->visit(n->left => mir*);
        var left = self->value_stack.back()->copy_instance();
        var left_value = left.to_value_t();
        var left_ty = self->type_mapping(left.resolved_type.__ptr__());
        self->value_stack.pop_back();

        self->visit(n->right => mir*);
        var right = self->value_stack.back()->copy_instance();
        var right_value = right.to_value_t();
        self->value_stack.pop_back();

        var temp_var = self->ssa_gen.create();
        var temp_var_value = value_t::variable(temp_var.__ptr__());

        var flag_is_integer = left.resolved_type.is_integer() ||
                              left.resolved_type.is_pointer() ||
                              left.resolved_type.is_bool() ||
                              left_ty.eq_const("i64");

        match (n->op) {
            mir_binary_opr::add => {
                self->block->add_stmt(sir_add::new(
                    left_value.__ptr__(),
                    right_value.__ptr__(),
                    temp_var_value.__ptr__(),
                    left.resolved_type.is_integer(),
                    left_ty.__ptr__()
                ) => sir*);
            }
            mir_binary_opr::sub => {
                self->block->add_stmt(sir_sub::new(
                    left_value.__ptr__(),
                    right_value.__ptr__(),
                    temp_var_value.__ptr__(),
                    left.resolved_type.is_integer(),
                    left_ty.__ptr__()
                ) => sir*);
            }
            mir_binary_opr::mul => {
                self->block->add_stmt(sir_mul::new(
                    left_value.__ptr__(),
                    right_value.__ptr__(),
                    temp_var_value.__ptr__(),
                    left.resolved_type.is_integer(),
                    left_ty.__ptr__()
                ) => sir*);
            }
            mir_binary_opr::div => {
                self->block->add_stmt(sir_div::new(
                    left_value.__ptr__(),
                    right_value.__ptr__(),
                    temp_var_value.__ptr__(),
                    left.resolved_type.is_integer(),
                    !left.resolved_type.is_unsigned(),
                    left_ty.__ptr__()
                ) => sir*);
            }
            mir_binary_opr::rem => {
                self->block->add_stmt(sir_rem::new(
                    left_value.__ptr__(),
                    right_value.__ptr__(),
                    temp_var_value.__ptr__(),
                    left.resolved_type.is_integer(),
                    !left.resolved_type.is_unsigned(),
                    left_ty.__ptr__()
                ) => sir*);
            }
            mir_binary_opr::band => {
                self->block->add_stmt(sir_band::new(
                    left_value.__ptr__(),
                    right_value.__ptr__(),
                    temp_var_value.__ptr__(),
                    left_ty.__ptr__()
                ) => sir*);
            }
            mir_binary_opr::bxor => {
                self->block->add_stmt(sir_bxor::new(
                    left_value.__ptr__(),
                    right_value.__ptr__(),
                    temp_var_value.__ptr__(),
                    left_ty.__ptr__()
                ) => sir*);
            }
            mir_binary_opr::bor => {
                self->block->add_stmt(sir_bor::new(
                    left_value.__ptr__(),
                    right_value.__ptr__(),
                    temp_var_value.__ptr__(),
                    left_ty.__ptr__()
                ) => sir*);
            }
            mir_binary_opr::cmpeq => {
                self->block->add_stmt(sir_cmp::new(
                    sir_cmp_kind::cmp_eq,
                    left_value.__ptr__(),
                    right_value.__ptr__(),
                    temp_var_value.__ptr__(),
                    flag_is_integer,
                    !left.resolved_type.is_unsigned(),
                    left_ty.__ptr__()
                ) => sir*);
            }
            mir_binary_opr::cmpne => {
                self->block->add_stmt(sir_cmp::new(
                    sir_cmp_kind::cmp_neq,
                    left_value.__ptr__(),
                    right_value.__ptr__(),
                    temp_var_value.__ptr__(),
                    flag_is_integer,
                    !left.resolved_type.is_unsigned(),
                    left_ty.__ptr__()
                ) => sir*);
            }
            mir_binary_opr::grt => {
                self->block->add_stmt(sir_cmp::new(
                    sir_cmp_kind::cmp_gt,
                    left_value.__ptr__(),
                    right_value.__ptr__(),
                    temp_var_value.__ptr__(),
                    left.resolved_type.is_integer(),
                    !left.resolved_type.is_unsigned(),
                    left_ty.__ptr__()
                ) => sir*);
            }
            mir_binary_opr::geq => {
                self->block->add_stmt(sir_cmp::new(
                    sir_cmp_kind::cmp_ge,
                    left_value.__ptr__(),
                    right_value.__ptr__(),
                    temp_var_value.__ptr__(),
                    left.resolved_type.is_integer(),
                    !left.resolved_type.is_unsigned(),
                    left_ty.__ptr__()
                ) => sir*);
            }
            mir_binary_opr::less => {
                self->block->add_stmt(sir_cmp::new(
                    sir_cmp_kind::cmp_lt,
                    left_value.__ptr__(),
                    right_value.__ptr__(),
                    temp_var_value.__ptr__(),
                    left.resolved_type.is_integer(),
                    !left.resolved_type.is_unsigned(),
                    left_ty.__ptr__()
                ) => sir*);
            }
            mir_binary_opr::leq => {
                self->block->add_stmt(sir_cmp::new(
                    sir_cmp_kind::cmp_le,
                    left_value.__ptr__(),
                    right_value.__ptr__(),
                    temp_var_value.__ptr__(),
                    left.resolved_type.is_integer(),
                    !left.resolved_type.is_unsigned(),
                    left_ty.__ptr__()
                ) => sir*);
            }
            _ => {}
        }

        var v = mir_value_t::variable(temp_var.__ptr__(), n->resolved_type.__ptr__());
        self->value_stack.push(v.__ptr__());

        left.delete();
        left_value.delete();
        left_ty.delete();
        right.delete();
        right_value.delete();
        temp_var.delete();
        temp_var_value.delete();
        v.delete();
    }

    func visit_mir_type_convert(self, n: mir_type_convert*) {
        self->visit(n->source => mir*);

        var source = self->value_stack.back()->copy_instance();
        self->value_stack.pop_back();

        var temp_var = self->ssa_gen.create();

        var source_value = source.to_value_t();
        var temp_var_value = value_t::variable(temp_var.__ptr__());
        var source_ty = self->type_mapping(source.resolved_type.__ptr__());
        var n_ty = self->type_mapping(n->target.__ptr__());

        self->block->add_stmt(sir_type_convert::new(
            source_value.__ptr__(),
            temp_var_value.__ptr__(),
            source_ty.__ptr__(),
            n_ty.__ptr__()
        ) => sir*);

        var v = mir_value_t::variable(
            temp_var.__ptr__(),
            n->target.__ptr__()
        );
        self->value_stack.push(v.__ptr__());

        source.delete();
        temp_var.delete();
        source_value.delete();
        temp_var_value.delete();
        source_ty.delete();
        n_ty.delete();
        v.delete();
    }

    func visit_mir_nil(self, n: mir_nil*) {
        var v = mir_value_t::nil_value(n->resolved_type.__ptr__());
        self->value_stack.push(v.__ptr__());
        v.delete();
    }

    func visit_mir_number(self, n: mir_number*) {
        var literal = n->value.copy_instance();
        if (!n->resolved_type.is_integer() &&
            !literal.contains('.')) {
            literal.append_i8_vec(".0");
        }
        var v = mir_value_t::literal(literal.__ptr__(), n->resolved_type.__ptr__());
        self->value_stack.push(v.__ptr__());
        v.delete();
        literal.delete();
    }

    func visit_mir_string(self, n: mir_string*) {
        var temp = self->ssa_gen.create();
        var v = value_t::variable(temp.__ptr__());
        if (!self->sctx->const_strings.has(n->value.__ptr__())) {
            var index = basic<u64>::wrap(self->sctx->const_strings.size);
            self->sctx->const_strings.insert(n->value.__ptr__(), index.__ptr__());
        }
        self->block->add_stmt(sir_str::new(
            self->sctx->const_strings.get(n->value.__ptr__())->unwrap(),
            n->value.size + 1,
            v.__ptr__()
        ) => sir*);

        var sv = mir_value_t::variable(temp.__ptr__(), n->resolved_type.__ptr__());
        self->value_stack.push(sv.__ptr__());

        temp.delete();
        v.delete();
        sv.delete();
    }

    func visit_mir_char(self, n: mir_char*) {
        var ch = str::from_i64(n->value.get(0) => i64);
        var v = mir_value_t::literal(ch.__ptr__(), n->resolved_type.__ptr__());
        self->value_stack.push(v.__ptr__());
        v.delete();
        ch.delete();
    }

    func visit_mir_bool(self, n: mir_bool*) {
        var flag = str::instance();
        if (n->value) {
            flag.append_i8_vec("1");
        } else {
            flag.append_i8_vec("0");
        }

        var v = mir_value_t::literal(flag.__ptr__(), n->resolved_type.__ptr__());
        self->value_stack.push(v.__ptr__());

        v.delete();
        flag.delete();
    }

    func visit_mir_array(self, n: mir_array*) {
        var index = self->array_ssa_gen.create();
        var temp_0 = str::from("arr.");
        var temp_1 = str::from("arr.");
        temp_0.append_str(index.__ptr__())->append_i8_vec(".ptr");
        temp_1.append_str(index.__ptr__())->append_i8_vec(".cast_ptr");

        var ref_copy = n->resolved_type.ref_copy();
        var array_elem_type = self->type_mapping(ref_copy.__ptr__());

        var ati = array_type_t::instance(
            array_elem_type.__ptr__(),
            n->size
        );
        var array_new = sir_alloca::new_array(
            temp_0.__ptr__(),
            ati.__ptr__()
        );
        self->block->add_alloca(array_new);

        var v_temp_0 = value_t::variable(temp_0.__ptr__());
        var v_temp_1 = value_t::variable(temp_1.__ptr__());
        var cv = sir_array_cast::new(
            v_temp_0.__ptr__(),
            v_temp_1.__ptr__(),
            array_elem_type.__ptr__(),
            n->size
        );
        self->block->add_stmt(cv => sir*);

        var v = mir_value_t::variable(temp_1.__ptr__(), n->resolved_type.__ptr__());
        self->value_stack.push(v.__ptr__());

        temp_0.delete();
        temp_1.delete();
        ref_copy.delete();
        array_elem_type.delete();
        ati.delete();
        v_temp_0.delete();
        v_temp_1.delete();
    }

    func visit_mir_struct_init(self, n: mir_struct_init*) {
        var temp_var = self->ssa_gen.create();
        var temp_var_real = str::from("_");
        temp_var_real.append_str(temp_var.__ptr__())->append_i8_vec(".real");
        var temp_var_value = value_t::variable(temp_var.__ptr__());
        var n_ty = self->type_mapping(n->resolved_type.__ptr__());

        self->block->add_move_register(sir_alloca::new(
            temp_var_real.__ptr__(),
            n_ty.__ptr__()
        ));
        self->block->add_stmt(sir_temp_ptr::new(
            temp_var.__ptr__(),
            temp_var_real.__ptr__(),
            n_ty.__ptr__(),
            ""
        ) => sir*);
        self->block->add_stmt(sir_zeroinitializer::new(
            temp_var_value.__ptr__(),
            n_ty.__ptr__()
        ) => sir*);

        var name_for_search = n->resolved_type.generic_name(self->pkg);
        var dm = self->ctx->global->domain.get(n->resolved_type.loc_file.__ptr__());
        var st = dm->structs.get(name_for_search.__ptr__());

        for (var i = n->fields.iter(); !i.is_end(); i = i.next()) {
            var target = self->ssa_gen.create();
            var target_value = value_t::variable(target.__ptr__());
            var index = st->field_index(i.get()->name.__ptr__());
            self->block->add_stmt(sir_get_field::new(
                target_value.__ptr__(),
                temp_var_value.__ptr__(),
                n_ty.__ptr__(),
                index
            ) => sir*);

            self->visit(i.get()->content => mir*);

            var res = self->value_stack.back()->copy_instance();
            self->value_stack.pop_back();

            var res_ty = self->type_mapping(res.resolved_type.__ptr__());
            var res_value = res.to_value_t();
            self->block->add_stmt(sir_store::new(
                res_ty.__ptr__(),
                res_value.__ptr__(),
                target_value.__ptr__()
            ) => sir*);

            target.delete();
            target_value.delete();
            res.delete();
            res_ty.delete();
            res_value.delete();
        }

        var n_ptr = n->resolved_type.pointer_copy();
        var v = mir_value_t::variable(temp_var.__ptr__(), n_ptr.__ptr__());
        self->value_stack.push(v.__ptr__());

        temp_var.delete();
        temp_var_real.delete();
        temp_var_value.delete();
        n_ty.delete();
        name_for_search.delete();
        n_ptr.delete();
        v.delete();
    }

    func call_expr_gen(self, n: mir_call*, need_address: bool) {
        self->visit(n->content => mir*);

        var source = self->value_stack.back()->copy_instance();
        // for enum member
        if (!source.resolved_type.is_pointer()) {
            source.delete();
            return;
        }
        if (source.resolved_type.is_void()) {
            source.delete();
            self->value_stack.pop_back();
            return;
        }

        if (need_address) {
            source.delete();
            return;
        }

        self->value_stack.pop_back();

        var temp_var = self->ssa_gen.create();
        var temp_var_value = value_t::variable(temp_var.__ptr__());
        var source_ref = source.resolved_type.ref_copy();
        var source_ref_ty = self->type_mapping(source_ref.__ptr__());
        var source_value = source.to_value_t();
        self->block->add_stmt(sir_load::new(
            source_ref_ty.__ptr__(),
            source_value.__ptr__(),
            temp_var_value.__ptr__()
        ) => sir*);

        var v = mir_value_t::variable(
            temp_var.__ptr__(),
            source_ref.__ptr__()
        );
        self->value_stack.push(v.__ptr__());

        temp_var.delete();
        temp_var_value.delete();
        source_ref.delete();
        source_ref_ty.delete();
        source_value.delete();
        v.delete();
    }
    
    func visit_mir_call(self, n: mir_call*) {
        self->call_expr_gen(n, false);
    }

    func visit_mir_call_id(self, n: mir_call_id*) {
        if (!n->resolved_type.is_global_sym) {
            var name = self->locals.get_local(n->name.__ptr__());
            var ty = n->resolved_type.pointer_copy();
            var v = mir_value_t::variable(name.__ptr__(), ty.__ptr__());

            self->value_stack.push(v.__ptr__());
            name.delete();
            ty.delete();
            v.delete();
            return;
        }

        var loc_file = n->resolved_type.loc_file.__ptr__();
        if (loc_file->empty()) {
            if (!self->ctx->global->primitives.has(n->name.__ptr__())) {
                panic("empty location for global symbol");
            } else {
                var v = mir_value_t::primitive(
                    n->name.__ptr__(),
                    n->resolved_type.__ptr__()
                );
                self->value_stack.push(v.__ptr__());
                v.delete();
            }
            return;
        }

        var dm = self->ctx->global->domain.get(loc_file);
        var name_for_search = n->resolved_type.generic_name(self->pkg);
        var full_path_name = n->resolved_type.full_path_name(self->pkg, false);
        if (dm->functions.has(name_for_search.__ptr__())) {
            var v = mir_value_t::func_symbol(
                full_path_name.__ptr__(),
                n->resolved_type.__ptr__()
            );
            // extern function remain raw name
            if (dm->functions.get(name_for_search.__ptr__())->is_extern) {
                v.content.clear();
                v.content.append_str(name_for_search.__ptr__());
            }
            self->value_stack.push(v.__ptr__());
            v.delete();
        } else if (dm->structs.has(name_for_search.__ptr__())) {
            var v = mir_value_t::struct_symbol(
                full_path_name.__ptr__(),
                n->resolved_type.__ptr__()
            );
            self->value_stack.push(v.__ptr__());
            v.delete();
        } else if (dm->enums.has(name_for_search.__ptr__())) {
            var v = mir_value_t::enum_symbol(
                name_for_search.__ptr__(),
                n->resolved_type.__ptr__()
            );
            self->value_stack.push(v.__ptr__());
            v.delete();
        } else {
            var info = str::from("cannot get global symbol ");
            info.append_str(name_for_search.__ptr__())
                ->append_i8_vec(" from ")
                ->append_str(loc_file);
            panic(info.c_str);
            info.delete();
        }
        name_for_search.delete();
        full_path_name.delete();
    }

    func visit_mir_call_index(self, n: mir_call_index*) {
        var prev = self->value_stack.back()->copy_instance();
        self->value_stack.pop_back();

        self->visit(n->index => mir*);
        var index = self->value_stack.back()->copy_instance();
        self->value_stack.pop_back();

        var temp_var = self->ssa_gen.create();
        var prev_ref = prev.resolved_type.ref_copy();
        var prev_ref_ty = self->type_mapping(prev_ref.__ptr__());
        var prev_value = prev.to_value_t();
        var temp_var_value = value_t::variable(temp_var.__ptr__());
        self->block->add_stmt(sir_load::new(
            prev_ref_ty.__ptr__(),
            prev_value.__ptr__(),
            temp_var_value.__ptr__()
        ) => sir*);

        var target = self->ssa_gen.create();
        var target_value = value_t::variable(target.__ptr__());
        var index_value = index.to_value_t();
        var prev_ref_ref = prev_ref.ref_copy();
        var prev_ref_ref_ty = self->type_mapping(prev_ref_ref.__ptr__());
        var index_ty = self->type_mapping(index.resolved_type.__ptr__());
        self->block->add_stmt(sir_get_index::new(
            temp_var_value.__ptr__(),
            target_value.__ptr__(),
            index_value.__ptr__(),
            prev_ref_ref_ty.__ptr__(),
            index_ty.__ptr__()
        ) => sir*);

        var n_ptr = n->resolved_type.pointer_copy();
        var v = mir_value_t::variable(
            target.__ptr__(),
            n_ptr.__ptr__()
        );
        self->value_stack.push(v.__ptr__());

        prev.delete();
        index.delete();
        temp_var.delete();
        prev_ref.delete();
        prev_ref_ty.delete();
        prev_value.delete();
        temp_var_value.delete();
        target.delete();
        target_value.delete();
        index_value.delete();
        prev_ref_ref.delete();
        prev_ref_ref_ty.delete();
        index_ty.delete();
        n_ptr.delete();
        v.delete();
    }

    func visit_mir_call_func(self, n: mir_call_func*) {
        var prev = self->value_stack.back()->copy_instance();
        self->value_stack.pop_back();

        // if is primitive size method call, replace with number literal
        if (self->primitive_methods.has(prev.content.__ptr__())) {
            var size = self->primitive_methods.get(prev.content.__ptr__());
            var v = mir_value_t::literal(size, n->resolved_type.__ptr__());
            self->value_stack.push(v.__ptr__());

            prev.delete();
            v.delete();
            return;
        }

        var args = vec<mir_value_t>::instance();
        // load "self" argument
        if (prev.value_kind == mir_value_kind::method) {
            args.push(self->value_stack.back());
            self->value_stack.pop_back();
        }

        for (var i = n->args->content.iter(); !i.is_end(); i = i.next()) {
            self->visit(i.get().unwrap());
            args.push(self->value_stack.back());
            self->value_stack.pop_back();
        }

        var target = str::instance();
        var sir_function_call: sir_call* = nil;
        if (!n->resolved_type.is_void()) {
            var temp = self->ssa_gen.create();
            target.append_str(temp.__ptr__());

            var n_ty = self->type_mapping(n->resolved_type.__ptr__());
            var target_value = value_t::variable(target.__ptr__());
            var mangled_name = mangle_function_name(prev.content.__ptr__());
            
            sir_function_call = sir_call::new(
                mangled_name.__ptr__(),
                n_ty.__ptr__(),
                target_value.__ptr__()
            );

            temp.delete();
            n_ty.delete();
            target_value.delete();
            mangled_name.delete();
        } else {
            var n_ty = self->type_mapping(n->resolved_type.__ptr__());
            var target_value = value_t::null(nil);
            var mangled_name = mangle_function_name(prev.content.__ptr__());

            sir_function_call = sir_call::new(
                mangled_name.__ptr__(),
                n_ty.__ptr__(),
                target_value.__ptr__()
            );

            n_ty.delete();
            target_value.delete();
            mangled_name.delete();
        }

        // load args
        for (var i = args.iter(); !i.is_end(); i = i.next()) {
            var arg = i.get();
            var arg_val = arg->to_value_t();
            var arg_ty = self->type_mapping(arg->resolved_type.__ptr__());
            sir_function_call->add_arg(arg_val.__ptr__(), arg_ty.__ptr__());
            arg_val.delete();
            arg_ty.delete();
        }
        self->block->add_stmt(sir_function_call => sir*);

        if (n->resolved_type.is_void()) {
            var v = mir_value_t::variable(
                target.__ptr__(),
                n->resolved_type.__ptr__()
            );
            self->value_stack.push(v.__ptr__());
            v.delete();
        } else {
            var temp_var = self->ssa_gen.create();
            var real = str::from("_");
            real.append_str(temp_var.__ptr__())->append_i8_vec(".real");
            var n_ty = self->type_mapping(n->resolved_type.__ptr__());
            var target_value = value_t::variable(target.__ptr__());
            var temp_var_value = value_t::variable(temp_var.__ptr__());
            
            self->block->add_move_register(sir_alloca::new(
                real.__ptr__(),
                n_ty.__ptr__()
            ));
            self->block->add_stmt(sir_temp_ptr::new(
                temp_var.__ptr__(),
                real.__ptr__(),
                n_ty.__ptr__(),
                ""
            ) => sir*);
            self->block->add_stmt(sir_store::new(
                n_ty.__ptr__(),
                target_value.__ptr__(),
                temp_var_value.__ptr__()
            ) => sir*);

            var n_ref = n->resolved_type.pointer_copy();
            var v = mir_value_t::variable(temp_var.__ptr__(), n_ref.__ptr__());
            self->value_stack.push(v.__ptr__());

            temp_var.delete();
            real.delete();
            n_ty.delete();
            target_value.delete();
            temp_var_value.delete();
            n_ref.delete();
            v.delete();
        }

        prev.delete();
        args.delete();
    }

    func visit_mir_get_field(self, n: mir_get_field*) {
        var prev = self->value_stack.back()->copy_instance();
        var prev_name_for_search = prev.resolved_type.generic_name(self->pkg);
        self->value_stack.pop_back();

        var dm = self->ctx->global->domain.get(prev.resolved_type.loc_file.__ptr__());
        var st = dm->structs.get(prev_name_for_search.__ptr__());

        // get method
        if (st->method.has(n->name.__ptr__())) {
            // push self into stack
            self->value_stack.push(prev.__ptr__());
            var method_name = prev.resolved_type.full_path_name(self->pkg, false);
            method_name.append_char('.')->append_str(n->name.__ptr__());

            var v = mir_value_t::method(
                method_name.__ptr__(),
                n->resolved_type.__ptr__()
            );
            self->value_stack.push(v.__ptr__());

            prev.delete();
            prev_name_for_search.delete();
            method_name.delete();
            v.delete();
            return;
        }

        var target = self->ssa_gen.create();
        var target_value = value_t::variable(target.__ptr__());
        var index = st->field_index(n->name.__ptr__());

        var prev_value = prev.to_value_t();
        var prev_ref = prev.resolved_type.ref_copy();
        var prev_ref_ty = self->type_mapping(prev_ref.__ptr__());
        self->block->add_stmt(sir_get_field::new(
            target_value.__ptr__(),
            prev_value.__ptr__(),
            prev_ref_ty.__ptr__(),
            index
        ) => sir*);

        var n_ty = n->resolved_type.pointer_copy();
        var v = mir_value_t::variable(target.__ptr__(), n_ty.__ptr__());

        self->value_stack.push(v.__ptr__());

        prev.delete();
        prev_name_for_search.delete();
        target.delete();
        target_value.delete();
        prev_value.delete();
        prev_ref.delete();
        prev_ref_ty.delete();
        n_ty.delete();
        v.delete();
    }

    func visit_mir_ptr_get_field(self, n: mir_ptr_get_field*) {
        var prev = self->value_stack.back()->copy_instance();
        var prev_name_for_search = prev.resolved_type.generic_name(self->pkg);
        self->value_stack.pop_back();

        var dm = self->ctx->global->domain.get(prev.resolved_type.loc_file.__ptr__());
        var st = dm->structs.get(prev_name_for_search.__ptr__());

        // get method
        if (st->method.has(n->name.__ptr__())) {
            var temp_var = self->ssa_gen.create();
            var temp_var_value = value_t::variable(temp_var.__ptr__());
            var prev_ref = prev.resolved_type.ref_copy();
            var prev_ref_ty = self->type_mapping(prev_ref.__ptr__());
            var prev_value = prev.to_value_t();
            self->block->add_stmt(sir_load::new(
                prev_ref_ty.__ptr__(),
                prev_value.__ptr__(),
                temp_var_value.__ptr__()
            ) => sir*);

            // push self into stack
            var v_self = mir_value_t::variable(temp_var.__ptr__(), prev_ref.__ptr__());
            self->value_stack.push(v_self.__ptr__());

            var method_name = prev.resolved_type.full_path_name(self->pkg, false);
            method_name.append_char('.')->append_str(n->name.__ptr__());

            var v = mir_value_t::method(
                method_name.__ptr__(),
                n->resolved_type.__ptr__()
            );
            self->value_stack.push(v.__ptr__());

            prev.delete();
            prev_name_for_search.delete();
            temp_var.delete();
            temp_var_value.delete();
            prev_ref.delete();
            prev_ref_ty.delete();
            prev_value.delete();
            v_self.delete();
            method_name.delete();
            v.delete();
            return;
        }

        var index = st->field_index(n->name.__ptr__());
        var temp_0 = self->ssa_gen.create();
        var temp_1 = self->ssa_gen.create();
        var temp_0_value = value_t::variable(temp_0.__ptr__());
        var temp_1_value = value_t::variable(temp_1.__ptr__());

        var prev_value = prev.to_value_t();
        var prev_ref = prev.resolved_type.ref_copy();
        var prev_ref_ty = self->type_mapping(prev_ref.__ptr__());
        var prev_ref_ref = prev_ref.ref_copy();
        var prev_ref_ref_ty = self->type_mapping(prev_ref_ref.__ptr__());

        self->block->add_stmt(sir_load::new(
            prev_ref_ty.__ptr__(),
            prev_value.__ptr__(),
            temp_0_value.__ptr__()
        ) => sir*);

        self->block->add_stmt(sir_get_field::new(
            temp_1_value.__ptr__(),
            temp_0_value.__ptr__(),
            prev_ref_ref_ty.__ptr__(),
            index
        ) => sir*);

        var n_ty = n->resolved_type.pointer_copy();
        var v = mir_value_t::variable(temp_1.__ptr__(), n_ty.__ptr__());

        self->value_stack.push(v.__ptr__());

        prev.delete();
        prev_name_for_search.delete();
        temp_0.delete();
        temp_0_value.delete();
        temp_1.delete();
        temp_1_value.delete();
        prev_value.delete();
        prev_ref.delete();
        prev_ref_ty.delete();
        prev_ref_ref.delete();
        prev_ref_ref_ty.delete();
        n_ty.delete();
        v.delete();
    }

    func visit_mir_get_path(self, n: mir_get_path*) {
        var prev = self->value_stack.back()->copy_instance();
        self->value_stack.pop_back();

        match (prev.value_kind) {
            mir_value_kind::primitive => {
                var name = prev.resolved_type.full_path_name(self->pkg, false);
                name.append_i8_vec(".")->append_str(n->name.__ptr__());

                var v = mir_value_t::func_symbol(
                    name.__ptr__(),
                    n->resolved_type.__ptr__()
                );
                self->value_stack.push(v.__ptr__());
                name.delete();
                v.delete();
            }
            mir_value_kind::struct_symbol => {
                var name = prev.resolved_type.full_path_name(self->pkg, false);
                name.append_i8_vec(".")->append_str(n->name.__ptr__());

                var v = mir_value_t::func_symbol(
                    name.__ptr__(),
                    n->resolved_type.__ptr__()
                );
                self->value_stack.push(v.__ptr__());
                name.delete();
                v.delete();
            }
            mir_value_kind::enum_symbol => {
                var dm = self->ctx->global->domain.get(prev.resolved_type.loc_file.__ptr__());
                var em = dm->enums.get(prev.resolved_type.name.__ptr__());
                var index = em->members.get(n->name.__ptr__())->unwrap();
                var index_str = str::from_i64(index);
                var v = mir_value_t::literal(
                    index_str.__ptr__(),
                    n->resolved_type.__ptr__()
                );
                self->value_stack.push(v.__ptr__());

                index_str.delete();
                v.delete();
            }
            _ => { unreachable(); }
        }
    }

    func visit_mir_define(self, n: mir_define*) {
        var name = n->name.copy_instance();
        name.append_i8_vec(".");
        name.append_i64(self->locals.local_scope_depth);

        // real name of the local variable
        self->locals.elem.back()->insert(n->name.__ptr__(), name.__ptr__());
        var type_name = self->type_mapping(n->resolved_type.__ptr__());
        self->block->add_alloca(sir_alloca::new(
            name.__ptr__(),
            type_name.__ptr__()
        ));

        self->visit(n->init_value => mir*);

        var source = self->value_stack.back()->copy_instance();
        self->value_stack.pop_back();
        var source_value = source.to_value_t();
        var name_value = value_t::variable(name.__ptr__());

        self->block->add_stmt(sir_store::new(
            type_name.__ptr__(),
            source_value.__ptr__(),
            name_value.__ptr__()
        ) => sir*);

        name.delete();
        type_name.delete();
        source.delete();
        source_value.delete();
        name_value.delete();
    }

    func visit_mir_assign(self, n: mir_assign*) {
        self->call_expr_gen(
            n->left->content.get(0).unwrap() => mir_call*,
            true
        );
        var left = self->value_stack.back()->copy_instance();
        var left_value = left.to_value_t();
        self->value_stack.pop_back();

        self->visit(n->right => mir*);
        var right = self->value_stack.back()->copy_instance();
        var right_value = right.to_value_t();
        var right_ty = self->type_mapping(right.resolved_type.__ptr__());
        self->value_stack.pop_back();

        match (n->opr) {
            mir_assign_opr::addeq => {
                var temp_0 = self->ssa_gen.create();
                var temp_1 = self->ssa_gen.create();
                var temp_0_value = value_t::variable(temp_0.__ptr__());
                var temp_1_value = value_t::variable(temp_1.__ptr__());
                self->block->add_stmt(sir_load::new(
                    right_ty.__ptr__(),
                    left_value.__ptr__(),
                    temp_0_value.__ptr__()
                ) => sir*);
                self->block->add_stmt(sir_add::new(
                    temp_0_value.__ptr__(),
                    right_value.__ptr__(),
                    temp_1_value.__ptr__(),
                    right.resolved_type.is_integer(),
                    right_ty.__ptr__()
                ) => sir*);
                self->block->add_stmt(sir_store::new(
                    right_ty.__ptr__(),
                    temp_1_value.__ptr__(),
                    left_value.__ptr__()
                ) => sir*);
                temp_0.delete();
                temp_1.delete();
                temp_0_value.delete();
                temp_1_value.delete();
            }
            mir_assign_opr::subeq => {
                var temp_0 = self->ssa_gen.create();
                var temp_1 = self->ssa_gen.create();
                var temp_0_value = value_t::variable(temp_0.__ptr__());
                var temp_1_value = value_t::variable(temp_1.__ptr__());
                self->block->add_stmt(sir_load::new(
                    right_ty.__ptr__(),
                    left_value.__ptr__(),
                    temp_0_value.__ptr__()
                ) => sir*);
                self->block->add_stmt(sir_sub::new(
                    temp_0_value.__ptr__(),
                    right_value.__ptr__(),
                    temp_1_value.__ptr__(),
                    right.resolved_type.is_integer(),
                    right_ty.__ptr__()
                ) => sir*);
                self->block->add_stmt(sir_store::new(
                    right_ty.__ptr__(),
                    temp_1_value.__ptr__(),
                    left_value.__ptr__()
                ) => sir*);
                temp_0.delete();
                temp_1.delete();
                temp_0_value.delete();
                temp_1_value.delete();
            }
            mir_assign_opr::muleq => {
                var temp_0 = self->ssa_gen.create();
                var temp_1 = self->ssa_gen.create();
                var temp_0_value = value_t::variable(temp_0.__ptr__());
                var temp_1_value = value_t::variable(temp_1.__ptr__());
                self->block->add_stmt(sir_load::new(
                    right_ty.__ptr__(),
                    left_value.__ptr__(),
                    temp_0_value.__ptr__()
                ) => sir*);
                self->block->add_stmt(sir_mul::new(
                    temp_0_value.__ptr__(),
                    right_value.__ptr__(),
                    temp_1_value.__ptr__(),
                    right.resolved_type.is_integer(),
                    right_ty.__ptr__()
                ) => sir*);
                self->block->add_stmt(sir_store::new(
                    right_ty.__ptr__(),
                    temp_1_value.__ptr__(),
                    left_value.__ptr__()
                ) => sir*);
                temp_0.delete();
                temp_1.delete();
                temp_0_value.delete();
                temp_1_value.delete();
            }
            mir_assign_opr::diveq => {
                var temp_0 = self->ssa_gen.create();
                var temp_1 = self->ssa_gen.create();
                var temp_0_value = value_t::variable(temp_0.__ptr__());
                var temp_1_value = value_t::variable(temp_1.__ptr__());
                self->block->add_stmt(sir_load::new(
                    right_ty.__ptr__(),
                    left_value.__ptr__(),
                    temp_0_value.__ptr__()
                ) => sir*);
                self->block->add_stmt(sir_div::new(
                    temp_0_value.__ptr__(),
                    right_value.__ptr__(),
                    temp_1_value.__ptr__(),
                    right.resolved_type.is_integer(),
                    !right.resolved_type.is_unsigned(),
                    right_ty.__ptr__()
                ) => sir*);
                self->block->add_stmt(sir_store::new(
                    right_ty.__ptr__(),
                    temp_1_value.__ptr__(),
                    left_value.__ptr__()
                ) => sir*);
                temp_0.delete();
                temp_1.delete();
                temp_0_value.delete();
                temp_1_value.delete();
            }
            mir_assign_opr::remeq => {
                var temp_0 = self->ssa_gen.create();
                var temp_1 = self->ssa_gen.create();
                var temp_0_value = value_t::variable(temp_0.__ptr__());
                var temp_1_value = value_t::variable(temp_1.__ptr__());
                self->block->add_stmt(sir_load::new(
                    right_ty.__ptr__(),
                    left_value.__ptr__(),
                    temp_0_value.__ptr__()
                ) => sir*);
                self->block->add_stmt(sir_rem::new(
                    temp_0_value.__ptr__(),
                    right_value.__ptr__(),
                    temp_1_value.__ptr__(),
                    right.resolved_type.is_integer(),
                    !right.resolved_type.is_unsigned(),
                    right_ty.__ptr__()
                ) => sir*);
                self->block->add_stmt(sir_store::new(
                    right_ty.__ptr__(),
                    temp_1_value.__ptr__(),
                    left_value.__ptr__()
                ) => sir*);
                temp_0.delete();
                temp_1.delete();
                temp_0_value.delete();
                temp_1_value.delete();
            }
            mir_assign_opr::eq => {
                self->block->add_stmt(sir_store::new(
                    right_ty.__ptr__(),
                    right_value.__ptr__(),
                    left_value.__ptr__()
                ) => sir*);
            }
            mir_assign_opr::andeq => {
                var temp_0 = self->ssa_gen.create();
                var temp_1 = self->ssa_gen.create();
                var temp_0_value = value_t::variable(temp_0.__ptr__());
                var temp_1_value = value_t::variable(temp_1.__ptr__());
                self->block->add_stmt(sir_load::new(
                    right_ty.__ptr__(),
                    left_value.__ptr__(),
                    temp_0_value.__ptr__()
                ) => sir*);
                self->block->add_stmt(sir_band::new(
                    temp_0_value.__ptr__(),
                    right_value.__ptr__(),
                    temp_1_value.__ptr__(),
                    right_ty.__ptr__()
                ) => sir*);
                self->block->add_stmt(sir_store::new(
                    right_ty.__ptr__(),
                    temp_1_value.__ptr__(),
                    left_value.__ptr__()
                ) => sir*);
                temp_0.delete();
                temp_1.delete();
                temp_0_value.delete();
                temp_1_value.delete();
            }
            mir_assign_opr::xoreq => {
                var temp_0 = self->ssa_gen.create();
                var temp_1 = self->ssa_gen.create();
                var temp_0_value = value_t::variable(temp_0.__ptr__());
                var temp_1_value = value_t::variable(temp_1.__ptr__());
                self->block->add_stmt(sir_load::new(
                    right_ty.__ptr__(),
                    left_value.__ptr__(),
                    temp_0_value.__ptr__()
                ) => sir*);
                self->block->add_stmt(sir_bxor::new(
                    temp_0_value.__ptr__(),
                    right_value.__ptr__(),
                    temp_1_value.__ptr__(),
                    right_ty.__ptr__()
                ) => sir*);
                self->block->add_stmt(sir_store::new(
                    right_ty.__ptr__(),
                    temp_1_value.__ptr__(),
                    left_value.__ptr__()
                ) => sir*);
                temp_0.delete();
                temp_1.delete();
                temp_0_value.delete();
                temp_1_value.delete();
            }
            mir_assign_opr::oreq => {
                var temp_0 = self->ssa_gen.create();
                var temp_1 = self->ssa_gen.create();
                var temp_0_value = value_t::variable(temp_0.__ptr__());
                var temp_1_value = value_t::variable(temp_1.__ptr__());
                self->block->add_stmt(sir_load::new(
                    right_ty.__ptr__(),
                    left_value.__ptr__(),
                    temp_0_value.__ptr__()
                ) => sir*);
                self->block->add_stmt(sir_bor::new(
                    temp_0_value.__ptr__(),
                    right_value.__ptr__(),
                    temp_1_value.__ptr__(),
                    right_ty.__ptr__()
                ) => sir*);
                self->block->add_stmt(sir_store::new(
                    right_ty.__ptr__(),
                    temp_1_value.__ptr__(),
                    left_value.__ptr__()
                ) => sir*);
                temp_0.delete();
                temp_1.delete();
                temp_0_value.delete();
                temp_1_value.delete();
            }
        }

        left.delete();
        left_value.delete();
        right.delete();
        right_value.delete();
        right_ty.delete();
    }

    func visit_mir_if(self, n: mir_if*) {
        var br_cond: sir_br_cond* = nil;

        if (n->condition != nil) {
            self->visit(n->condition => mir*);

            var cond = self->value_stack.back()->copy_instance();
            self->value_stack.pop_back();
            var cond_value = cond.to_value_t();

            br_cond = sir_br_cond::new(
                cond_value.__ptr__(),
                self->block->stmts.size + 1,
                0
            );
            self->block->add_stmt(br_cond => sir*);
            self->block->add_stmt(sir_label::new(self->block->stmts.size, "cond.true") => sir*);

            cond.delete();
            cond_value.delete();
        }
        
        self->visit(n->content => mir*);

        // for block ends with ret instruction, another basic block is needed
        // because ret instruction is the terminator instruction
        if (self->block->back_is_ret_stmt()) {
            self->block->add_stmt(sir_label::new(self->block->stmts.size, "block.end.ret") => sir*);
        }

        var jump_out = sir_br::new(0);
        self->block->add_stmt(jump_out => sir*);
        self->branch_jump_out.back()->push(ptr<sir_br>::wrap(jump_out).__ptr__());

        if (br_cond != nil) {
            br_cond->label_false = self->block->stmts.size;
            self->block->add_stmt(sir_label::new(self->block->stmts.size, "cond.false") => sir*);
        }
    }

    func visit_mir_branch(self, n: mir_branch*) {
        var new_table = vec<ptr<sir_br>>::instance();
        self->branch_jump_out.push(new_table.__ptr__());
        new_table.delete();

        for (var i = n->branch.iter(); !i.is_end(); i = i.next()) {
            self->visit(i.get().unwrap() => mir*);
            if (i.get().unwrap()->condition != nil && i.index() == n->branch.size - 1) {
                self->block->add_stmt(sir_br::new(self->block->stmts.size + 1) => sir*);
            }
        }

        // set jump out
        for (var i = self->branch_jump_out.back()->iter(); !i.is_end(); i = i.next()) {
            i.get()->unwrap()->label = self->block->stmts.size;
        }
        self->branch_jump_out.pop_back();

        self->block->add_stmt(sir_label::new(self->block->stmts.size, "branch.end") => sir*);
    }

    func visit_mir_switch_case(self, n: mir_switch_case*) {
        self->visit(n->content => mir*);
    }

    func visit_mir_switch(self, n: mir_switch*) {
        self->visit(n->condition => mir*);
        var value = self->value_stack.back()->copy_instance();
        self->value_stack.pop_back();
        var value_val = value.to_value_t();

        var switch_inst = sir_switch::new(value_val.__ptr__());
        self->block->add_stmt(switch_inst => sir*);

        var jmp_exits = vec<ptr<sir_br>>::instance();

        for (var i = n->cases.iter(); !i.is_end(); i = i.next()) {
            var case_label_index = self->block->stmts.size;
            var label_comment = str::from("switch.case ");
            label_comment.append_i64(i.get().unwrap()->value);

            var label = sir_label::new(
                case_label_index,
                label_comment.c_str
            );
            label_comment.delete();

            self->block->add_stmt(label => sir*);
            switch_inst->add_case(i.get().unwrap()->value, case_label_index);

            self->visit(i.get().unwrap()->content => mir*);

            // if block ends with ret instruction, do not generate
            // switch jump exit instruction
            if (self->block->back_is_ret_stmt()) {
                continue;
            }

            var jmp_exit = sir_br::new(0);
            self->block->add_stmt(jmp_exit => sir*);
            jmp_exits.push(ptr<sir_br>::wrap(jmp_exit).__ptr__());
        }

        var default_label_index = self->block->stmts.size;
        var label = sir_label::new(default_label_index, "switch.default");
        self->block->add_stmt(label => sir*);
        switch_inst->default_label = default_label_index;

        if (n->default_case != nil) {
            self->visit(n->default_case => mir*);

            // if block ends with ret instruction, do not generate
            // switch jump exit instruction
            if (!self->block->back_is_ret_stmt()) {
                var jmp_exit = sir_br::new(0);
                self->block->add_stmt(jmp_exit => sir*);
                jmp_exits.push(ptr<sir_br>::wrap(jmp_exit).__ptr__());
            }

            var exit_label_index = self->block->stmts.size;
            self->block->add_stmt(sir_label::new(
                exit_label_index,
                "switch.end"
            ) => sir*);

            for (var i = jmp_exits.iter(); !i.is_end(); i = i.next()) {
                i.get()->unwrap()->label = exit_label_index;
            }
        } else {
            for (var i = jmp_exits.iter(); !i.is_end(); i = i.next()) {
                i.get()->unwrap()->label = default_label_index;
            }
        }

        value.delete();
        value_val.delete();
        jmp_exits.delete();
    }

    func visit_mir_break(self, n: mir_break*) {
        var break_br = sir_br::new(0);
        var ptr_break = ptr<sir_br>::wrap(break_br);
        self->break_inst.back()->push(ptr_break.__ptr__());

        self->block->add_stmt(break_br => sir*);
        self->block->add_stmt(sir_label::new(
            self->block->stmts.size,
            "break.end"
        ) => sir*);
    }

    func visit_mir_continue(self, n: mir_continue*) {
        var continue_br = sir_br::new(0);
        var ptr_continue = ptr<sir_br>::wrap(continue_br);
        self->continue_inst.back()->push(ptr_continue.__ptr__());

        self->block->add_stmt(continue_br => sir*);
        self->block->add_stmt(sir_label::new(
            self->block->stmts.size,
            "continue.end"
        ) => sir*);
    }

    func visit_mir_loop(self, n: mir_loop*) {
        var new_break_continue_table = vec<ptr<sir_br>>::instance();
        self->continue_inst.push(new_break_continue_table.__ptr__());
        self->break_inst.push(new_break_continue_table.__ptr__());
        new_break_continue_table.delete();

        // mir loop will generate llvm ir in this form:
        //
        // %loop.entry:
        //   ... ; condition
        //   br i1 %cond %loop.cond.true, %loop.exit
        // %loop.cond.true:
        //   ... ; content
        // br %loop.continue
        // %loop.continue:   ; continue jumps here
        //   ... ; update
        // br %loop.entry
        // %loop.exit:       ; break jumps here
        //
        var entry_label_index = self->block->stmts.size + 1;
        self->block->add_stmt(sir_br::new(entry_label_index) => sir*);
        self->block->add_stmt(sir_label::new(entry_label_index, "loop.entry") => sir*);

        self->visit(n->condition => mir*);
        var cond = self->value_stack.back()->copy_instance();
        self->value_stack.pop_back();
        var cond_value = cond.to_value_t();

        var cond_inst = sir_br_cond::new(
            cond_value.__ptr__(),
            self->block->stmts.size + 1,
            0
        );
        self->block->add_stmt(cond_inst => sir*);
        self->block->add_stmt(sir_label::new(
            self->block->stmts.size,
            "loop.cond.true"
        ) => sir*);

        self->visit(n->content => mir*);

        var continue_label_value = self->block->stmts.size + 1;
        self->block->add_stmt(sir_br::new(continue_label_value) => sir*);
        self->block->add_stmt(sir_label::new(continue_label_value, "loop.continue") => sir*);
        for (var i = self->continue_inst.back()->iter(); !i.is_end(); i = i.next()) {
            i.get()->unwrap()->label = continue_label_value;
        }

        if (n->update != nil) {
            self->visit(n->update => mir*);
        }

        self->block->add_stmt(sir_br::new(entry_label_index) => sir*);

        var exit_label_index = self->block->stmts.size;
        cond_inst->label_false = exit_label_index;
        self->block->add_stmt(sir_label::new(exit_label_index, "loop.exit") => sir*);
        for (var i = self->break_inst.back()->iter(); !i.is_end(); i = i.next()) {
            i.get()->unwrap()->label = exit_label_index;
        }

        cond.delete();
        cond_value.delete();
        self->continue_inst.pop_back();
        self->break_inst.pop_back();
    }

    func visit_mir_return(self, n: mir_return*) {
        if (n->value->content.empty()) {
            var void_name = str::from("void");
            var null_val = value_t::null(nil);
            self->block->add_stmt(sir_ret::new(
                void_name.__ptr__(),
                null_val.__ptr__()
            ) => sir*);
            void_name.delete();
            null_val.delete();
            return;
        }

        self->visit(n->value => mir*);
        var ret = self->value_stack.back()->copy_instance();
        self->value_stack.pop_back();

        var ret_ty = self->type_mapping(ret.resolved_type.__ptr__());
        var ret_val = ret.to_value_t();
        self->block->add_stmt(sir_ret::new(
            ret_ty.__ptr__(),
            ret_val.__ptr__()
        ) => sir*);

        ret.delete();
        ret_ty.delete();
        ret_val.delete();
    }

    func visit(self, n: mir*) {
        match (n->kind) {
            mir_kind::mir_block => {
                self->visit_mir_block(n => mir_block*);
            }
            mir_kind::mir_unary => {
                self->visit_mir_unary(n => mir_unary*);
            }
            mir_kind::mir_binary => {
                self->visit_mir_binary(n => mir_binary*);
            }
            mir_kind::mir_type_convert => {
                self->visit_mir_type_convert(n => mir_type_convert*);
            }
            mir_kind::mir_nil => {
                self->visit_mir_nil(n => mir_nil*);
            }
            mir_kind::mir_number => {
                self->visit_mir_number(n => mir_number*);
            }
            mir_kind::mir_string => {
                self->visit_mir_string(n => mir_string*);
            }
            mir_kind::mir_char => {
                self->visit_mir_char(n => mir_char*);
            }
            mir_kind::mir_bool => {
                self->visit_mir_bool(n => mir_bool*);
            }
            mir_kind::mir_array => {
                self->visit_mir_array(n => mir_array*);
            }
            mir_kind::mir_struct_init => {
                self->visit_mir_struct_init(n => mir_struct_init*);
            }
            mir_kind::mir_call => {
                self->visit_mir_call(n => mir_call*);
            }
            mir_kind::mir_call_id => {
                self->visit_mir_call_id(n => mir_call_id*);
            }
            mir_kind::mir_call_index => {
                self->visit_mir_call_index(n => mir_call_index*);
            }
            mir_kind::mir_call_func => {
                self->visit_mir_call_func(n => mir_call_func*);
            }
            mir_kind::mir_get_field => {
                self->visit_mir_get_field(n => mir_get_field*);
            }
            mir_kind::mir_ptr_get_field => {
                self->visit_mir_ptr_get_field(n => mir_ptr_get_field*);
            }
            mir_kind::mir_get_path => {
                self->visit_mir_get_path(n => mir_get_path*);
            }
            mir_kind::mir_define => {
                self->visit_mir_define(n => mir_define*);
            }
            mir_kind::mir_assign => {
                self->visit_mir_assign(n => mir_assign*);
            }
            mir_kind::mir_if => {
                self->visit_mir_if(n => mir_if*);
            }
            mir_kind::mir_branch => {
                self->visit_mir_branch(n => mir_branch*);
            }
            mir_kind::mir_switch_case => {
                self->visit_mir_switch_case(n => mir_switch_case*);
            }
            mir_kind::mir_switch => {
                self->visit_mir_switch(n => mir_switch*);
            }
            mir_kind::mir_break => {
                self->visit_mir_break(n => mir_break*);
            }
            mir_kind::mir_continue => {
                self->visit_mir_continue(n => mir_continue*);
            }
            mir_kind::mir_loop => {
                self->visit_mir_loop(n => mir_loop*);
            }
            mir_kind::mir_return => {
                self->visit_mir_return(n => mir_return*);
            }
            _ => unreachable();
        }
    }
}

impl mir2sir {
    pub func generate(self, mctx: mir_context*) {
        self->generate_type_mapper();
        self->emit_struct(mctx);
        self->emit_func_decl(mctx);
        self->emit_func_impl(mctx);
        adjust_va_arg(self->sctx);
        replace_struct_ptr_call(self->sctx);
    }
}