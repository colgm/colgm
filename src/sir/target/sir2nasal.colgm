use sir::context::*;

use std::io::{ io };
use std::vec::{ vec };
use std::str::{ str };

pub struct sir2nasal {
    ctx: sir_context*
}

impl sir2nasal {
    pub func instance(ctx: sir_context*) -> sir2nasal {
        return sir2nasal { ctx: ctx };
    }
}

impl sir2nasal {
    func dump_raw_nasal_string(self, out: io, s: str*) {
        var tmp = str::instance();
        defer tmp.delete();

        for (var i: u64 = 0; i < s->size; i += 1) {
            var c = s->c_str[i];
            if (c == '\"') {
                tmp.append("\\\"");
            } elsif (c == '\\') {
                tmp.append("\\\\");
            } elsif (c == '\n') {
                tmp.append("\\n");
            } elsif (c == '\r') {
                tmp.append("\\r");
            } elsif (c == '\t') {
                tmp.append("\\t");
            } elsif (c == '\e') {
                tmp.append("\\e");
            } else {
                tmp.append_char(c);
            }
        }

        out.out(tmp.c_str);
    }

    func dump_const_strings(self, out: io) {
        if (self->ctx->const_strings.empty()) {
            return;
        }

        // convert map to vec
        var ordered_const_string = vec<str>::instance();
        defer ordered_const_string.delete();
        foreach (var i; self->ctx->const_strings) {
            var temp = str::instance();
            defer temp.delete();

            ordered_const_string.push(temp.__ptr__());
        }
        foreach (var i; self->ctx->const_strings) {
            ordered_const_string.get(i.value())->append_str(i.key());
        }

        out.out("var colgm_S = [\n");
        foreach (var i; ordered_const_string) {
            out.out("  \"");
            self->dump_raw_nasal_string(out, i.get());
            out.out("\"");
            if (i.index() < ordered_const_string.size - 1) {
                out.out(",");
            }
            out.out("\n");
        }
        out.out("];\n");

        if (!ordered_const_string.empty()) {
            out.out("\n");
        }
    }

    func dump_tagged_unions(self, out: io) {
        foreach (var i; self->ctx->tagged_union_decls) {
            out.out("colgm_T[\"");
            self->dump_raw_nasal_string(out, i.get()->name.__ptr__());
            out.out("\"] = func { return { tag: 0, value: nil }; }\n");
        }

        if (self->ctx->tagged_union_decls.size > 0) {
            out.out("\n");
        }
    }

    func dump_structs(self, out: io) {
        foreach (var i; self->ctx->struct_decls) {
            out.out("colgm_T[\"");
            self->dump_raw_nasal_string(out, i.get()->name.__ptr__());
            out.out("\"] = ");
            if (i.get()->field_type.empty()) {
                out.out("func { return {}; }\n");
                continue;
            }
            out.out("func { return {");
            foreach (var j; i.get()->field_type) {
                out.out(" e").out_u64(j.index()).out(": nil");
                if (j.index() < i.get()->field_type.size - 1) {
                    out.out(",");
                }
            }
            out.out(" }; }\n");
        }

        if (self->ctx->struct_decls.size > 0) {
            out.out("\n");
        }
    }

    func dump_func_decls(self, out: io) {
        foreach (var i; self->ctx->func_decls) {
            out.out("colgm_F[\"");
            self->dump_raw_nasal_string(out, i.get()->name.__ptr__());
            out.out("\"] = nil;\n");
        }

        if (self->ctx->func_decls.size > 0) {
            out.out("\n");
        }
    }

    func dump_func_impls(self, out: io) {
        foreach (var i; self->ctx->func_impls) {
            out.out("colgm_F[\"");
            self->dump_raw_nasal_string(out, i.get()->name.__ptr__());
            out.out("\"] = func {}\n\n");
        }
    }

    pub func dump(self, filename: const i8*) {
        var out = io::fileout(filename);
        defer out.close();

        out.out("# generated by colgm\n");
        out.out("var colgm_T = {};\n");
        self->dump_tagged_unions(out);
        self->dump_structs(out);
        self->dump_const_strings(out);

        out.out("var colgm_F = {};\n");
        self->dump_func_decls(out);
        self->dump_func_impls(out);
    }
}