use sir::sir::*;
use sir::value::{ value_t };
use sir::context::{ sir_func, sir_struct, sir_tagged_union, sir_context };
use sir::value::{ value_kind };
use sir::pass::replacer::{ replacer };

use std::vec::{ vec };
use std::str::{ str };
use std::map::{ hashmap };
use std::io::{ io };
use std::libc::{ free };

use util::timestamp::{ maketimestamp };

func adjust_single_function_size_call(
    bb: sir_basic_block*,
    struct_size_map: hashmap<str, sir_struct*>&,
    union_size_map: hashmap<str, sir_tagged_union*>&
) -> i64 {
    var replace_count = 0;

    foreach (var i; bb->stmts) {
        var inst = i.get();
        if (inst->kind != sir_kind::sir_call) {
            continue;
        }

        var call = inst => sir_call*;
        if (!call->name.endswith(".__size__") &&
            !call->name.endswith(".__size__\"")) {
            continue;
        }

        var size: u64 = 0;
        if (struct_size_map.has(call->name)) {
            size = struct_size_map.get(call->name)->size;
        } else if (union_size_map.has(call->name)) {
            size = union_size_map.get(call->name)->size;
        } else {
            continue;
        }

        var size_str = str::from_u64(size);
        var zero_str = str::from("0");
        defer size_str.delete();
        defer zero_str.delete();

        var left = value_t::literal(size_str);
        var right = value_t::literal(zero_str);
        defer left.delete();
        defer right.delete();

        replace_count += 1;
        // replace
        //   %1 = call i64 @T.__size__()
        // to
        //   %1 = add i64 [size], i64 0
        var constant = sir_add::new(
            left,
            right,
            call->target,
            call->return_type,
            call->debug_info_index,
            call->name.c_str
        );
        bb->stmts.set(i.index(), constant => sir*);

        // replaced old instruction could be freed
        inst->delete();
        free(inst => i8*);
    }

    return replace_count;
}

pub func replace_size_call(ctx: sir_context*, verbose: bool) {
    var ts = maketimestamp();
    ts.stamp();

    var struct_size_map = hashmap<str, sir_struct*>::instance();
    var union_size_map = hashmap<str, sir_tagged_union*>::instance();
    defer struct_size_map.delete();
    defer union_size_map.delete();

    foreach (var i; ctx->struct_decls) {
        var size_func_name = i.get().get_intrinsic_method_name("__size__");
        defer size_func_name.delete();

        struct_size_map.insert(size_func_name, i.get().__ptr__());
    }
    foreach (var i; ctx->tagged_union_decls) {
        var size_func_name = i.get().get_intrinsic_method_name("__size__");
        defer size_func_name.delete();

        union_size_map.insert(size_func_name, i.get().__ptr__());
    }

    var replace_count = 0;
    foreach (var i; ctx->func_impls) {
        foreach (var j; i.get().body->basic_block) {
            replace_count += adjust_single_function_size_call(
                j.get(),
                struct_size_map,
                union_size_map
            );
        }
    }

    if (verbose) {
        io::stdout().green().out("  SIR-PASS ").reset();
        io::stdout().out("Run pass");
        io::stdout().blue().out(" <replace __size__ call>").reset().out(": ");
        io::stdout().cyan().out_i64(replace_count).reset();
        io::stdout().out(" ").out_f64(ts.elapsed_msec()).out(" ms\n");
    }
}

func adjust_single_function_ptr_call(bb: sir_basic_block*,
                                     prc: replacer&) -> i64 {
    var replace_count = 0;
    var tmp = vec<sir*>::instance();
    defer tmp.delete();

    foreach (var i; bb->stmts) {
        var inst = i.get();
        if (inst->kind != sir_kind::sir_call) {
            tmp.push(inst);
            continue;
        }

        var call = inst => sir_call*;
        if (!call->name.endswith(".__ptr__") &&
            !call->name.endswith(".__ptr__\"")) {
            tmp.push(inst);
            continue;
        }

        // __ptr__ call has one argument, and must return pointer type
        // __ptr__(self: T*) -> T*
        if (call->args.size != 1 ||
            call->return_type.empty() ||
            call->return_type.back() != '*') {
            tmp.push(inst);
            continue;
        }

        replace_count += 1;
        prc.name_map.insert(call->target.content, call->args.get(0).content);

        // replaced old instruction could be freed
        inst->delete();
        free(inst => i8*);
    }

    bb->stmts.swap(tmp);

    return replace_count;
}

pub func replace_ptr_call(ctx: sir_context*, verbose: bool) {
    var ts = maketimestamp();
    ts.stamp();

    var prc = replacer::instance();
    defer prc.delete();

    var replace_count = 0;
    foreach (var i; ctx->func_impls) {
        prc.clear();
        foreach (var j; i.get().body->basic_block) {
            replace_count += adjust_single_function_ptr_call(j.get(), prc);
        }
        foreach (var j; i.get().body->basic_block) {
            foreach (var k; j.get()->stmts) {
                prc.accept(k.get());
            }
        }
    }

    if (verbose) {
        io::stdout().green().out("  SIR-PASS ").reset();
        io::stdout().out("Run pass");
        io::stdout().blue().out(" <replace __ptr__ call>").reset().out(": ");
        io::stdout().cyan().out_i64(replace_count).reset();
        io::stdout().out(" ").out_f64(ts.elapsed_msec()).out(" ms\n");
    }
}