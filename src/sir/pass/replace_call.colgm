use sir::sir::*;
use sir::value::{ value_t };
use sir::context::{ sir_func, sir_struct, sir_tagged_union, sir_context };
use sir::value::{ value_kind };

use std::vec::{ vec };
use std::str::{ str };
use std::map::{ hashmap };
use std::io::{ io };
use std::libc::{ free };

use util::timestamp::{ maketimestamp };

func adjust_single_function_size_call(
    bb: sir_basic_block*,
    struct_size_map: hashmap<str, sir_struct*>&,
    union_size_map: hashmap<str, sir_tagged_union*>&
) -> i64 {
    var replace_count = 0;

    foreach (var i; bb->stmts) {
        var inst = i.get();
        if (inst->kind != sir_kind::sir_call) {
            continue;
        }

        var call = inst => sir_call*;
        if (!call->name.endswith(".__size__") &&
            !call->name.endswith(".__size__\"")) {
            continue;
        }

        var size: u64 = 0;
        if (struct_size_map.has(call->name)) {
            size = struct_size_map.get(call->name)->size;
        } else if (union_size_map.has(call->name)) {
            size = union_size_map.get(call->name)->size;
        } else {
            continue;
        }

        var size_str = str::from_u64(size);
        var zero_str = str::from("0");
        defer size_str.delete();
        defer zero_str.delete();

        var left = value_t::literal(size_str);
        var right = value_t::literal(zero_str);
        defer left.delete();
        defer right.delete();

        replace_count += 1;
        // replace
        //   %1 = call i64 @T.__size__()
        // to
        //   %1 = add i64 [size], i64 0
        var constant = sir_add::new(
            left,
            right,
            call->target,
            call->return_type,
            call->debug_info_index,
            call->name.c_str
        );
        bb->stmts.set(i.index(), constant => sir*);

        // replaced old instruction could be freed
        inst->delete();
        free(inst => i8*);
    }

    return replace_count;
}

pub func replace_size_call(ctx: sir_context*, verbose: bool) {
    var ts = maketimestamp();
    ts.stamp();

    var struct_size_map = hashmap<str, sir_struct*>::instance();
    var union_size_map = hashmap<str, sir_tagged_union*>::instance();
    defer struct_size_map.delete();
    defer union_size_map.delete();

    foreach (var i; ctx->struct_decls) {
        var size_func_name = i.get().get_intrinsic_method_name("__size__");
        defer size_func_name.delete();

        struct_size_map.insert(size_func_name, i.get().__ptr__());
    }
    foreach (var i; ctx->tagged_union_decls) {
        var size_func_name = i.get().get_intrinsic_method_name("__size__");
        defer size_func_name.delete();

        union_size_map.insert(size_func_name, i.get().__ptr__());
    }

    var replace_count = 0;
    foreach (var i; ctx->func_impls) {
        foreach (var j; i.get().body->basic_block) {
            replace_count += adjust_single_function_size_call(
                j.get(),
                struct_size_map,
                union_size_map
            );
        }
    }

    if (verbose) {
        io::stdout().green().out("  SIR-PASS ").reset();
        io::stdout().out("Run SIR pass");
        io::stdout().blue().out(" <replace __size__ call>").reset().out(": ");
        io::stdout().cyan().out_i64(replace_count).reset();
        io::stdout().out(" ").out_f64(ts.elapsed_msec()).out(" ms\n");
    }
}

struct ptr_replace_context {
    name_map: hashmap<str, str>
}

impl ptr_replace_context {
    pub func instance() -> ptr_replace_context {
        return ptr_replace_context {
            name_map: hashmap<str, str>::instance()
        };
    }

    pub func delete(self) {
        self.name_map.delete();
    }

    pub func clear(self) {
        self.name_map.clear();
    }

    pub func rename(self, name: value_t&) {
        if (name.kind != value_kind::variable) {
            return;
        }

        if (self.name_map.has(name.content)) {
            var new_name = self.name_map.get(name.content);
            name.content.delete();
            name.content = new_name.clone();
        }
    }

    pub func accept(self, stmt: sir*) {
        match (stmt->kind) {
            sir_kind::sir_null => {}
            sir_kind::sir_block => {}
            sir_kind::sir_alloca => {
                var n = stmt => sir_alloca*;
                self.rename(n->name);
            }
            sir_kind::sir_ret => {
                var n = stmt => sir_ret*;
                self.rename(n->value);
            }
            sir_kind::sir_str => {
                var n = stmt => sir_str*;
                self.rename(n->target);
            }
            sir_kind::sir_zeroinitializer => {
                var n = stmt => sir_zeroinitializer*;
                self.rename(n->target);
            }
            sir_kind::sir_get_index => {
                var n = stmt => sir_get_index*;
                self.rename(n->source);
                self.rename(n->index);
                self.rename(n->target);
            }
            sir_kind::sir_get_field => {
                var n = stmt => sir_get_field*;
                self.rename(n->source);
                self.rename(n->target);
            }
            sir_kind::sir_call => {
                var n = stmt => sir_call*;
                foreach (var i; n->args) {
                    self.rename(i.get());
                }
                self.rename(n->target);
            }
            sir_kind::sir_neg => {
                var n = stmt => sir_neg*;
                self.rename(n->source);
                self.rename(n->target);
            }
            sir_kind::sir_bnot => {
                var n = stmt => sir_bnot*;
                self.rename(n->source);
                self.rename(n->target);
            }
            sir_kind::sir_lnot => {
                var n = stmt => sir_lnot*;
                self.rename(n->source);
                self.rename(n->target);
            }
            sir_kind::sir_add => {
                var n = stmt => sir_add*;
                self.rename(n->left);
                self.rename(n->right);
                self.rename(n->target);
            }
            sir_kind::sir_fadd => {
                var n = stmt => sir_fadd*;
                self.rename(n->left);
                self.rename(n->right);
                self.rename(n->target);
            }
            sir_kind::sir_sub => {
                var n = stmt => sir_sub*;
                self.rename(n->left);
                self.rename(n->right);
                self.rename(n->target);
            }
            sir_kind::sir_mul => {
                var n = stmt => sir_mul*;
                self.rename(n->left);
                self.rename(n->right);
                self.rename(n->target);
            }
            sir_kind::sir_div => {
                var n = stmt => sir_div*;
                self.rename(n->left);
                self.rename(n->right);
                self.rename(n->target);
            }
            sir_kind::sir_rem => {
                var n = stmt => sir_rem*;
                self.rename(n->left);
                self.rename(n->right);
                self.rename(n->target);
            }
            sir_kind::sir_band => {
                var n = stmt => sir_band*;
                self.rename(n->left);
                self.rename(n->right);
                self.rename(n->target);
            }
            sir_kind::sir_bxor => {
                var n = stmt => sir_bxor*;
                self.rename(n->left);
                self.rename(n->right);
                self.rename(n->target);
            }
            sir_kind::sir_bor => {
                var n = stmt => sir_bor*;
                self.rename(n->left);
                self.rename(n->right);
                self.rename(n->target);
            }
            sir_kind::sir_cmp => {
                var n = stmt => sir_cmp*;
                self.rename(n->left);
                self.rename(n->right);
                self.rename(n->target);
            }
            sir_kind::sir_basic_block => {}
            sir_kind::sir_store => {
                var n = stmt => sir_store*;
                self.rename(n->source);
                self.rename(n->target);
            }
            sir_kind::sir_load => {
                var n = stmt => sir_load*;
                self.rename(n->source);
                self.rename(n->target);
            }
            sir_kind::sir_br => {}
            sir_kind::sir_br_cond => {
                var n = stmt => sir_br_cond*;
                self.rename(n->cond);
            }
            sir_kind::sir_switch => {
                var n = stmt => sir_switch*;
                self.rename(n->source);
            }
            sir_kind::sir_type_convert => {
                var n = stmt => sir_type_convert*;
                self.rename(n->source);
                self.rename(n->target);
            }
            sir_kind::sir_array_cast => {
                var n = stmt => sir_array_cast*;
                self.rename(n->source);
                self.rename(n->target);
            }
        }
    }
}

func adjust_single_function_ptr_call(bb: sir_basic_block*,
                                     prc: ptr_replace_context&) -> i64 {
    var replace_count = 0;
    var tmp = vec<sir*>::instance();
    defer tmp.delete();

    foreach (var i; bb->stmts) {
        var inst = i.get();
        if (inst->kind != sir_kind::sir_call) {
            tmp.push(inst);
            continue;
        }

        var call = inst => sir_call*;
        if (!call->name.endswith(".__ptr__") &&
            !call->name.endswith(".__ptr__\"")) {
            tmp.push(inst);
            continue;
        }

        // __ptr__ call has one argument, and must return pointer type
        // __ptr__(self: T*) -> T*
        if (call->args.size != 1 ||
            call->return_type.empty() ||
            call->return_type.back() != '*') {
            tmp.push(inst);
            continue;
        }

        replace_count += 1;
        prc.name_map.insert(call->target.content, call->args.get(0).content);

        // replaced old instruction could be freed
        inst->delete();
        free(inst => i8*);
    }

    bb->stmts.swap(tmp);

    return replace_count;
}

pub func replace_ptr_call(ctx: sir_context*, verbose: bool) {
    var ts = maketimestamp();
    ts.stamp();

    var prc = ptr_replace_context::instance();
    defer prc.delete();

    var replace_count = 0;
    foreach (var i; ctx->func_impls) {
        prc.clear();
        foreach (var j; i.get().body->basic_block) {
            replace_count += adjust_single_function_ptr_call(j.get(), prc);
        }
        foreach (var j; i.get().body->basic_block) {
            foreach (var k; j.get()->stmts) {
                prc.accept(k.get());
            }
        }
    }

    if (verbose) {
        io::stdout().green().out("  SIR-PASS ").reset();
        io::stdout().out("Run SIR pass");
        io::stdout().blue().out(" <replace __ptr__ call>").reset().out(": ");
        io::stdout().cyan().out_i64(replace_count).reset();
        io::stdout().out(" ").out_f64(ts.elapsed_msec()).out(" ms\n");
    }
}