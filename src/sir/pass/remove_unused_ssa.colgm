use sir::sir::*;
use sir::context::{ sir_func, sir_context };
use sir::value::{ value_kind, value_t };

use std::str::{ str };
use std::io::{ io };
use std::vec::{ vec };
use std::set::{ hashset };
use std::map::{ hashmap };
use std::basic::{ basic };
use std::libc::{ free };

use util::timestamp::{ maketimestamp };

struct ssa_remove_context {
    defined: hashmap<str, sir*>,
    used: hashset<str>
}

impl ssa_remove_context {
    pub func instance() -> ssa_remove_context {
        return ssa_remove_context {
            defined: hashmap<str, sir*>::instance(),
            used: hashset<str>::instance()
        };
    }

    pub func delete(self) {
        self.defined.delete();
        self.used.delete();
    }

    pub func clear(self) {
        self.defined.clear();
        self.used.clear();
    }

    pub func add_param(self, name: str&) {
        self.defined.insert(name, nil);
    }

    func record_define(self, name: value_t&, n: sir*) {
        if (name.kind != value_kind::variable) {
            return;
        }

        self.defined.insert(name.content, n);
    }

    func record_use(self, name: value_t&) {
        if (name.kind != value_kind::variable) {
            return;
        }

        self.used.insert(name.content);
    }

    pub func accept(self, stmt: sir*) {
        match (stmt->kind) {
            sir_kind::sir_null => {}
            sir_kind::sir_block => {}
            sir_kind::sir_alloca => {
                var n = stmt => sir_alloca*;
                self.record_define(n->name, stmt);
            }
            sir_kind::sir_ret => {
                var n = stmt => sir_ret*;
                self.record_use(n->value);
            }
            sir_kind::sir_str => {
                var n = stmt => sir_str*;
                self.record_define(n->target, stmt);
            }
            sir_kind::sir_zeroinitializer => {
                var n = stmt => sir_zeroinitializer*;
                self.record_define(n->target, stmt);
            }
            sir_kind::sir_get_index => {
                var n = stmt => sir_get_index*;
                self.record_use(n->source);
                self.record_use(n->index);
                self.record_define(n->target, stmt);
            }
            sir_kind::sir_get_field => {
                var n = stmt => sir_get_field*;
                self.record_use(n->source);
                self.record_define(n->target, stmt);
            }
            sir_kind::sir_call => {
                var n = stmt => sir_call*;
                foreach (var i; n->args) {
                    self.record_use(i.get());
                }
                self.record_define(n->target, stmt);
            }
            sir_kind::sir_neg => {
                var n = stmt => sir_neg*;
                self.record_use(n->source);
                self.record_define(n->target, stmt);
            }
            sir_kind::sir_bnot => {
                var n = stmt => sir_bnot*;
                self.record_use(n->source);
                self.record_define(n->target, stmt);
            }
            sir_kind::sir_lnot => {
                var n = stmt => sir_lnot*;
                self.record_use(n->source);
                self.record_define(n->target, stmt);
            }
            sir_kind::sir_add => {
                var n = stmt => sir_add*;
                self.record_use(n->left);
                self.record_use(n->right);
                self.record_define(n->target, stmt);
            }
            sir_kind::sir_fadd => {
                var n = stmt => sir_fadd*;
                self.record_use(n->left);
                self.record_use(n->right);
                self.record_define(n->target, stmt);
            }
            sir_kind::sir_sub => {
                var n = stmt => sir_sub*;
                self.record_use(n->left);
                self.record_use(n->right);
                self.record_define(n->target, stmt);
            }
            sir_kind::sir_mul => {
                var n = stmt => sir_mul*;
                self.record_use(n->left);
                self.record_use(n->right);
                self.record_define(n->target, stmt);
            }
            sir_kind::sir_div => {
                var n = stmt => sir_div*;
                self.record_use(n->left);
                self.record_use(n->right);
                self.record_define(n->target, stmt);
            }
            sir_kind::sir_rem => {
                var n = stmt => sir_rem*;
                self.record_use(n->left);
                self.record_use(n->right);
                self.record_define(n->target, stmt);
            }
            sir_kind::sir_band => {
                var n = stmt => sir_band*;
                self.record_use(n->left);
                self.record_use(n->right);
                self.record_define(n->target, stmt);
            }
            sir_kind::sir_bxor => {
                var n = stmt => sir_bxor*;
                self.record_use(n->left);
                self.record_use(n->right);
                self.record_define(n->target, stmt);
            }
            sir_kind::sir_bor => {
                var n = stmt => sir_bor*;
                self.record_use(n->left);
                self.record_use(n->right);
                self.record_define(n->target, stmt);
            }
            sir_kind::sir_cmp => {
                var n = stmt => sir_cmp*;
                self.record_use(n->left);
                self.record_use(n->right);
                self.record_define(n->target, stmt);
            }
            sir_kind::sir_basic_block => {}
            sir_kind::sir_store => {
                var n = stmt => sir_store*;
                self.record_use(n->source);
                self.record_use(n->target);
            }
            sir_kind::sir_load => {
                var n = stmt => sir_load*;
                self.record_use(n->source);
                self.record_define(n->target, stmt);
            }
            sir_kind::sir_br => {}
            sir_kind::sir_br_cond => {
                var n = stmt => sir_br_cond*;
                self.record_use(n->cond);
            }
            sir_kind::sir_switch => {
                var n = stmt => sir_switch*;
                self.record_use(n->source);
            }
            sir_kind::sir_type_convert => {
                var n = stmt => sir_type_convert*;
                self.record_use(n->source);
                self.record_define(n->target, stmt);
            }
            sir_kind::sir_array_cast => {
                var n = stmt => sir_array_cast*;
                self.record_use(n->source);
                self.record_define(n->target, stmt);
            }
        }
    }
}

func deal_single_function(f: sir_func&, rc: ssa_remove_context&) -> i64 {
    foreach (var i; f.params) {
        rc.add_param(i.get().key);
    }
    foreach (var i; f.body->basic_block) {
        foreach (var j; i.get()->stmts) {
            rc.accept(j.get());
        }
    }

    var replace_count = 0;
    var to_be_removed = hashset<basic<sir*>>::instance();
    defer to_be_removed.delete();
    foreach (var i; rc.defined) {
        if (rc.used.has(i.key())) {
            continue;
        }
        // do not delete call inst, all function calls are used
        if (i.value()->kind == sir_kind::sir_call) {
            continue;
        }
        to_be_removed.insert(basic<sir*>::wrap(i.value()));
    }

    foreach (var i; f.body->basic_block) {
        var tmp = vec<sir*>::instance();
        defer tmp.delete();

        foreach (var j; i.get()->stmts) {
            if (to_be_removed.has(basic<sir*>::wrap(j.get()))) {
                j.get()->delete();
                free(j.get() => i8*);
                replace_count += 1;
                continue;
            }
            tmp.push(j.get());
        }

        i.get()->stmts.swap(tmp);
    }

    return replace_count;
}

pub func remove_unused_ssa(ctx: sir_context*, verbose: bool) {
    var ts = maketimestamp();
    ts.stamp();

    var rc = ssa_remove_context::instance();
    defer rc.delete();

    var total = 0;
    while (true) {
        var replace_count = 0;
        foreach (var i; ctx->func_impls) {
            rc.clear();
            replace_count += deal_single_function(i.get(), rc);
        }
        if (replace_count == 0) {
            break;
        }
        total += replace_count;
    }

    if (verbose) {
        io::stdout().green().out("  SIR-PASS ").reset();
        io::stdout().out("Run pass");
        io::stdout().blue().out(" <remove unused ssa>").reset().out(": ");
        io::stdout().cyan().out_i64(total).reset();
        io::stdout().out(" ").out_f64(ts.elapsed_msec()).out(" ms\n");
    }
}