use std::str::{ str };
use std::ptr::{ ptr };
use std::vec::{ primitive_vec, vec };
use std::libc::{ free };
use std::io::{ io };

use err::panic::{ unreachable };
use sir::value::{ value_t, value_kind };

pub enum sir_kind {
    sir_null,
    sir_nop,
    sir_block,
    sir_alloca,
    sir_temp_ptr,
    sir_ret,
    sir_str,
    sir_zeroinitializer,
    sir_get_index,
    sir_get_field,
    sir_call,
    sir_neg,
    sir_bnot,
    sir_lnot,
    sir_add,
    sir_sub,
    sir_mul,
    sir_div,
    sir_rem,
    sir_band,
    sir_bxor,
    sir_bor,
    sir_cmp,
    sir_label,
    sir_store,
    sir_load,
    sir_br,
    sir_br_cond,
    sir_switch,
    sir_type_convert,
    sir_array_cast
}

pub enum sir_cmp_kind {
    cmp_eq,
    cmp_neq,
    cmp_ge,
    cmp_gt,
    cmp_le,
    cmp_lt
}

pub struct sir {
    kind: sir_kind
}

impl sir {
    pub func instance(kind: sir_kind) -> sir {
        return sir { kind: kind };
    }

    pub func delete(self) {
        match (self->kind) {
            sir_kind::sir_nop => {
                var n = self => sir_nop*;
                n->delete();
            }
            sir_kind::sir_block => {
                var n = self => sir_block*;
                n->delete();
            }
            sir_kind::sir_alloca => {
                var n = self => sir_alloca*;
                n->delete();
            }
            sir_kind::sir_temp_ptr =>{
                var n = self => sir_temp_ptr*;
                n->delete();
            }
            sir_kind::sir_ret => {
                var n = self => sir_ret*;
                n->delete();
            }
            sir_kind::sir_str => {
                var n = self => sir_str*;
                n->delete();
            }
            sir_kind::sir_zeroinitializer => {
                var n = self => sir_zeroinitializer*;
                n->delete();
            }
            sir_kind::sir_get_index => {
                var n = self => sir_get_index*;
                n->delete();
            }
            sir_kind::sir_get_field => {
                var n = self => sir_get_field*;
                n->delete();
            }
            sir_kind::sir_call => {
                var n = self => sir_call*;
                n->delete();
            }
            sir_kind::sir_neg => {
                var n = self => sir_neg*;
                n->delete();
            }
            sir_kind::sir_bnot => {
                var n = self => sir_bnot*;
                n->delete();
            }
            sir_kind::sir_lnot => {
                var n = self => sir_lnot*;
                n->delete();
            }
            sir_kind::sir_add => {
                var n = self => sir_add*;
                n->delete();
            }
            sir_kind::sir_sub => {
                var n = self => sir_sub*;
                n->delete();
            }
            sir_kind::sir_mul =>{
                var n = self => sir_mul*;
                n->delete();
            }
            sir_kind::sir_div => {
                var n = self => sir_div*;
                n->delete();
            }
            sir_kind::sir_rem => {
                var n = self => sir_rem*;
                n->delete();
            }
            sir_kind::sir_band => {
                var n = self => sir_band*;
                n->delete();
            }
            sir_kind::sir_bxor => {
                var n = self => sir_bxor*;
                n->delete();
            }
            sir_kind::sir_bor => {
                var n = self => sir_bor*;
                n->delete();
            }
            sir_kind::sir_cmp => {
                var n = self => sir_cmp*;
                n->delete();
            }
            sir_kind::sir_label => {
                var n = self => sir_label*;
                n->delete();
            }
            sir_kind::sir_store => {
                var n = self => sir_store*;
                n->delete();
            }
            sir_kind::sir_load => {
                var n = self => sir_load*;
                n->delete();
            }
            sir_kind::sir_br => {
                var n = self => sir_br*;
                n->delete();
            }
            sir_kind::sir_br_cond => {
                var n = self => sir_br_cond*;
                n->delete();
            }
            sir_kind::sir_switch => {
                var n = self => sir_switch*;
                n->delete();
            }
            sir_kind::sir_type_convert => {
                var n = self => sir_type_convert*;
                n->delete();
            }
            sir_kind::sir_array_cast => {
                var n = self => sir_array_cast*;
                n->delete();
            }
            _ => { unreachable(); }
        }
    }

    pub func dump(self, out: io) {
        match (self->kind) {
            sir_kind::sir_nop => {
                out.out("  ; nop\n");
            }
            sir_kind::sir_block => {
                var n = self => sir_block*;
                n->dump(out);
            }
            sir_kind::sir_alloca => {
                var n = self => sir_alloca*;
                n->dump(out);
            }
            sir_kind::sir_ret => {
                var n = self => sir_ret*;
                n->dump(out);
            }
            sir_kind::sir_str => {
                var n = self => sir_str*;
                n->dump(out);
            }
            sir_kind::sir_get_index => {
                var n = self => sir_get_index*;
                n->dump(out);
            }
            sir_kind::sir_get_field => {
                var n = self => sir_get_field*;
                n->dump(out);
            }
            sir_kind::sir_label => {
                var n = self => sir_label*;
                n->dump(out);
            }
            sir_kind::sir_store => {
                var n = self => sir_store*;
                n->dump(out);
            }
            sir_kind::sir_load => {
                var n = self => sir_load*;
                n->dump(out);
            }
            sir_kind::sir_br => {
                var n = self => sir_br*;
                n->dump(out);
            }
            sir_kind::sir_array_cast => {
                var n = self => sir_array_cast*;
                n->dump(out);
            }
            _ => {
                out.out("  ; 0x").out_i64(self => i64).endln();
            }
        }
    }
}

pub struct sir_nop {
    base: sir,
    info: str
}

impl sir_nop {
    pub func new(info: str*) -> sir_nop* {
        var n = sir_nop::__alloc__();
        n->base = sir::instance(sir_kind::sir_nop);
        if (info != nil) {
            n->info = info->copy_instance();
        } else {
            n->info = str::instance();
        }
        return n;
    }

    pub func delete(self) {
        self->info.delete();
    }

    pub func dump(self, out: io) {
        if (!self->info.empty()) {
            out.out("; ").out(self->info.c_str);
        }
        out.out("\n");
    }
}

pub struct sir_block {
    base: sir,
    allocas: primitive_vec<ptr<sir_alloca>>,
    move_register: primitive_vec<ptr<sir_alloca>>,
    stmts: primitive_vec<ptr<sir>>
}

impl sir_block {
    pub func new() -> sir_block* {
        var n = sir_block::__alloc__();
        n->base = sir::instance(sir_kind::sir_block);
        n->allocas = primitive_vec<ptr<sir_alloca>>::instance();
        n->move_register = primitive_vec<ptr<sir_alloca>>::instance();
        n->stmts = primitive_vec<ptr<sir>>::instance();
        return n;
    }

    pub func delete(self) {
        for (var i = self->allocas.iter(); !i.is_end(); i = i.next()) {
            var n = i.get().unwrap() => sir*;
            n->delete();
            free(n => i8*);
        }
        for (var i = self->move_register.iter(); !i.is_end(); i = i.next()) {
            var n = i.get().unwrap() => sir*;
            n->delete();
            free(n => i8*);
        }
        for (var i = self->stmts.iter(); !i.is_end(); i = i.next()) {
            var n = i.get().unwrap();
            n->delete();
            free(n => i8*);
        }
        self->allocas.delete();
        self->move_register.delete();
        self->stmts.delete();
    }

    pub func add_alloca(self, s: sir_alloca*) {
        self->allocas.push(ptr<sir_alloca>::wrap(s));
    }

    pub func add_stmt(self, s: sir*) {
        self->stmts.push(ptr<sir>::wrap(s));
    }

    pub func dump(self, out: io) {
        for (var i = self->allocas.iter(); !i.is_end(); i = i.next()) {
            var n = i.get().unwrap() => sir*;
            n->dump(out);
        }
        for (var i = self->move_register.iter(); !i.is_end(); i = i.next()) {
            var n = i.get().unwrap() => sir*;
            n->dump(out);
        }
        for (var i = self->stmts.iter(); !i.is_end(); i = i.next()) {
            i.get().unwrap()->dump(out);
        }
    }
}

pub struct array_type_t {
    base_type: str,
    size: u64
}

impl array_type_t {
    pub func instance(base: str*, size: u64) -> array_type_t {
        return array_type_t {
            base_type: base->copy_instance(),
            size: size
        };
    }

    pub func default_instance() -> array_type_t {
        return array_type_t {
            base_type: str::instance(),
            size: 0
        };
    }

    pub func copy_instance(self) -> array_type_t {
        return array_type_t {
            base_type: self->base_type.copy_instance(),
            size: self->size
        };
    }

    pub func delete(self) {
        self->base_type.delete();
    }
}

pub struct sir_alloca {
    base: sir,
    variable: str,
    type: str,
    array_info: array_type_t    
}

impl sir_alloca {
    pub func new(variable: str*, type: str*) -> sir_alloca* {
        var n = sir_alloca::__alloc__();
        n->base = sir::instance(sir_kind::sir_alloca);
        n->variable = variable->copy_instance();
        n->type = type->copy_instance();
        n->array_info = array_type_t::default_instance();
        return n;
    }

    pub func new_array(variable: str*, at: array_type_t*) -> sir_alloca* {
        var n = sir_alloca::__alloc__();
        n->base = sir::instance(sir_kind::sir_alloca);
        n->variable = variable->copy_instance();
        n->type = str::instance();
        n->array_info = at->copy_instance();
        return n;
    }

    pub func delete(self) {
        self->variable.delete();
        self->type.delete();
        self->array_info.delete();
    }

    pub func dump(self, out: io) {
        out.out("  %").out(self->variable.c_str).out(" = alloca ");
        if (self->array_info.base_type.empty()) {
            out.out(self->type.c_str).endln();
        } else {
            out.out("[").out(self->array_info.base_type.c_str).out(" x ");
            out.out_i64(self->array_info.size => i64).out("]").endln();
        }
    }
}

pub struct sir_temp_ptr {
//
// used to get temporary pointer of numbering variable
//     %_1.real = alloca i32
// this operand will do this:
//     %1 = getelementptr i32, i32* %_1.real, i32 0
// and %1 is i32*
//
    base: sir,
    target: str,
    source: str,
    comment: str // for tail comment
}

impl sir_temp_ptr {
    pub func new(target: str*, source: str*, comment: str*) -> sir_temp_ptr* {
        var n = sir_temp_ptr::__alloc__();
        n->base = sir::instance(sir_kind::sir_temp_ptr);
        n->target = target->copy_instance();
        n->source = source->copy_instance();
        if (comment != nil) {
            n->comment = comment->copy_instance();
        } else {
            n->comment = str::instance();
        }
        return n;
    }

    pub func delete(self) {
        self->target.delete();
        self->source.delete();
        self->comment.delete();
    }
}

pub struct sir_ret {
    base: sir,
    type: str,
    value: value_t
}

impl sir_ret {
    pub func new(type: str*, v: value_t*) -> sir_ret* {
        var n = sir_ret::__alloc__();
        n->base = sir::instance(sir_kind::sir_ret);
        n->type = type->copy_instance();
        n->value = v->copy_instance();
        return n;
    }

    pub func delete(self) {
        self->type.delete();
        self->value.delete();
    }

    pub func dump(self, out: io) {
        out.out("  ret ").out(self->type.c_str);
        if (self->value.kind != value_kind::null) {
            out.out(" ");
            self->value.dump(out);
        }
        out.endln();
    }
}

pub struct sir_str {
    base: sir,
    index: u64,
    length: u64,
    target: value_t
}

impl sir_str {
    pub func new(index: u64, length: u64, tgt: value_t*) -> sir_str* {
        var n = sir_str::__alloc__();
        n->base = sir::instance(sir_kind::sir_str);
        n->index = index;
        n->length = length;
        n->target = tgt->copy_instance();
        return n;
    }

    pub func delete(self) {
        self->target.delete();
    }

    pub func dump(self, out: io) {
        out.out("  ");
        self->target.dump(out);
        out.out(" = bitcast [").out_i64(self->length => i64).out(" x i8]* ");
        out.out("@str.").out_i64(self->index => i64).out(" to i8*\n");
    }
}

pub struct sir_zeroinitializer {
    base: sir,
    type: str,
    target: value_t
}

impl sir_zeroinitializer {
    pub func new(type: str*) -> sir_zeroinitializer* {
        var n = sir_zeroinitializer::__alloc__();
        n->base = sir::instance(sir_kind::sir_zeroinitializer);
        n->type = type->copy_instance();
        n->target = value_t::instance();
        return n;
    }

    pub func delete(self){
        self->type.delete();
        self->target.delete();
    }
}

pub struct sir_get_index {
    base: sir,
    source: value_t,
    target: value_t,
    index: value_t,
    type: str,
    index_type: str
}

impl sir_get_index {
    pub func new(src: value_t*,
                 tgt: value_t*,
                 idx: value_t*,
                 t: str*,
                 it: str*) -> sir_get_index* {
        var n = sir_get_index::__alloc__();
        n->base = sir::instance(sir_kind::sir_get_index);
        n->source = src->copy_instance();
        n->target = tgt->copy_instance();
        n->index = idx->copy_instance();
        n->type = t->copy_instance();
        n->index_type = it->copy_instance();
        return n;
    }

    pub func delete(self) {
        self->source.delete();
        self->target.delete();
        self->index.delete();
        self->type.delete();
        self->index_type.delete();
    }

    pub func dump(self, out: io) {
        out.out("  ");
        self->target.dump(out);
        out.out(" = getelementptr ").out(self->type.c_str).out(", ");
        out.out(self->type.c_str).out("* ");
        self->source.dump(out);
        out.out(", i32 0, i32 ");
        self->index.dump(out);
        out.endln();
    }
}

pub struct sir_get_field {
    base: sir,
    source: value_t,
    target: value_t,
    struct_name: str,
    index: i64
}

impl sir_get_field {
    pub func new(tgt: value_t*, src: value_t*, sn: str*, i: i64) -> sir_get_field* {
        var n = sir_get_field::__alloc__();
        n->base = sir::instance(sir_kind::sir_get_field);
        n->target = tgt->copy_instance();
        n->source = src->copy_instance();
        n->struct_name = sn->copy_instance();
        n->index = i;
        return n;
    }

    pub func delete(self) {
        self->source.delete();
        self->target.delete();
        self->struct_name.delete();
    }

    pub func dump(self, out: io) {
        out.out("  ");
        self->target.dump(out);
        out.out(" = getelementptr inbounds ");
        out.out(self->struct_name.c_str).out(", ");
        out.out(self->struct_name.c_str).out("* ");
        self->source.dump(out);
        out.out(", i32 0, i32 ").out_i64(self->index).endln();
    }
}

pub struct sir_call {
    base: sir,
    name: str,
    return_type: str,
    target: value_t,
    args_type: vec<str>,
    args: vec<value_t>,
    with_va_args: bool,
    with_va_args_real_param_size: u64,
    debug_info_index: u64
}

impl sir_call {
    pub func new(name: str*, return_type: str*) -> sir_call* {
        var n = sir_call::__alloc__();
        n->base = sir::instance(sir_kind::sir_call);
        n->name = name->copy_instance();
        n->return_type = return_type->copy_instance();
        n->target = value_t::instance();
        n->args_type = vec<str>::instance();
        n->args = vec<value_t>::instance();
        n->with_va_args = false;
        n->with_va_args_real_param_size = 0;
        n->debug_info_index = 0;
        return n;
    }

    pub func delete(self) {
        self->name.delete();
        self->return_type.delete();
        self->target.delete();
        self->args_type.delete();
        self->args.delete();
    }
}

pub struct sir_neg {
    base: sir,
    target: value_t,
    source: value_t,
    is_integer: bool,
    type: str
}

impl sir_neg {
    pub func new(type: str*) -> sir_neg* {
        var n = sir_neg::__alloc__();
        n->base = sir::instance(sir_kind::sir_neg);
        n->target = value_t::instance();
        n->source = value_t::instance();
        n->is_integer = false;
        n->type = type->copy_instance();
        return n;
    }

    pub func delete(self) {
        self->target.delete();
        self->source.delete();
        self->type.delete();
    }
}

pub struct sir_bnot {
    base: sir,
    target: value_t,
    source: value_t,
    type: str
}

impl sir_bnot {
    pub func new(type: str*) -> sir_bnot* {
        var n = sir_bnot::__alloc__();
        n->base = sir::instance(sir_kind::sir_bnot);
        n->target = value_t::instance();
        n->source = value_t::instance();
        n->type = type->copy_instance();
        return n;
    }

    pub func delete(self) {
        self->target.delete();
        self->source.delete();
        self->type.delete();
    }
}

pub struct sir_lnot {
    base: sir,
    target: value_t,
    source: value_t,
    type: str
}

impl sir_lnot {
    pub func new(type: str*) -> sir_lnot* {
        var n = sir_lnot::__alloc__();
        n->base = sir::instance(sir_kind::sir_lnot);
        n->target = value_t::instance();
        n->source = value_t::instance();
        n->type = type->copy_instance();
        return n;
    }

    pub func delete(self) {
        self->target.delete();
        self->source.delete();
        self->type.delete();
    }
}

pub struct sir_add {
    base: sir,
    target: value_t,
    left: value_t,
    right: value_t,
    is_integer: bool,
    type: str
}

impl sir_add {
    pub func new(type: str*) -> sir_add* {
        var n = sir_add::__alloc__();
        n->base = sir::instance(sir_kind::sir_add);
        n->target = value_t::instance();
        n->left = value_t::instance();
        n->right = value_t::instance();
        n->is_integer = false;
        n->type = type->copy_instance();
        return n;
    }

    pub func delete(self) {
        self->target.delete();
        self->left.delete();
        self->right.delete();
        self->type.delete();
    }
}

pub struct sir_sub {
    base: sir,
    target: value_t,
    left: value_t,
    right: value_t,
    is_integer: bool,
    type: str
}

impl sir_sub {
    pub func new(type: str*) -> sir_sub* {
        var n = sir_sub::__alloc__();
        n->base = sir::instance(sir_kind::sir_sub);
        n->target = value_t::instance();
        n->left = value_t::instance();
        n->right = value_t::instance();
        n->is_integer = false;
        n->type = type->copy_instance();
        return n;
    }

    pub func delete(self) {
        self->target.delete();
        self->left.delete();
        self->right.delete();
        self->type.delete();
    }
}

pub struct sir_mul {
    base: sir,
    target: value_t,
    left: value_t,
    right: value_t,
    is_integer: bool,
    type: str
}

impl sir_mul {
    pub func new(type: str*) -> sir_mul* {
        var n = sir_mul::__alloc__();
        n->base = sir::instance(sir_kind::sir_mul);
        n->target = value_t::instance();
        n->left = value_t::instance();
        n->right = value_t::instance();
        n->is_integer = false;
        n->type = type->copy_instance();
        return n;
    }

    pub func delete(self) {
        self->target.delete();
        self->left.delete();
        self->right.delete();
        self->type.delete();
    }
}

pub struct sir_div {
    base: sir,
    target: value_t,
    left: value_t,
    right: value_t,
    is_integer: bool,
    is_signed: bool,
    type: str
}

impl sir_div {
    pub func new(type: str*) -> sir_div* {
        var n = sir_div::__alloc__();
        n->base = sir::instance(sir_kind::sir_div);
        n->target = value_t::instance();
        n->left = value_t::instance();
        n->right = value_t::instance();
        n->is_integer = false;
        n->is_signed = false;
        n->type = type->copy_instance();
        return n;
    }

    pub func delete(self) {
        self->target.delete();
        self->left.delete();
        self->right.delete();
        self->type.delete();
    }
}

pub struct sir_rem {
    base: sir,
    target: value_t,
    left: value_t,
    right: value_t,
    is_integer: bool,
    is_signed: bool,
    type: str
}

impl sir_rem {
    pub func new(type: str*) -> sir_rem* {
        var n = sir_rem::__alloc__();
        n->base = sir::instance(sir_kind::sir_rem);
        n->target = value_t::instance();
        n->left = value_t::instance();
        n->right = value_t::instance();
        n->is_integer = false;
        n->is_signed = false;
        n->type = type->copy_instance();
        return n;
    }

    pub func delete(self) {
        self->target.delete();
        self->left.delete();
        self->right.delete();
        self->type.delete();
    }
}

pub struct sir_band {
    base: sir,
    target: value_t,
    left: value_t,
    right: value_t,
    type: str
}

impl sir_band {
    pub func new(type: str*) -> sir_band* {
        var n = sir_band::__alloc__();
        n->base = sir::instance(sir_kind::sir_band);
        n->target = value_t::instance();
        n->left = value_t::instance();
        n->right = value_t::instance();
        n->type = type->copy_instance();
        return n;
    }

    pub func delete(self) {
        self->target.delete();
        self->left.delete();
        self->right.delete();
        self->type.delete();
    }
}

pub struct sir_bxor {
    base: sir,
    target: value_t,
    left: value_t,
    right: value_t,
    type: str
}

impl sir_bxor {
    pub func new(type: str*) -> sir_bxor* {
        var n = sir_bxor::__alloc__();
        n->base = sir::instance(sir_kind::sir_bxor);
        n->target = value_t::instance();
        n->left = value_t::instance();
        n->right = value_t::instance();
        n->type = type->copy_instance();
        return n;
    }

    pub func delete(self) {
        self->target.delete();
        self->left.delete();
        self->right.delete();
        self->type.delete();
    }
}

pub struct sir_bor {
    base: sir,
    target: value_t,
    left: value_t,
    right: value_t,
    type: str
}

impl sir_bor {
    pub func new(type: str*) -> sir_bor* {
        var n = sir_bor::__alloc__();
        n->base = sir::instance(sir_kind::sir_bor);
        n->target = value_t::instance();
        n->left = value_t::instance();
        n->right = value_t::instance();
        n->type = type->copy_instance();
        return n;
    }

    pub func delete(self) {
        self->target.delete();
        self->left.delete();
        self->right.delete();
        self->type.delete();
    }
}

pub struct sir_cmp {
    base: sir,
    target: value_t,
    left: value_t,
    right: value_t,
    kind: sir_cmp_kind,
    is_integer: bool,
    is_signed: bool,
    type: str
}

impl sir_cmp {
    pub func new(type: str*) -> sir_cmp* {
        var n = sir_cmp::__alloc__();
        n->base = sir::instance(sir_kind::sir_cmp);
        n->target = value_t::instance();
        n->left = value_t::instance();
        n->right = value_t::instance();
        n->kind = sir_cmp_kind::cmp_eq;
        n->is_integer = false;
        n->is_signed = false;
        n->type = type->copy_instance();
        return n;
    }

    pub func delete(self) {
        self->target.delete();
        self->left.delete();
        self->right.delete();
        self->type.delete();
    }
}

pub struct sir_label {
    base: sir,
    label: u64,
    comment: str
}

impl sir_label {
    pub func new(label: u64, comment: i8*) -> sir_label* {
        var n = sir_label::__alloc__();
        n->base = sir::instance(sir_kind::sir_label);
        n->label = label;
        n->comment = str::from(comment);
        return n;
    }

    pub func delete(self) {
        self->comment.delete();
    }

    pub func dump(self, out: io) {
        out.out("label.").out_hex(self->label => i64).out(":");
        if (!self->comment.empty()) {
            out.out("\t; ").out(self->comment.c_str);
        }
        out.endln();
    }
}

pub struct sir_store {
    base: sir,
    target: value_t,
    source: value_t,
    type: str
}

impl sir_store {
    pub func new(type: str*, src: value_t*, tgt: value_t*) -> sir_store* {
        var n = sir_store::__alloc__();
        n->base = sir::instance(sir_kind::sir_store);
        n->target = tgt->copy_instance();
        n->source = src->copy_instance();
        n->type = type->copy_instance();
        return n;
    }

    pub func delete(self) {
        self->target.delete();
        self->source.delete();
        self->type.delete();
    }

    pub func dump(self, out: io) {
        out.out("  store ").out(self->type.c_str).out(" ");
        self->source.dump(out);
        out.out(", ").out(self->type.c_str).out("* ");
        self->target.dump(out);
        out.endln();
    }
}

pub struct sir_load {
    base: sir,
    target: value_t,
    source: value_t,
    type: str
}

impl sir_load {
    pub func new(type: str*, src: value_t*, tgt: value_t*) -> sir_load* {
        var n = sir_load::__alloc__();
        n->base = sir::instance(sir_kind::sir_load);
        n->source = src->copy_instance();
        n->target = tgt->copy_instance();
        n->type = type->copy_instance();
        return n;
    }

    pub func delete(self) {
        self->target.delete();
        self->source.delete();
        self->type.delete();
    }

    pub func dump(self, out: io) {
        out.out("  ");
        self->target.dump(out);
        out.out(" = load ").out(self->type.c_str).out(", ");
        out.out(self->type.c_str).out("* ");
        self->source.dump(out);
        out.endln();
    }
}

pub struct sir_br {
    base: sir,
    label: u64
}

impl sir_br {
    pub func new(label: u64) -> sir_br* {
        var n = sir_br::__alloc__();
        n->base = sir::instance(sir_kind::sir_br);
        n->label = label;
        return n;
    }

    pub func delete(self) {}

    pub func dump(self, out: io) {
        out.out("  br label %label.").out_hex(self->label => i64).endln();
    }
}

pub struct sir_br_cond {
    base: sir,
    cond: value_t,
    label_true: u64,
    label_false: u64
}

impl sir_br_cond {
    pub func new(label_true: u64, label_false: u64) -> sir_br_cond* {
        var n = sir_br_cond::__alloc__();
        n->base = sir::instance(sir_kind::sir_br_cond);
        n->cond = value_t::instance();
        n->label_true = label_true;
        n->label_false = label_false;
        return n;
    }

    pub func delete(self) {
        self->cond.delete();
    }
}

pub struct sir_switch {
    base: sir,
    source: value_t,
    default_label: u64,
    case_value: primitive_vec<i64>,
    case_label: primitive_vec<u64>
}

impl sir_switch {
    pub func new(default_label: u64) -> sir_switch* {
        var n = sir_switch::__alloc__();
        n->base = sir::instance(sir_kind::sir_switch);
        n->source = value_t::instance();
        n->default_label = default_label;
        n->case_value = primitive_vec<i64>::instance();
        n->case_label = primitive_vec<u64>::instance();
        return n;
    }

    pub func delete(self) {
        self->source.delete();
        self->case_value.delete();
        self->case_label.delete();
    }
}

pub struct sir_type_convert {
    base: sir,
    target: value_t,
    source: value_t,
    src_type: str,
    dst_type: str
}

impl sir_type_convert {
    pub func new(src_type: str*, dst_type: str*) -> sir_type_convert* {
        var n = sir_type_convert::__alloc__();
        n->base = sir::instance(sir_kind::sir_type_convert);
        n->target = value_t::instance();
        n->source = value_t::instance();
        n->src_type = src_type->copy_instance();
        n->dst_type = dst_type->copy_instance();
        return n;
    }

    pub func delete(self) {
        self->target.delete();
        self->source.delete();
        self->src_type.delete();
        self->dst_type.delete();
    }
}

pub struct sir_array_cast {
    base: sir,
    target: value_t,
    source: value_t,
    type: str,
    array_size: u64
}

impl sir_array_cast {
    pub func new(src: value_t*, tgt: value_t*, type: str*, size: u64) -> sir_array_cast* {
        var n = sir_array_cast::__alloc__();
        n->base = sir::instance(sir_kind::sir_array_cast);
        n->source = src->copy_instance();
        n->target = tgt->copy_instance();
        n->type = type->copy_instance();
        n->array_size = size;
        return n;
    }

    pub func delete(self) {
        self->target.delete();
        self->source.delete();
        self->type.delete();
    }

    pub func dump(self, out: io) {
        out.out("  ");
        self->target.dump(out);
        out.out(" = bitcast [").out_i64(self->array_size => i64).out(" x ");
        out.out(self->type.c_str).out("]* ");
        self->source.dump(out);
        out.out(" to ").out(self->type.c_str).out("*\n");
    }
}