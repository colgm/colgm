use std::str::{ str };
use std::ptr::{ ptr };
use std::vec::{ primitive_vec, vec };
use std::libc::{ free };
use std::io::{ io };

use err::panic::{ unreachable };
use sir::value::{ value_t, value_kind };
use util::to_num::{ to_u64 };

use dwarf::dwarf::{ DI_ERROR_INDEX };

pub enum sir_kind {
    sir_null,
    sir_nop,
    sir_block,
    sir_alloca,
    sir_temp_ptr,
    sir_ret,
    sir_str,
    sir_zeroinitializer,
    sir_get_index,
    sir_get_field,
    sir_call,
    sir_neg,
    sir_bnot,
    sir_lnot,
    sir_add,
    sir_sub,
    sir_mul,
    sir_div,
    sir_rem,
    sir_band,
    sir_bxor,
    sir_bor,
    sir_cmp,
    sir_label,
    sir_store,
    sir_load,
    sir_br,
    sir_br_cond,
    sir_switch,
    sir_type_convert,
    sir_array_cast
}

pub enum sir_cmp_kind {
    cmp_eq,
    cmp_neq,
    cmp_ge,
    cmp_gt,
    cmp_le,
    cmp_lt
}

pub struct sir {
    kind: sir_kind
}

impl sir {
    pub func instance(kind: sir_kind) -> sir {
        return sir { kind: kind };
    }

    pub func delete(self) {
        match (self->kind) {
            sir_kind::sir_nop => {
                var n = self => sir_nop*;
                n->delete();
            }
            sir_kind::sir_block => {
                var n = self => sir_block*;
                n->delete();
            }
            sir_kind::sir_alloca => {
                var n = self => sir_alloca*;
                n->delete();
            }
            sir_kind::sir_temp_ptr => {
                var n = self => sir_temp_ptr*;
                n->delete();
            }
            sir_kind::sir_ret => {
                var n = self => sir_ret*;
                n->delete();
            }
            sir_kind::sir_str => {
                var n = self => sir_str*;
                n->delete();
            }
            sir_kind::sir_zeroinitializer => {
                var n = self => sir_zeroinitializer*;
                n->delete();
            }
            sir_kind::sir_get_index => {
                var n = self => sir_get_index*;
                n->delete();
            }
            sir_kind::sir_get_field => {
                var n = self => sir_get_field*;
                n->delete();
            }
            sir_kind::sir_call => {
                var n = self => sir_call*;
                n->delete();
            }
            sir_kind::sir_neg => {
                var n = self => sir_neg*;
                n->delete();
            }
            sir_kind::sir_bnot => {
                var n = self => sir_bnot*;
                n->delete();
            }
            sir_kind::sir_lnot => {
                var n = self => sir_lnot*;
                n->delete();
            }
            sir_kind::sir_add => {
                var n = self => sir_add*;
                n->delete();
            }
            sir_kind::sir_sub => {
                var n = self => sir_sub*;
                n->delete();
            }
            sir_kind::sir_mul => {
                var n = self => sir_mul*;
                n->delete();
            }
            sir_kind::sir_div => {
                var n = self => sir_div*;
                n->delete();
            }
            sir_kind::sir_rem => {
                var n = self => sir_rem*;
                n->delete();
            }
            sir_kind::sir_band => {
                var n = self => sir_band*;
                n->delete();
            }
            sir_kind::sir_bxor => {
                var n = self => sir_bxor*;
                n->delete();
            }
            sir_kind::sir_bor => {
                var n = self => sir_bor*;
                n->delete();
            }
            sir_kind::sir_cmp => {
                var n = self => sir_cmp*;
                n->delete();
            }
            sir_kind::sir_label => {
                var n = self => sir_label*;
                n->delete();
            }
            sir_kind::sir_store => {
                var n = self => sir_store*;
                n->delete();
            }
            sir_kind::sir_load => {
                var n = self => sir_load*;
                n->delete();
            }
            sir_kind::sir_br => {
                var n = self => sir_br*;
                n->delete();
            }
            sir_kind::sir_br_cond => {
                var n = self => sir_br_cond*;
                n->delete();
            }
            sir_kind::sir_switch => {
                var n = self => sir_switch*;
                n->delete();
            }
            sir_kind::sir_type_convert => {
                var n = self => sir_type_convert*;
                n->delete();
            }
            sir_kind::sir_array_cast => {
                var n = self => sir_array_cast*;
                n->delete();
            }
            _ => unreachable();
        }
    }

    pub func dump(self, out: io) {
        match (self->kind) {
            sir_kind::sir_nop => {
                out.out("  ; nop\n");
            }
            sir_kind::sir_block => {
                var n = self => sir_block*;
                n->dump(out);
            }
            sir_kind::sir_alloca => {
                var n = self => sir_alloca*;
                n->dump(out);
            }
            sir_kind::sir_temp_ptr => {
                var n = self => sir_temp_ptr*;
                n->dump(out);
            }
            sir_kind::sir_ret => {
                var n = self => sir_ret*;
                n->dump(out);
            }
            sir_kind::sir_str => {
                var n = self => sir_str*;
                n->dump(out);
            }
            sir_kind::sir_zeroinitializer => {
                var n = self => sir_zeroinitializer*;
                n->dump(out);
            }
            sir_kind::sir_get_index => {
                var n = self => sir_get_index*;
                n->dump(out);
            }
            sir_kind::sir_get_field => {
                var n = self => sir_get_field*;
                n->dump(out);
            }
            sir_kind::sir_call => {
                var n = self => sir_call*;
                n->dump(out);
            }
            sir_kind::sir_neg => {
                var n = self => sir_neg*;
                n->dump(out);
            }
            sir_kind::sir_bnot => {
                var n = self => sir_bnot*;
                n->dump(out);
            }
            sir_kind::sir_lnot => {
                var n = self => sir_lnot*;
                n->dump(out);
            }
            sir_kind::sir_add => {
                var n = self => sir_add*;
                n->dump(out);
            }
            sir_kind::sir_sub => {
                var n = self => sir_sub*;
                n->dump(out);
            }
            sir_kind::sir_mul => {
                var n = self => sir_mul*;
                n->dump(out);
            }
            sir_kind::sir_div => {
                var n = self => sir_div*;
                n->dump(out);
            }
            sir_kind::sir_rem => {
                var n = self => sir_rem*;
                n->dump(out);
            }
            sir_kind::sir_band => {
                var n = self => sir_band*;
                n->dump(out);
            }
            sir_kind::sir_bxor => {
                var n = self => sir_bxor*;
                n->dump(out);
            }
            sir_kind::sir_bor => {
                var n = self => sir_bor*;
                n->dump(out);
            }
            sir_kind::sir_cmp => {
                var n = self => sir_cmp*;
                n->dump(out);
            }
            sir_kind::sir_label => {
                var n = self => sir_label*;
                n->dump(out);
            }
            sir_kind::sir_store => {
                var n = self => sir_store*;
                n->dump(out);
            }
            sir_kind::sir_load => {
                var n = self => sir_load*;
                n->dump(out);
            }
            sir_kind::sir_br => {
                var n = self => sir_br*;
                n->dump(out);
            }
            sir_kind::sir_br_cond => {
                var n = self => sir_br_cond*;
                n->dump(out);
            }
            sir_kind::sir_switch => {
                var n = self => sir_switch*;
                n->dump(out);
            }
            sir_kind::sir_type_convert => {
                var n = self => sir_type_convert*;
                n->dump(out);
            }
            sir_kind::sir_array_cast => {
                var n = self => sir_array_cast*;
                n->dump(out);
            }
            _ => {
                io::stdout().out("unsupported ").out_i64(self->kind => i64).endln();
                unreachable();
            }
        }
    }
}

pub struct sir_nop {
    base: sir,
    info: str
}

impl sir_nop {
    pub func new(info: str*) -> sir_nop* {
        var n = sir_nop::__alloc__();
        n->base = sir::instance(sir_kind::sir_nop);
        if (info != nil) {
            n->info = info->copy_instance();
        } else {
            n->info = str::instance();
        }
        return n;
    }

    pub func delete(self) {
        self->info.delete();
    }

    pub func dump(self, out: io) {
        if (!self->info.empty()) {
            out.out("; ").out(self->info.c_str);
        }
        out.out("\n");
    }
}

pub struct sir_block {
    base: sir,
    allocas: primitive_vec<ptr<sir_alloca>>,
    move_register: primitive_vec<ptr<sir_alloca>>,
    stmts: primitive_vec<ptr<sir>>
}

impl sir_block {
    pub func new() -> sir_block* {
        var n = sir_block::__alloc__();
        n->base = sir::instance(sir_kind::sir_block);
        n->allocas = primitive_vec<ptr<sir_alloca>>::instance();
        n->move_register = primitive_vec<ptr<sir_alloca>>::instance();
        n->stmts = primitive_vec<ptr<sir>>::instance();
        return n;
    }

    pub func delete(self) {
        foreach (var i; self->allocas) {
            var n = i.get().unwrap() => sir*;
            n->delete();
            free(n => i8*);
        }
        foreach (var i; self->move_register) {
            var n = i.get().unwrap() => sir*;
            n->delete();
            free(n => i8*);
        }
        foreach (var i; self->stmts) {
            var n = i.get().unwrap();
            n->delete();
            free(n => i8*);
        }
        self->allocas.delete();
        self->move_register.delete();
        self->stmts.delete();
    }

    pub func add_alloca(self, s: sir_alloca*) {
        self->allocas.push(ptr<sir_alloca>::wrap(s));
    }

    pub func add_move_register(self, s: sir_alloca*) {
        self->move_register.push(ptr<sir_alloca>::wrap(s));
    }

    pub func add_stmt(self, s: sir*) {
        self->stmts.push(ptr<sir>::wrap(s));
    }

    pub func back_is_ret_stmt(self) -> bool {
        return self->stmts.size > 0 &&
               self->stmts.back().unwrap()->kind == sir_kind::sir_ret;
    }

    pub func dump(self, out: io) {
        foreach (var i; self->allocas) {
            var n = i.get().unwrap() => sir*;
            n->dump(out);
        }
        foreach (var i; self->move_register) {
            var n = i.get().unwrap() => sir*;
            n->dump(out);
        }
        foreach (var i; self->stmts) {
            i.get().unwrap()->dump(out);
        }
    }
}

pub struct array_type_t {
    base_type: str,
    size: u64
}

impl array_type_t {
    pub func instance(base: str*, size: u64) -> array_type_t {
        return array_type_t {
            base_type: base->copy_instance(),
            size: size
        };
    }

    pub func default_instance() -> array_type_t {
        return array_type_t {
            base_type: str::instance(),
            size: 0
        };
    }

    pub func copy_instance(self) -> array_type_t {
        return array_type_t {
            base_type: self->base_type.copy_instance(),
            size: self->size
        };
    }

    pub func delete(self) {
        self->base_type.delete();
    }
}

pub struct sir_alloca {
    base: sir,
    variable: str,
    type: str,
    array_info: array_type_t    
}

impl sir_alloca {
    pub func new(variable: str*, type: str*) -> sir_alloca* {
        var n = sir_alloca::__alloc__();
        n->base = sir::instance(sir_kind::sir_alloca);
        n->variable = variable->copy_instance();
        n->type = type->copy_instance();
        n->array_info = array_type_t::default_instance();
        return n;
    }

    pub func new_array(variable: str*, at: array_type_t*) -> sir_alloca* {
        var n = sir_alloca::__alloc__();
        n->base = sir::instance(sir_kind::sir_alloca);
        n->variable = variable->copy_instance();
        n->type = str::instance();
        n->array_info = at->copy_instance();
        return n;
    }

    pub func delete(self) {
        self->variable.delete();
        self->type.delete();
        self->array_info.delete();
    }

    pub func dump(self, out: io) {
        out.out("  %").out(self->variable.c_str).out(" = alloca ");
        if (self->array_info.base_type.empty()) {
            out.out(self->type.c_str).endln();
        } else {
            out.out("[").out_u64(self->array_info.size).out(" x ");
            out.out(self->array_info.base_type.c_str).out("]").endln();
        }
    }
}

pub struct sir_temp_ptr {
//
// used to get temporary pointer of numbering variable
//     %_1.real = alloca i32
// this operand will do this:
//     %1 = getelementptr i32, i32* %_1.real, i32 0
// and %1 is i32*
//
    base: sir,
    target: str,
    source: str,
    type: str,
    comment: str // for tail comment
}

impl sir_temp_ptr {
    pub func new(target: str*, source: str*, ty: str*, comment: i8*) -> sir_temp_ptr* {
        var n = sir_temp_ptr::__alloc__();
        n->base = sir::instance(sir_kind::sir_temp_ptr);
        n->target = target->copy_instance();
        n->source = source->copy_instance();
        n->type = ty->copy_instance();
        if (comment != nil) {
            n->comment = str::from(comment);
        } else {
            n->comment = str::instance();
        }
        return n;
    }

    pub func delete(self) {
        self->target.delete();
        self->source.delete();
        self->type.delete();
        self->comment.delete();
    }

    pub func dump(self, out: io) {
        out.out("  %").out(self->target.c_str).out(" = ");
        out.out("getelementptr ").out(self->type.c_str).out(", ");
        out.out(self->type.c_str).out("* %").out(self->source.c_str);
        out.out(", i32 0");
        if (self->comment.empty()) {
            out.out(" ; %").out(self->source.c_str).out(" -> %").out(self->target.c_str).endln();
        } else {
            out.out(" ; ").out(self->comment.c_str).endln();
        }
    }
}

pub struct sir_ret {
    base: sir,
    type: str,
    value: value_t,
    debug_info_index: u64
}

impl sir_ret {
    pub func new(type: str*, v: value_t*, dii: u64) -> sir_ret* {
        var n = sir_ret::__alloc__();
        n->base = sir::instance(sir_kind::sir_ret);
        n->type = type->copy_instance();
        n->value = v->copy_instance();
        n->debug_info_index = dii;
        return n;
    }

    pub func delete(self) {
        self->type.delete();
        self->value.delete();
    }

    pub func dump(self, out: io) {
        out.out("  ret ").out(self->type.c_str);
        if (self->value.kind != value_kind::null) {
            out.out(" ");
            self->value.dump(out);
        }
        if (self->debug_info_index != DI_ERROR_INDEX()) {
            out.out(", !dbg !").out_u64(self->debug_info_index);
        }
        out.endln();
    }
}

pub struct sir_str {
    base: sir,
    index: u64,
    length: u64,
    target: value_t,
    debug_info_index: u64
}

impl sir_str {
    pub func new(index: u64, length: u64, tgt: value_t*, dii: u64) -> sir_str* {
        var n = sir_str::__alloc__();
        n->base = sir::instance(sir_kind::sir_str);
        n->index = index;
        n->length = length;
        n->target = tgt->copy_instance();
        n->debug_info_index = dii;
        return n;
    }

    pub func delete(self) {
        self->target.delete();
    }

    pub func dump(self, out: io) {
        out.out("  ");
        self->target.dump(out);
        out.out(" = bitcast [").out_u64(self->length).out(" x i8]* ");
        out.out("@str.").out_u64(self->index).out(" to i8*");
        if (self->debug_info_index != DI_ERROR_INDEX()) {
            out.out(", !dbg !").out_u64(self->debug_info_index);
        }
        out.endln();
    }
}

pub struct sir_zeroinitializer {
    base: sir,
    type: str,
    target: value_t,
    debug_info_index: u64
}

impl sir_zeroinitializer {
    pub func new(tgt: value_t*, type: str*, dii: u64) -> sir_zeroinitializer* {
        var n = sir_zeroinitializer::__alloc__();
        n->base = sir::instance(sir_kind::sir_zeroinitializer);
        n->type = type->copy_instance();
        n->target = tgt->copy_instance();
        n->debug_info_index = dii;
        return n;
    }

    pub func delete(self){
        self->type.delete();
        self->target.delete();
    }

    pub func dump(self, out: io) {
        out.out("  store ").out(self->type.c_str).out(" zeroinitializer, ");
        out.out(self->type.c_str).out("* ");
        self->target.dump(out);
        if (self->debug_info_index != DI_ERROR_INDEX()) {
            out.out(", !dbg !").out_u64(self->debug_info_index);
        }
        out.endln();
    }
}

pub struct sir_get_index {
    base: sir,
    source: value_t,
    target: value_t,
    index: value_t,
    type: str,
    index_type: str,
    debug_info_index: u64
}

impl sir_get_index {
    pub func new(src: value_t*,
                 tgt: value_t*,
                 idx: value_t*,
                 t: str*,
                 it: str*,
                 dii: u64) -> sir_get_index* {
        var n = sir_get_index::__alloc__();
        n->base = sir::instance(sir_kind::sir_get_index);
        n->source = src->copy_instance();
        n->target = tgt->copy_instance();
        n->index = idx->copy_instance();
        n->type = t->copy_instance();
        n->index_type = it->copy_instance();
        n->debug_info_index = dii;
        return n;
    }

    pub func delete(self) {
        self->source.delete();
        self->target.delete();
        self->index.delete();
        self->type.delete();
        self->index_type.delete();
    }

    pub func dump(self, out: io) {
        out.out("  ");
        self->target.dump(out);
        out.out(" = getelementptr ").out(self->type.c_str).out(", ");
        out.out(self->type.c_str).out("* ");
        self->source.dump(out);
        out.out(", ").out(self->index_type.c_str).out(" ");
        self->index.dump(out);
        if (self->debug_info_index != DI_ERROR_INDEX()) {
            out.out(", !dbg !").out_u64(self->debug_info_index);
        }
        out.endln();
    }
}

pub struct sir_get_field {
    base: sir,
    source: value_t,
    target: value_t,
    struct_name: str,
    index: i64,
    debug_info_index: u64
}

impl sir_get_field {
    pub func new(tgt: value_t*, src: value_t*, sn: str*, i: i64, dii: u64) -> sir_get_field* {
        var n = sir_get_field::__alloc__();
        n->base = sir::instance(sir_kind::sir_get_field);
        n->target = tgt->copy_instance();
        n->source = src->copy_instance();
        n->struct_name = sn->copy_instance();
        n->index = i;
        n->debug_info_index = dii;
        return n;
    }

    pub func delete(self) {
        self->source.delete();
        self->target.delete();
        self->struct_name.delete();
    }

    pub func dump(self, out: io) {
        out.out("  ");
        self->target.dump(out);
        out.out(" = getelementptr inbounds ");
        out.out(self->struct_name.c_str).out(", ");
        out.out(self->struct_name.c_str).out("* ");
        self->source.dump(out);
        out.out(", i32 0, i32 ").out_i64(self->index);
        if (self->debug_info_index != DI_ERROR_INDEX()) {
            out.out(", !dbg !").out_u64(self->debug_info_index);
        }
        out.endln();
    }
}

pub struct sir_call {
    base: sir,
    name: str,
    return_type: str,
    target: value_t,
    args_type: vec<str>,
    args: vec<value_t>,
    with_va_args: bool,
    with_va_args_real_param_size: u64,
    debug_info_index: u64
}

impl sir_call {
    pub func new(name: str*, return_type: str*, tgt: value_t*) -> sir_call* {
        var n = sir_call::__alloc__();
        n->base = sir::instance(sir_kind::sir_call);
        n->name = name->copy_instance();
        n->return_type = return_type->copy_instance();
        n->target = tgt->copy_instance();
        n->args_type = vec<str>::instance();
        n->args = vec<value_t>::instance();
        n->with_va_args = false;
        n->with_va_args_real_param_size = 0;
        n->debug_info_index = DI_ERROR_INDEX();
        return n;
    }

    pub func delete(self) {
        self->name.delete();
        self->return_type.delete();
        self->target.delete();
        self->args_type.delete();
        self->args.delete();
    }

    pub func add_arg(self, arg: value_t*, arg_type: str*) {
        self->args.push(arg);
        self->args_type.push(arg_type);
    }

    pub func dump(self, out: io) {
        out.out("  ");
        if (self->target.kind == value_kind::variable) {
            self->target.dump(out);
            out.out(" = ");
        }
        out.out("call ").out(self->return_type.c_str);

        if (self->with_va_args) {
            out.out("(");
            for (var i: u64 = 0; i < self->with_va_args_real_param_size; i += 1) {
                out.out(self->args_type.get(i)->c_str).out(", ");
            }
            out.out("...)");
        }

        out.out(" @").out(self->name.c_str).out("(");
        forindex (var i; self->args) {
            out.out(self->args_type.get(i)->c_str).out(" ");
            self->args.get(i)->dump(out);
            if (i != self->args.size - 1) {
                out.out(", ");
            }
        }
        out.out(")");

        if (self->debug_info_index != DI_ERROR_INDEX()) {
            out.out(", !dbg !").out_u64(self->debug_info_index);
        }
        out.endln();
    }
}

pub struct sir_neg {
    base: sir,
    target: value_t,
    source: value_t,
    is_integer: bool,
    type: str
}

impl sir_neg {
    pub func new(src: value_t*,
                 tgt: value_t*,
                 is_int: bool,
                 type: str*) -> sir_neg* {
        var n = sir_neg::__alloc__();
        n->base = sir::instance(sir_kind::sir_neg);
        n->target = tgt->copy_instance();
        n->source = src->copy_instance();
        n->is_integer = is_int;
        n->type = type->copy_instance();
        return n;
    }

    pub func delete(self) {
        self->target.delete();
        self->source.delete();
        self->type.delete();
    }

    pub func dump(self, out: io) {
        out.out("  ");
        self->target.dump(out);
        out.out(" = ");
        if (self->is_integer) {
            out.out("sub ");
        } else {
            out.out("fsub ");
        }
        out.out(self->type.c_str).out(" ");
        if (self->is_integer) {
            out.out("0, ");
        } else {
            out.out("0.0, ");
        }
        self->source.dump(out);
        out.endln();
    }
}

pub struct sir_bnot {
    base: sir,
    target: value_t,
    source: value_t,
    type: str
}

impl sir_bnot {
    pub func new(src: value_t*, tgt: value_t*, type: str*) -> sir_bnot* {
        var n = sir_bnot::__alloc__();
        n->base = sir::instance(sir_kind::sir_bnot);
        n->target = tgt->copy_instance();
        n->source = src->copy_instance();
        n->type = type->copy_instance();
        return n;
    }

    pub func delete(self) {
        self->target.delete();
        self->source.delete();
        self->type.delete();
    }

    pub func dump(self, out: io) {
        out.out("  ");
        self->target.dump(out);
        out.out(" = xor ").out(self->type.c_str).out(" ");
        self->source.dump(out);
        out.out(", -1\n");
    }
}

pub struct sir_lnot {
    base: sir,
    target: value_t,
    source: value_t,
    type: str
}

impl sir_lnot {
    pub func new(src: value_t*, tgt: value_t*, type: str*) -> sir_lnot* {
        var n = sir_lnot::__alloc__();
        n->base = sir::instance(sir_kind::sir_lnot);
        n->target = tgt->copy_instance();
        n->source = src->copy_instance();
        n->type = type->copy_instance();
        return n;
    }

    pub func delete(self) {
        self->target.delete();
        self->source.delete();
        self->type.delete();
    }

    pub func dump(self, out: io) {
        out.out("  ");
        self->target.dump(out);
        out.out(" = xor ").out(self->type.c_str).out(" ");
        self->source.dump(out);
        out.out(", true\n");
    }
}

pub struct sir_add {
    base: sir,
    target: value_t,
    left: value_t,
    right: value_t,
    is_integer: bool,
    type: str
}

impl sir_add {
    pub func new(l: value_t*,
                 r: value_t*,
                 tgt: value_t*,
                 is_int: bool,
                 type: str*) -> sir_add* {
        var n = sir_add::__alloc__();
        n->base = sir::instance(sir_kind::sir_add);
        n->target = tgt->copy_instance();
        n->left = l->copy_instance();
        n->right = r->copy_instance();
        n->is_integer = is_int;
        n->type = type->copy_instance();
        return n;
    }

    pub func delete(self) {
        self->target.delete();
        self->left.delete();
        self->right.delete();
        self->type.delete();
    }

    pub func dump(self, out: io) {
        out.out("  ");
        self->target.dump(out);
        out.out(" = ");
        if (self->is_integer) {
            out.out("add ");
        } else {
            out.out("fadd ");
        }
        out.out(self->type.c_str).out(" ");
        self->left.dump(out);
        out.out(", ");
        self->right.dump(out);
        out.endln();
    }
}

pub struct sir_sub {
    base: sir,
    target: value_t,
    left: value_t,
    right: value_t,
    is_integer: bool,
    type: str
}

impl sir_sub {
    pub func new(l: value_t*,
                 r: value_t*,
                 tgt: value_t*,
                 is_int: bool,
                 type: str*) -> sir_sub* {
        var n = sir_sub::__alloc__();
        n->base = sir::instance(sir_kind::sir_sub);
        n->target = tgt->copy_instance();
        n->left = l->copy_instance();
        n->right = r->copy_instance();
        n->is_integer = is_int;
        n->type = type->copy_instance();
        return n;
    }

    pub func delete(self) {
        self->target.delete();
        self->left.delete();
        self->right.delete();
        self->type.delete();
    }

    pub func dump(self, out: io) {
        out.out("  ");
        self->target.dump(out);
        out.out(" = ");
        if (self->is_integer) {
            out.out("sub ");
        } else {
            out.out("fsub ");
        }
        out.out(self->type.c_str).out(" ");
        self->left.dump(out);
        out.out(", ");
        self->right.dump(out);
        out.endln();
    }
}

pub struct sir_mul {
    base: sir,
    target: value_t,
    left: value_t,
    right: value_t,
    is_integer: bool,
    type: str
}

impl sir_mul {
    pub func new(l: value_t*,
                 r: value_t*,
                 tgt: value_t*,
                 is_int: bool,
                 type: str*) -> sir_mul* {
        var n = sir_mul::__alloc__();
        n->base = sir::instance(sir_kind::sir_mul);
        n->target = tgt->copy_instance();
        n->left = l->copy_instance();
        n->right = r->copy_instance();
        n->is_integer = is_int;
        n->type = type->copy_instance();
        return n;
    }

    pub func delete(self) {
        self->target.delete();
        self->left.delete();
        self->right.delete();
        self->type.delete();
    }

    pub func dump(self, out: io) {
        out.out("  ");
        self->target.dump(out);
        out.out(" = ");
        if (self->is_integer) {
            out.out("mul ");
        } else {
            out.out("fmul ");
        }
        out.out(self->type.c_str).out(" ");
        self->left.dump(out);
        out.out(", ");
        self->right.dump(out);
        out.endln();
    }
}

pub struct sir_div {
    base: sir,
    target: value_t,
    left: value_t,
    right: value_t,
    is_integer: bool,
    is_signed: bool,
    type: str
}

impl sir_div {
    pub func new(l: value_t*,
                 r: value_t*,
                 tgt: value_t*,
                 is_int: bool,
                 is_signed: bool,
                 type: str*) -> sir_div* {
        var n = sir_div::__alloc__();
        n->base = sir::instance(sir_kind::sir_div);
        n->target = tgt->copy_instance();
        n->left = l->copy_instance();
        n->right = r->copy_instance();
        n->is_integer = is_int;
        n->is_signed = is_signed;
        n->type = type->copy_instance();
        return n;
    }

    pub func delete(self) {
        self->target.delete();
        self->left.delete();
        self->right.delete();
        self->type.delete();
    }

    pub func dump(self, out: io) {
        out.out("  ");
        self->target.dump(out);
        out.out(" = ");
        if (self->is_integer) {
            if (self->is_signed) {
                out.out("sdiv ");
            } else {
                out.out("udiv ");
            }
        } else {
            out.out("fdiv ");
        }
        out.out(self->type.c_str).out(" ");
        self->left.dump(out);
        out.out(", ");
        self->right.dump(out);
        out.endln();
    }
}

pub struct sir_rem {
    base: sir,
    target: value_t,
    left: value_t,
    right: value_t,
    is_integer: bool,
    is_signed: bool,
    type: str
}

impl sir_rem {
    pub func new(l: value_t*,
                 r: value_t*,
                 tgt: value_t*,
                 is_int: bool,
                 is_signed: bool,
                 type: str*) -> sir_rem* {
        var n = sir_rem::__alloc__();
        n->base = sir::instance(sir_kind::sir_rem);
        n->target = tgt->copy_instance();
        n->left = l->copy_instance();
        n->right = r->copy_instance();
        n->is_integer = is_int;
        n->is_signed = is_signed;
        n->type = type->copy_instance();
        return n;
    }

    pub func delete(self) {
        self->target.delete();
        self->left.delete();
        self->right.delete();
        self->type.delete();
    }

    pub func dump(self, out: io) {
        out.out("  ");
        self->target.dump(out);
        out.out(" = ");
        if (self->is_integer) {
            if (self->is_signed) {
                out.out("srem ");
            } else {
                out.out("urem ");
            }
        } else {
            out.out("frem ");
        }
        out.out(self->type.c_str).out(" ");
        self->left.dump(out);
        out.out(", ");
        self->right.dump(out);
        out.endln();
    }
}

pub struct sir_band {
    base: sir,
    target: value_t,
    left: value_t,
    right: value_t,
    type: str
}

impl sir_band {
    pub func new(l: value_t*,
                 r: value_t*,
                 tgt: value_t*,
                 type: str*) -> sir_band* {
        var n = sir_band::__alloc__();
        n->base = sir::instance(sir_kind::sir_band);
        n->target = tgt->copy_instance();
        n->left = l->copy_instance();
        n->right = r->copy_instance();
        n->type = type->copy_instance();
        return n;
    }

    pub func delete(self) {
        self->target.delete();
        self->left.delete();
        self->right.delete();
        self->type.delete();
    }

    pub func dump(self, out: io) {
        out.out("  ");
        self->target.dump(out);
        out.out(" = and ");
        out.out(self->type.c_str).out(" ");
        self->left.dump(out);
        out.out(", ");
        self->right.dump(out);
        out.endln();
    }
}

pub struct sir_bxor {
    base: sir,
    target: value_t,
    left: value_t,
    right: value_t,
    type: str
}

impl sir_bxor {
    pub func new(l: value_t*,
                 r: value_t*,
                 tgt: value_t*,
                 type: str*) -> sir_bxor* {
        var n = sir_bxor::__alloc__();
        n->base = sir::instance(sir_kind::sir_bxor);
        n->target = tgt->copy_instance();
        n->left = l->copy_instance();
        n->right = r->copy_instance();
        n->type = type->copy_instance();
        return n;
    }

    pub func delete(self) {
        self->target.delete();
        self->left.delete();
        self->right.delete();
        self->type.delete();
    }

    pub func dump(self, out: io) {
        out.out("  ");
        self->target.dump(out);
        out.out(" = xor ");
        out.out(self->type.c_str).out(" ");
        self->left.dump(out);
        out.out(", ");
        self->right.dump(out);
        out.endln();
    }
}

pub struct sir_bor {
    base: sir,
    target: value_t,
    left: value_t,
    right: value_t,
    type: str
}

impl sir_bor {
    pub func new(l: value_t*,
                 r: value_t*,
                 tgt: value_t*,
                 type: str*) -> sir_bor* {
        var n = sir_bor::__alloc__();
        n->base = sir::instance(sir_kind::sir_bor);
        n->target = tgt->copy_instance();
        n->left = l->copy_instance();
        n->right = r->copy_instance();
        n->type = type->copy_instance();
        return n;
    }

    pub func delete(self) {
        self->target.delete();
        self->left.delete();
        self->right.delete();
        self->type.delete();
    }

    pub func dump(self, out: io) {
        out.out("  ");
        self->target.dump(out);
        out.out(" = or ");
        out.out(self->type.c_str).out(" ");
        self->left.dump(out);
        out.out(", ");
        self->right.dump(out);
        out.endln();
    }
}

pub struct sir_cmp {
    base: sir,
    target: value_t,
    left: value_t,
    right: value_t,
    kind: sir_cmp_kind,
    is_integer: bool,
    is_signed: bool,
    type: str
}

impl sir_cmp {
    pub func new(op: sir_cmp_kind,
                 l: value_t*,
                 r: value_t*,
                 tgt: value_t*,
                 is_int: bool,
                 is_sign: bool,
                 type: str*) -> sir_cmp* {
        var n = sir_cmp::__alloc__();
        n->base = sir::instance(sir_kind::sir_cmp);
        n->target = tgt->copy_instance();
        n->left = l->copy_instance();
        n->right = r->copy_instance();
        n->kind = op;
        n->is_integer = is_int;
        n->is_signed = is_sign;
        n->type = type->copy_instance();
        return n;
    }

    pub func delete(self) {
        self->target.delete();
        self->left.delete();
        self->right.delete();
        self->type.delete();
    }

    pub func dump(self, out: io) {
        out.out("  ");
        self->target.dump(out);
        out.out(" = ");
        if (self->is_integer) {
            out.out("icmp ");
        } else {
            out.out("fcmp ");
        }

        var head = 's';
        if (self->is_integer && self->is_signed) {
            head = 's';
        } else {
            head = 'u';
        }

        match (self->kind) {
            sir_cmp_kind::cmp_eq => {
                if (self->is_integer) {
                    out.out("eq");
                } else {
                    out.out("ueq");
                }
            }
            sir_cmp_kind::cmp_neq => {
                if (self->is_integer) {
                    out.out("ne");
                } else {
                    out.out("une");
                }
            }
            sir_cmp_kind::cmp_ge => out.out_ch(head).out("ge");
            sir_cmp_kind::cmp_gt => out.out_ch(head).out("gt");
            sir_cmp_kind::cmp_le => out.out_ch(head).out("le");
            sir_cmp_kind::cmp_lt => out.out_ch(head).out("lt");
        }

        out.out(" ").out(self->type.c_str).out(" ");
        self->left.dump(out);
        out.out(", ");
        self->right.dump(out);
        out.endln();
    }
}

pub struct sir_label {
    base: sir,
    label: u64,
    comment: str
}

impl sir_label {
    pub func new(label: u64, comment: i8*) -> sir_label* {
        var n = sir_label::__alloc__();
        n->base = sir::instance(sir_kind::sir_label);
        n->label = label;
        n->comment = str::from(comment);
        return n;
    }

    pub func delete(self) {
        self->comment.delete();
    }

    pub func dump(self, out: io) {
        out.out("\nlabel.").out_hex(self->label => i64).out(":");
        if (!self->comment.empty()) {
            out.out("\t; ").out(self->comment.c_str);
        }
        out.endln();
    }
}

pub struct sir_store {
    base: sir,
    target: value_t,
    source: value_t,
    type: str
}

impl sir_store {
    pub func new(type: str*, src: value_t*, tgt: value_t*) -> sir_store* {
        var n = sir_store::__alloc__();
        n->base = sir::instance(sir_kind::sir_store);
        n->target = tgt->copy_instance();
        n->source = src->copy_instance();
        n->type = type->copy_instance();
        return n;
    }

    pub func delete(self) {
        self->target.delete();
        self->source.delete();
        self->type.delete();
    }

    pub func dump(self, out: io) {
        out.out("  store ").out(self->type.c_str).out(" ");
        self->source.dump(out);
        out.out(", ").out(self->type.c_str).out("* ");
        self->target.dump(out);
        out.endln();
    }
}

pub struct sir_load {
    base: sir,
    target: value_t,
    source: value_t,
    type: str
}

impl sir_load {
    pub func new(type: str*, src: value_t*, tgt: value_t*) -> sir_load* {
        var n = sir_load::__alloc__();
        n->base = sir::instance(sir_kind::sir_load);
        n->source = src->copy_instance();
        n->target = tgt->copy_instance();
        n->type = type->copy_instance();
        return n;
    }

    pub func delete(self) {
        self->target.delete();
        self->source.delete();
        self->type.delete();
    }

    pub func dump(self, out: io) {
        out.out("  ");
        self->target.dump(out);
        out.out(" = load ").out(self->type.c_str).out(", ");
        out.out(self->type.c_str).out("* ");
        self->source.dump(out);
        out.endln();
    }
}

pub struct sir_br {
    base: sir,
    label: u64
}

impl sir_br {
    pub func new(label: u64) -> sir_br* {
        var n = sir_br::__alloc__();
        n->base = sir::instance(sir_kind::sir_br);
        n->label = label;
        return n;
    }

    pub func delete(self) {}

    pub func dump(self, out: io) {
        out.out("  br label %label.").out_hex(self->label => i64).endln();
    }
}

pub struct sir_br_cond {
    base: sir,
    cond: value_t,
    label_true: u64,
    label_false: u64
}

impl sir_br_cond {
    pub func new(c: value_t*, label_true: u64, label_false: u64) -> sir_br_cond* {
        var n = sir_br_cond::__alloc__();
        n->base = sir::instance(sir_kind::sir_br_cond);
        n->cond = c->copy_instance();
        n->label_true = label_true;
        n->label_false = label_false;
        return n;
    }

    pub func delete(self) {
        self->cond.delete();
    }

    pub func dump(self, out: io) {
        out.out("  br i1 ");
        self->cond.dump(out);
        out.out(", label %label.").out_hex(self->label_true => i64);
        out.out(", label %label.").out_hex(self->label_false => i64).endln();
    }
}

pub struct sir_switch {
    base: sir,
    source: value_t,
    default_label: u64,
    case_value: vec<i64>,
    case_label: vec<u64>
}

impl sir_switch {
    pub func new(src: value_t*) -> sir_switch* {
        var n = sir_switch::__alloc__();
        n->base = sir::instance(sir_kind::sir_switch);
        n->source = src->copy_instance();
        n->default_label = 0;
        n->case_value = vec<i64>::instance();
        n->case_label = vec<u64>::instance();
        return n;
    }

    pub func delete(self) {
        self->source.delete();
        self->case_value.delete();
        self->case_label.delete();
    }

    pub func add_case(self, value: i64, label: u64) {
        self->case_value.push(value);
        self->case_label.push(label);
    }

    pub func dump(self, out: io) {
        out.out("  switch i64 ");
        self->source.dump(out);
        out.out(", label %label.").out_hex(self->default_label => i64).out(" [\n");
        forindex (var i; self->case_value) {
            var value = self->case_value.get(i);
            var label = self->case_label.get(i);
            out.out("    i64 ").out_i64(value);
            out.out(", label %label.").out_hex(label => i64).out("\n");
        }
        out.out("  ]\n");
    }
}

pub struct sir_type_convert {
    base: sir,
    target: value_t,
    source: value_t,
    src_type: str,
    dst_type: str,
    src_unsigned: bool,
    dst_unsigned: bool,
    debug_info_index: u64
}

impl sir_type_convert {
    pub func new(src: value_t*, tgt: value_t*,
                 st: str*, dt: str*,
                 su: bool, du: bool,
                 dii: u64) -> sir_type_convert* {
        var n = sir_type_convert::__alloc__();
        n->base = sir::instance(sir_kind::sir_type_convert);
        n->target =tgt->copy_instance();
        n->source = src->copy_instance();
        n->src_type = st->copy_instance();
        n->dst_type = dt->copy_instance();
        n->src_unsigned = su;
        n->dst_unsigned = du;
        n->debug_info_index = dii;
        return n;
    }

    pub func delete(self) {
        self->target.delete();
        self->source.delete();
        self->src_type.delete();
        self->dst_type.delete();
    }

    func dump_bitcast(self, out: io) {
        out.out("  ");
        self->target.dump(out);
        out.out(" = bitcast ").out(self->src_type.c_str).out(" ");
        self->source.dump(out);
        out.out(" to ").out(self->dst_type.c_str);
        self->dump_debug_info(out);
        out.endln();
    }

    func dump_inttoptr(self, out: io) {
        out.out("  ");
        self->target.dump(out);
        out.out(" = inttoptr ").out(self->src_type.c_str).out(" ");
        self->source.dump(out);
        out.out(" to ").out(self->dst_type.c_str);
        self->dump_debug_info(out);
        out.endln();
    }

    func dump_ptrtoint(self, out: io) {
        out.out("  ");
        self->target.dump(out);
        out.out(" = ptrtoint ").out(self->src_type.c_str).out(" ");
        self->source.dump(out);
        out.out(" to ").out(self->dst_type.c_str);
        self->dump_debug_info(out);
        out.endln();
    }

    func convert_instruction(src_type_mark: i8,
                             src_bits: u64,
                             dst_type_mark: i8,
                             dst_bits: u64) -> i8* {
        if (src_type_mark == 'u' && dst_type_mark == 'u') {
            if (src_bits < dst_bits) {
                return "zext";
            } else {
                return "trunc";
            }
        }
        if (src_type_mark == 'u' && dst_type_mark == 'i') {
            if (src_bits < dst_bits) {
                return "zext";
            } else {
                return "trunc";
            }
        }
        if (src_type_mark == 'i' && dst_type_mark == 'u') {
            if (src_bits < dst_bits) {
                return "sext";
            } else {
                return "trunc";
            }
        }
        if (src_type_mark == 'i' && dst_type_mark == 'i') {
            if (src_bits < dst_bits) {
                return "sext";
            } else {
                return "trunc";
            }
        }
        if (src_type_mark == 'u' && dst_type_mark == 'f') {
            return "uitofp";
        }
        if (src_type_mark == 'i' && dst_type_mark == 'f') {
            return "sitofp";
        }
        if (src_type_mark == 'f' && dst_type_mark == 'u') {
            return "fptoui";
        }
        if (src_type_mark == 'f' && dst_type_mark == 'i') {
            return "fptosi";
        }
        if (src_type_mark == 'f' && dst_type_mark == 'f') {
            if (src_bits < dst_bits) {
                return "fpext";
            } else {
                return "fptrunc";
            }
        }

        return "";
    }

    func dump_debug_info(self, out: io) {
        if (self->debug_info_index != DI_ERROR_INDEX()) {
            out.out(", !dbg !").out_u64(self->debug_info_index);
        }
    }

    pub func dump(self, out: io) {
        if (self->src_type.back() == '*' && self->dst_type.back() == '*') {
            self->dump_bitcast(out);
            return;
        }
        if (self->src_type.back() != '*' && self->dst_type.back() == '*') {
            self->dump_inttoptr(out);
            return;
        }
        if (self->src_type.back() == '*' && self->dst_type.back() != '*') {
            self->dump_ptrtoint(out);
            return;
        }

        var real_src_type = str::instance();
        var real_dst_type = str::instance();
        if (self->src_type.eq_const("float")) {
            real_src_type.append_i8_vec("f32");
        } else if (self->src_type.eq_const("double")) {
            real_src_type.append_i8_vec("f64");
        } else {
            real_src_type.append_str(self->src_type.__ptr__());
        }
        if (self->dst_type.eq_const("float")) {
            real_dst_type.append_i8_vec("f32");
        } else if (self->dst_type.eq_const("double")) {
            real_dst_type.append_i8_vec("f64");
        } else {
            real_dst_type.append_str(self->dst_type.__ptr__());
        }

        if (real_src_type.front() == 'i' && self->src_unsigned) {
            real_src_type.c_str[0] = 'u';
        }
        if (real_dst_type.front() == 'i' && self->dst_unsigned) {
            real_dst_type.c_str[0] = 'u';
        }

        var src_type_mark = real_src_type.front();
        var dst_type_mark = real_dst_type.front();

        // source type maybe the same as target type
        // because like i64 & u64 share the same llvm type `i64`
        if (self->src_type.eq(self->dst_type.__ptr__()) &&
            (src_type_mark == 'i' || src_type_mark == 'u')) {
            out.out("  ");
            self->target.dump(out);
            out.out(" = bitcast ").out(self->src_type.c_str).out(" ");
            self->source.dump(out);
            out.out(" to ").out(self->dst_type.c_str);
            self->dump_debug_info(out);
            out.endln();

            real_src_type.delete();
            real_dst_type.delete();
            return;
        }
        // f32 f64 also
        if (self->src_type.eq(self->dst_type.__ptr__()) && src_type_mark == 'f') {
            out.out("  ");
            self->target.dump(out);
            out.out(" = bitcast ").out(self->src_type.c_str).out(" ");
            self->source.dump(out);
            out.out(" to ").out(self->dst_type.c_str);
            self->dump_debug_info(out);
            out.endln();

            real_src_type.delete();
            real_dst_type.delete();
            return;
        }

        var src_type_bits = real_src_type.substr_from(1);
        var src_bits = to_u64(src_type_bits.__ptr__()).unwrap();
        var dst_type_bits = real_dst_type.substr_from(1);
        var dst_bits = to_u64(dst_type_bits.__ptr__()).unwrap();

        var conv_inst = sir_type_convert::convert_instruction(
            src_type_mark,
            src_bits,
            dst_type_mark,
            dst_bits
        );

        out.out("  ");
        self->target.dump(out);
        out.out(" = ").out(conv_inst).out(" ").out(self->src_type.c_str).out(" ");
        self->source.dump(out);
        out.out(" to ").out(self->dst_type.c_str);
        self->dump_debug_info(out);
        out.endln();

        real_src_type.delete();
        real_dst_type.delete();
        src_type_bits.delete();
        dst_type_bits.delete();
    }
}

pub struct sir_array_cast {
    base: sir,
    target: value_t,
    source: value_t,
    type: str,
    array_size: u64,
    debug_info_index: u64
}

impl sir_array_cast {
    pub func new(src: value_t*, tgt: value_t*, type: str*, size: u64, dii: u64) -> sir_array_cast* {
        var n = sir_array_cast::__alloc__();
        n->base = sir::instance(sir_kind::sir_array_cast);
        n->source = src->copy_instance();
        n->target = tgt->copy_instance();
        n->type = type->copy_instance();
        n->array_size = size;
        n->debug_info_index = dii;
        return n;
    }

    pub func delete(self) {
        self->target.delete();
        self->source.delete();
        self->type.delete();
    }

    pub func dump(self, out: io) {
        out.out("  ");
        self->target.dump(out);
        out.out(" = bitcast [").out_u64(self->array_size).out(" x ");
        out.out(self->type.c_str).out("]* ");
        self->source.dump(out);
        out.out(" to ").out(self->type.c_str).out("*");
        if (self->debug_info_index != DI_ERROR_INDEX()) {
            out.out(", !dbg !").out_u64(self->debug_info_index);
        }
        out.endln();
    }
}