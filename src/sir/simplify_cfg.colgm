use sir::context::{ sir_func, sir_context };
use sir::sir::{ sir_kind, sir, sir_basic_block, sir_br, sir_br_cond, sir_switch };
use sir::control_flow::{ control_flow_analysis };
use util::timestamp::{ maketimestamp };

use std::io::{ io };
use std::vec::{ vec };
use std::libc::{ free };
use std::set::{ hashset };
use std::basic::{ basic };
use std::panic::{ unreachable };

// remove blocks that have no predecessors
// block should require the following properties:
// - no predecessors
// - only have one instruction
// - the instruction is not ret/switch
// so obviously, this block is useless and can be removed
func do_remove_no_pred_blocks(f: sir_func&) -> i64 {
    if (f.body->basic_block.size <= 1) {
        return 0;
    }

    var blocks = vec<sir_basic_block*>::instance();
    defer blocks.delete();

    var delete_count = 0;
    foreach (var i; f.body->basic_block) {
        var bb = i.get();
        if (!bb->preds.empty()) {
            blocks.push(bb);
            continue;
        }

        if (bb->stmts.size > 1 || bb->back_is_ret_stmt()) {
            blocks.push(bb);
            continue;
        }

        if (bb->stmts.size == 1) {
            var stmt = bb->stmts.get(0);
            if (stmt->kind != sir_kind::sir_br &&
                stmt->kind != sir_kind::sir_br_cond) {
                blocks.push(bb);
                continue;
            }
        }

        var n = bb => sir*;
        n->delete();
        free(n => i8*);
        delete_count += 1;
    }

    if (delete_count == 0) {
        return 0;
    }

    f.body->basic_block.clear();
    foreach (var i; blocks) {
        f.body->basic_block.push(i.get());
    }
    return delete_count;
}

func iter_remove_no_pred_blocks(ctx: sir_context*) -> i64 {
    var delete_count = 0;
    foreach (var f; ctx->func_impls) {
        if (f.get().eliminated) {
            continue;
        }
        delete_count += do_remove_no_pred_blocks(f.get());
    }
    // flush cfg if some blocks were deleted
    if (delete_count > 0) {
        control_flow_analysis(ctx, false);
    }
    return delete_count;
}

func remove_no_pred_blocks(ctx: sir_context*) -> i64 {
    // build cfg first
    control_flow_analysis(ctx, false);

    // iterate until no more blocks can be removed
    var delete_count = 0;
    while (true) {
        var this_iter_delete_count = iter_remove_no_pred_blocks(ctx);
        if (this_iter_delete_count == 0) {
            break;
        }
        delete_count += this_iter_delete_count;
    }

    return delete_count;
}

func adjust_label(bb: sir_basic_block*, locked_block: hashset<basic<i64>>&) {
    var succ = bb->succs.get(0);
    locked_block.insert(basic<i64>::wrap(succ->label));

    foreach (var i; bb->preds) {
        var pred = i.get();
        var stmt = pred->stmts.back();

        if (stmt->kind == sir_kind::sir_br) {
            var n = stmt => sir_br*;
            if (n->label == bb->label) {
                n->label = succ->label;
            }
        } elsif (stmt->kind == sir_kind::sir_br_cond) {
            var n = stmt => sir_br_cond*;
            if (n->label_true == bb->label) {
                n->label_true = succ->label;
            }
            if (n->label_false == bb->label) {
                n->label_false = succ->label;
            }
        } elsif (stmt->kind == sir_kind::sir_switch) {
            var n = stmt => sir_switch*;
            if (n->default_label == bb->label) {
                n->default_label = succ->label;
            }

            foreach (var case; n->case_label) {
                if (case.get() == bb->label) {
                    n->case_label.set(case.index(), succ->label);
                }
            }
        } else {
            unreachable();
        }
    }
}

// if this block has only one successor, and only has one instruction
// which means the instruction must be br inst
// so we merge the block into all of its predecessors
// adjust label of the br insts of its predecessors to the label of the successor
func do_merge_block_with_no_cond_br(f: sir_func&) -> i64 {
    var blocks = vec<sir_basic_block*>::instance();
    defer blocks.delete();

    // if the block is locked, we cannot delete it in this iteration
    // succ of moved block will be locked
    var locked_block = hashset<basic<i64>>::instance();
    defer locked_block.delete();

    var delete_count = 0;
    foreach (var i; f.body->basic_block) {
        var bb = i.get();
        if (bb->succs.size != 1 || bb->stmts.size != 1) {
            blocks.push(bb);
            continue;
        }

        if (locked_block.has(basic<i64>::wrap(bb->label))) {
            blocks.push(bb);
            continue;
        }

        adjust_label(bb, locked_block);

        var n = bb => sir*;
        n->delete();
        free(n => i8*);
        delete_count += 1;
    }

    if (delete_count == 0) {
        return 0;
    }

    f.body->basic_block.clear();
    foreach (var i; blocks) {
        f.body->basic_block.push(i.get());
    }
    return delete_count;
}

func iter_merge_block_with_no_cond_br(ctx: sir_context*) -> i64 {
    var delete_count = 0;
    foreach (var f; ctx->func_impls) {
        if (f.get().eliminated) {
            continue;
        }
        delete_count += do_merge_block_with_no_cond_br(f.get());
    }
    // flush cfg if some blocks were deleted
    if (delete_count > 0) {
        control_flow_analysis(ctx, false);
    }
    return delete_count;
}

func merge_block_with_no_cond_br(ctx: sir_context*) -> i64 {
    // build cfg first
    control_flow_analysis(ctx, false);

    // iterate until no more blocks can be merged
    var delete_count = 0;
    while (true) {
        var this_iter_delete_count = iter_merge_block_with_no_cond_br(ctx);
        if (this_iter_delete_count == 0) {
            break;
        }
        delete_count += this_iter_delete_count;
    }

    return delete_count;
}

// if the block has only one predecessor,
// and pred's succs has only one,
// and pred's succs is this block
// then merge them into this block's predecessor
// example:
//
// label.L0:	; succs: L1
//   ...
//   br label %label.L1
// label.L1:	; preds: L0, succs: L2
//   ...
//   br label %label.L2
// label.L2:	; preds: L1, succs: L4, L6
//   ...
//   br i1 %0, label %label.L4, label %label.L6
//
// will be merged to:
//
// label.L0:	; succs: L4, L6
//   ...
//   ...
//   ...
//   br i1 %0, label %label.L4, label %label.L6
func do_merge_if_pred_has_only_one_succ(f: sir_func&) -> i64 {
    var blocks = vec<sir_basic_block*>::instance();
    defer blocks.delete();

    // if the block is locked, we cannot delete it in this iteration
    // succ of moved block will be locked
    var locked_block = hashset<basic<i64>>::instance();
    defer locked_block.delete();

    var delete_count = 0;
    foreach (var i; f.body->basic_block) {
        var bb = i.get();
        if (locked_block.has(basic<i64>::wrap(bb->label))) {
            blocks.push(bb);
            continue;
        }

        if (bb->preds.size != 1) {
            blocks.push(bb);
            continue;
        }

        var pred = bb->preds.get(0);
        // pred's succs must have only one, and must be this bb
        if (pred->succs.size != 1) {
            blocks.push(bb);
            continue;
        }

        // move last branch statement of predecessor
        var br_stmt = pred->stmts.back();
        br_stmt->delete();
        free(br_stmt => i8*);
        pred->stmts.pop_back();

        foreach (var j; bb->stmts) {
            pred->stmts.push(j.get());
        }
        bb->stmts.clear();

        foreach (var j; bb->succs) {
            locked_block.insert(basic<i64>::wrap(j.get()->label));
        }

        var n = bb => sir*;
        n->delete();
        free(n => i8*);
        delete_count += 1;
    }

    if (delete_count == 0) {
        return 0;
    }

    f.body->basic_block.clear();
    foreach (var i; blocks) {
        f.body->basic_block.push(i.get());
    }
    return delete_count;
}

func iter_merge_if_pred_has_only_one_succ(ctx: sir_context*) -> i64 {
    var delete_count = 0;
    foreach (var f; ctx->func_impls) {
        if (f.get().eliminated) {
            continue;
        }
        delete_count += do_merge_if_pred_has_only_one_succ(f.get());
    }
    // flush cfg if some blocks were deleted
    if (delete_count > 0) {
        control_flow_analysis(ctx, false);
    }
    return delete_count;
}

func merge_if_pred_has_only_one_succ(ctx: sir_context*) -> i64 {
    // build cfg first
    control_flow_analysis(ctx, false);

    // iterate until no more blocks can be merged
    var delete_count = 0;
    while (true) {
        var this_iter_delete_count = iter_merge_if_pred_has_only_one_succ(ctx);
        if (this_iter_delete_count == 0) {
            break;
        }
        delete_count += this_iter_delete_count;
    }

    return delete_count;
}

pub func simplify_cfg(ctx: sir_context*, verbose: bool) {
    var ts = maketimestamp();
    ts.stamp();

    var total = 0;
    while (true) {
        var delete_count = 0;
        delete_count += remove_no_pred_blocks(ctx);
        delete_count += merge_block_with_no_cond_br(ctx);
        // this pass breaks ssa numbering
        // so we need to run ssa re-numbering pass after simplify-cfg pass
        delete_count += merge_if_pred_has_only_one_succ(ctx);
        if (delete_count == 0) {
            break;
        }
        total += delete_count;
    }

    if (verbose) {
        io::stdout().green().out("  SIR-PASS ").reset();
        io::stdout().out("Run SIR pass");
        io::stdout().blue().out(" <simplify cfg>").reset().out(": ");
        io::stdout().cyan().out_i64(total).reset();
        io::stdout().out(" ").out_f64(ts.elapsed_msec()).out(" ms\n");
    }
}