use ast::ast::*;
use ast::dumper::{ ast_dumper };
use err::report::*;
use err::span::{ span };
use lex::lexer::{ lexer, token, tok_kind };
use std::libc::{ free, streq };
use std::io::{ io };
use std::str::{ str };
use std::vec::{ vec };
use parse::remove_disabled_node::{ remove_disabled_node };

pub struct parser {
    err: report*,
    toks: vec<token>*,
    root: root*,
    index: i64
}

impl parser {
    func tok_kind_to_content(kind: tok_kind) -> const i8* {
        match(kind) {
            tok_kind::tok_null =>       return "<null>";
            tok_kind::tok_num =>        return "<number-literal>";
            tok_kind::tok_str =>        return "<string-literal>";
            tok_kind::tok_ch =>         return "<char-literal>";
            tok_kind::tok_id =>         return "<identifier>";
            tok_kind::tok_true =>       return "true";
            tok_kind::tok_false =>      return "false";
            tok_kind::tok_use =>        return "use";
            tok_kind::tok_enum =>       return "enum";
            tok_kind::tok_for =>        return "for";
            tok_kind::tok_forindex =>   return "forindex";
            tok_kind::tok_foreach =>    return "foreach";
            tok_kind::tok_while =>      return "while";
            tok_kind::tok_var =>        return "var";
            tok_kind::tok_struct =>     return "struct";
            tok_kind::tok_pub =>        return "pub";
            tok_kind::tok_extern =>     return "extern";
            tok_kind::tok_const =>      return "const";
            tok_kind::tok_impl =>       return "impl";
            tok_kind::tok_func =>       return "func";
            tok_kind::tok_match =>      return "match";
            tok_kind::tok_break =>      return "break";
            tok_kind::tok_continue =>   return "continue";
            tok_kind::tok_return =>     return "return";
            tok_kind::tok_if =>         return "if";
            tok_kind::tok_elsif =>      return "elsif";
            tok_kind::tok_else =>       return "else";
            tok_kind::tok_nil =>        return "nil";
            tok_kind::tok_lparen =>     return "(";
            tok_kind::tok_rparen =>     return ")";
            tok_kind::tok_lbracket =>   return "[";
            tok_kind::tok_rbracket =>   return "]";
            tok_kind::tok_lbrace =>     return "{";
            tok_kind::tok_rbrace =>     return "}";
            tok_kind::tok_semi =>       return ";";
            tok_kind::tok_op_and =>     return "&&";
            tok_kind::tok_op_or =>      return "||";
            tok_kind::tok_comma =>      return ",";
            tok_kind::tok_dot =>        return ".";
            tok_kind::tok_ellipsis =>   return "...";
            tok_kind::tok_quesmark =>   return "?";
            tok_kind::tok_colon =>      return ":";
            tok_kind::tok_coloncolon => return "::";
            tok_kind::tok_add =>        return "+";
            tok_kind::tok_sub =>        return "-";
            tok_kind::tok_mul =>        return "*";
            tok_kind::tok_div =>        return "/";
            tok_kind::tok_rem =>        return "%";
            tok_kind::tok_floater =>    return "~";
            tok_kind::tok_bit_and =>    return "&";
            tok_kind::tok_bit_or =>     return "|";
            tok_kind::tok_bit_xor =>    return "^";
            tok_kind::tok_op_not =>     return "!";
            tok_kind::tok_eq =>         return "=";
            tok_kind::tok_addeq =>      return "+=";
            tok_kind::tok_subeq =>      return "-=";
            tok_kind::tok_muleq =>      return "*=";
            tok_kind::tok_diveq =>      return "/=";
            tok_kind::tok_remeq =>      return "%=";
            tok_kind::tok_floatereq =>  return "~=";
            tok_kind::tok_bit_and_eq => return "&=";
            tok_kind::tok_bit_or_eq =>  return "|=";
            tok_kind::tok_bit_xor_eq => return "^=";
            tok_kind::tok_cmp_eq =>     return "==";
            tok_kind::tok_neq =>        return "!=";
            tok_kind::tok_less =>       return "<";
            tok_kind::tok_leq =>        return "<=";
            tok_kind::tok_grt =>        return ">";
            tok_kind::tok_geq =>        return ">=";
            tok_kind::tok_arrow =>      return "->";
            tok_kind::tok_wide_arrow => return "=>";
            tok_kind::tok_sharp =>      return "#";
            tok_kind::tok_eof =>        return "<eof>";
        }
        return "<unknown>";
    }
}

impl parser {
    pub func new(e: report*, l: lexer*) -> parser* {
        var res = parser::__alloc__();
        res->err = e;
        res->toks = l->toks.__ptr__();
        res->root = nil => root*;
        res->index = 0;
        return res;
    }

    pub func delete(self) {
        if (self->root == (nil => root*)) {
            return;
        }
        self->root->delete();
        free(self->root => i8*);
    }

    func get_tok(self, index: i64) -> token* {
        return self->toks->get(index => u64);
    }

    func this_tok(self) -> token* {
        return self->toks->get(self->index => u64);
    }

    func this_tok_loc_copy(self) -> span* {
        return self->this_tok()->location->copy();
    }

    func this_tok_loc(self) -> span* {
        return self->this_tok()->location;
    }

    func update_location(self, node: ast*) {
        if (self->index <= 0) {
            return;
        }

        // do not update location if node does not have location info
        if (node->location => i8* == nil) {
            return;
        }

        var last_loc = self->get_tok(self->index - 1)->location;
        node->location->end_line = last_loc->end_line;
        node->location->end_column = last_loc->end_column;
    }

    func lookahead(self, kind: tok_kind) -> bool {
        return self->this_tok()->kind == kind;
    }

    func lookahead_generic(self) -> bool {
        if (self->this_tok()->kind != tok_kind::tok_less) {
            return false;
        }

        var tmp_ptr = self->index + 1;
        // check if is end of file token
        if (self->get_tok(tmp_ptr)->kind == tok_kind::tok_eof) {
            return false;
        }
        // check if is generic
        while(self->get_tok(tmp_ptr)->kind != tok_kind::tok_grt) {
            if (self->get_tok(tmp_ptr)->kind == tok_kind::tok_eof) {
                return false;
            }
            if (self->get_tok(tmp_ptr)->kind != tok_kind::tok_id) {
                return false;
            }
            tmp_ptr += 1;
            if (self->get_tok(tmp_ptr)->kind == tok_kind::tok_eof) {
                return false;
            }
            if (self->get_tok(tmp_ptr)->kind != tok_kind::tok_comma &&
                self->get_tok(tmp_ptr)->kind != tok_kind::tok_grt) {
                return false;
            }
            if (self->get_tok(tmp_ptr)->kind == tok_kind::tok_comma) {
                tmp_ptr += 1;
            }
        }
        return true;
    }

    func next(self) {
        if (self->this_tok()->kind == tok_kind::tok_eof) {
            return;
        }
        self->index += 1;
    }

    func match_token(self, kind: tok_kind) {
        var tp = self->this_tok()->kind;
        if (tp == kind) {
            self->next();
            return;
        }
        var loc = self->this_tok()->location;
        match (kind) {
            tok_kind::tok_id => {
                self->err->error(loc, "expected identifier here.");
                self->next();
                return;
            }
            tok_kind::tok_num => {
                self->err->error(loc, "expected number here.");
                self->next();
                return;
            }
            tok_kind::tok_str => {
                self->err->error(loc, "expected string here.");
                self->next();
                return;
            }
        }

        var message = str::instance();
        message.append_i8_vec("get \"")
               ->append_str(self->this_tok()->content)
               ->append_i8_vec("\" here, but expect \"")
               ->append_i8_vec(parser::tok_kind_to_content(kind))
               ->append_i8_vec("\".");
        self->err->error(loc, message.c_str);
        message.delete();

        while (self->this_tok()->kind != tok_kind::tok_eof &&
               self->this_tok()->kind != kind) {
            self->next();
        }
    }
}

impl parser {
    func conditional_compilation(self) -> ast_cond_compile* {
        var begin_loc = self->this_tok_loc();
        self->match_token(tok_kind::tok_sharp);
        self->match_token(tok_kind::tok_lbracket);
        var res = ast_cond_compile::new(
            begin_loc->copy(),
            self->this_tok()->content
        );
        self->match_token(tok_kind::tok_id);
        self->match_token(tok_kind::tok_lparen);
        while (!self->lookahead(tok_kind::tok_rparen)) {
            var key = self->this_tok()->content;
            self->match_token(tok_kind::tok_id);
            self->match_token(tok_kind::tok_eq);
            var value = self->this_tok()->content;
            self->match_token(tok_kind::tok_str);
            res->add_condition(key, value);
            if (self->lookahead(tok_kind::tok_comma)) {
                self->match_token(tok_kind::tok_comma);
            } else {
                break;
            }
        }
        
        self->match_token(tok_kind::tok_rparen);
        self->match_token(tok_kind::tok_rbracket);
        self->update_location(res => ast*);
        return res;
    }

    func identifier_gen(self) -> ast_identifier* {
        var res = ast_identifier::new(
            self->this_tok_loc_copy(),
            self->this_tok()->content
        );
        self->match_token(tok_kind::tok_id);
        return res;
    }

    func initializer_gen(self) -> ast_initializer* {
        var res = ast_initializer::new(self->this_tok_loc_copy());
        self->match_token(tok_kind::tok_lbrace);
        while (!self->lookahead(tok_kind::tok_rbrace)) {
            var pair_node = ast_init_pair::new(self->this_tok_loc_copy());
            pair_node->field = self->identifier_gen();
            self->match_token(tok_kind::tok_colon);
            pair_node->value = self->calculation_gen();
            self->update_location(pair_node => ast*);
            res->pairs.push(pair_node => ast*);
            if (self->lookahead(tok_kind::tok_comma)) {
                self->match_token(tok_kind::tok_comma);
            } else {
                break;
            }
        }
        self->match_token(tok_kind::tok_rbrace);
        self->update_location(res => ast*);
        return res;
    }

    func call_id_gen(self) -> ast_call_id* {
        var res = ast_call_id::new(self->this_tok_loc_copy());
        res->id = self->identifier_gen();
        if (self->lookahead_generic()) {
            res->generic_types = self->generic_type_list_gen();
        }
        self->update_location(res => ast*);
        return res;
    }

    func call_gen(self) -> ast_call* {
        var res = ast_call::new(self->this_tok_loc_copy());
        res->head = self->call_id_gen();
        while (self->lookahead(tok_kind::tok_lparen) ||
               self->lookahead(tok_kind::tok_lbracket) ||
               self->lookahead(tok_kind::tok_lbrace) ||
               self->lookahead(tok_kind::tok_dot) ||
               self->lookahead(tok_kind::tok_arrow) ||
               self->lookahead(tok_kind::tok_coloncolon)) {
            match (self->this_tok()->kind) {
                tok_kind::tok_lparen => {
                    self->match_token(tok_kind::tok_lparen);
                    var call_func = ast_call_func_args::new(self->this_tok_loc_copy());
                    while (!self->lookahead(tok_kind::tok_rparen)) {
                        call_func->args.push(self->calculation_gen());
                        if (self->lookahead(tok_kind::tok_comma)) {
                            self->match_token(tok_kind::tok_comma);
                        } else {
                            break;
                        }
                    }
                    self->match_token(tok_kind::tok_rparen);
                    self->update_location(call_func => ast*);
                    res->chain.push(call_func => ast*);
                }
                tok_kind::tok_lbracket => {
                    self->match_token(tok_kind::tok_lbracket);
                    var call_index = ast_call_index::new(self->this_tok_loc_copy());
                    call_index->index = self->calculation_gen();
                    self->update_location(call_index => ast*);
                    self->match_token(tok_kind::tok_rbracket);
                    res->chain.push(call_index => ast*);
                }
                tok_kind::tok_lbrace => {
                    res->chain.push(self->initializer_gen() => ast*);
                }
                tok_kind::tok_dot => {
                    self->match_token(tok_kind::tok_dot);
                    var get_field = ast_get_field::new(
                        self->this_tok_loc_copy(),
                        self->this_tok()->content
                    );
                    self->match_token(tok_kind::tok_id);
                    res->chain.push(get_field => ast*);
                }
                tok_kind::tok_arrow => {
                    self->match_token(tok_kind::tok_arrow);
                    var ptr_get_field = ast_ptr_get_field::new(
                        self->this_tok_loc_copy(),
                        self->this_tok()->content
                    );
                    self->match_token(tok_kind::tok_id);
                    res->chain.push(ptr_get_field => ast*);
                }
                tok_kind::tok_coloncolon => {
                    self->match_token(tok_kind::tok_coloncolon);
                    var call_path = ast_call_path::new(
                        self->this_tok_loc_copy(),
                        self->this_tok()->content
                    );
                    self->match_token(tok_kind::tok_id);
                    res->chain.push(call_path => ast*);
                }
            }
        }
        self->update_location(res => ast*);
        return res;
    }

    func nil_gen(self) -> ast_nil_literal* {
        var res = ast_nil_literal::new(self->this_tok_loc_copy());
        self->match_token(tok_kind::tok_nil);
        return res;
    }

    func number_literal_gen(self) -> ast_number_literal* {
        var res = ast_number_literal::new(
            self->this_tok_loc_copy(),
            self->this_tok()->content
        );
        self->match_token(tok_kind::tok_num);
        return res;
    }

    func string_literal_gen(self) -> ast_string_literal* {
        var res = ast_string_literal::new(
            self->this_tok_loc_copy(),
            self->this_tok()->content
        );
        self->match_token(tok_kind::tok_str);
        return res;
    }

    func char_gen(self) -> ast_char_literal* {
        var res = ast_char_literal::new(
            self->this_tok_loc_copy(),
            self->this_tok()->content
        );
        self->match_token(tok_kind::tok_ch);
        return res;
    }

    func bool_gen(self) -> ast_bool_literal* {
        var res = nil => ast_bool_literal*;
        if (streq(self->this_tok()->content->c_str, "true")) {
            res = ast_bool_literal::new(
                self->this_tok_loc_copy(),
                true
            );
            self->match_token(tok_kind::tok_true);
        } else if (streq(self->this_tok()->content->c_str, "false")) {
            res = ast_bool_literal::new(
                self->this_tok_loc_copy(),
                false
            );
            self->match_token(tok_kind::tok_false);
        } else {
            self->err->error(
                self->this_tok()->location,
                "expected \"true\" or \"false\" here."
            );
        }
        return res;
    }

    func array_gen(self) -> ast_array_literal* {
        var res = ast_array_literal::new(self->this_tok_loc_copy());
        self->match_token(tok_kind::tok_lbracket);
        res->type = self->type_def_gen();
        self->match_token(tok_kind::tok_semi);
        res->size = self->number_literal_gen();
        self->match_token(tok_kind::tok_rbracket);
        self->update_location(res => ast*);
        return res;
    }

    func scalar_gen(self) -> ast* {
        if (self->lookahead(tok_kind::tok_lparen)) {
            self->match_token(tok_kind::tok_lparen);
            var res = self->calculation_gen();
            self->match_token(tok_kind::tok_rparen);
            return res;
        }
        if (self->lookahead(tok_kind::tok_sub)) {
            return self->unary_neg_gen() => ast*;
        } elsif (self->lookahead(tok_kind::tok_floater)) {
            return self->unary_bnot_gen() => ast*;
        } elsif (self->lookahead(tok_kind::tok_nil)) {
            return self->nil_gen() => ast*;
        } elsif (self->lookahead(tok_kind::tok_num)) {
            return self->number_literal_gen() => ast*;
        } elsif (self->lookahead(tok_kind::tok_str)) {
            return self->string_literal_gen() => ast*;
        } elsif (self->lookahead(tok_kind::tok_ch)) {
            return self->char_gen() => ast*;
        } elsif (self->lookahead(tok_kind::tok_true) ||
                 self->lookahead(tok_kind::tok_false)) {
            return self->bool_gen() => ast*;
        } elsif (self->lookahead(tok_kind::tok_lbracket)) {
            return self->array_gen() => ast*;
        } elsif (self->lookahead(tok_kind::tok_id)) {
            return self->call_gen() => ast*;
        }

        self->err->error(
            self->this_tok()->location,
            "expected scalar here."
        );
        return ast_null::new() => ast*;
    }

    func unary_neg_gen(self) -> ast_unary_operator* {
        var res = ast_unary_operator::new(
            self->this_tok_loc_copy(),
            unary_kind::neg
        );
        self->match_token(tok_kind::tok_sub);
        res->value = self->scalar_gen();
        self->update_location(res => ast*);
        return res;
    }

    func unary_bnot_gen(self) -> ast_unary_operator* {
        var res = ast_unary_operator::new(
            self->this_tok_loc_copy(),
            unary_kind::bnot
        );
        self->match_token(tok_kind::tok_floater);
        res->value = self->scalar_gen();
        self->update_location(res => ast*);
        return res;
    }

    func type_convert_gen(self) -> ast* {
        var begin_loc = self->this_tok_loc();
        var result = self->scalar_gen();
        if (self->lookahead(tok_kind::tok_wide_arrow)) {
            self->match_token(tok_kind::tok_wide_arrow);
            var type_cast_node = ast_type_convert::new(begin_loc->copy());
            type_cast_node->from = result;
            type_cast_node->to = self->type_def_gen();
            self->update_location(type_cast_node => ast*);
            return type_cast_node => ast*;
        }
        return result;
    }

    func multive_gen(self) -> ast* {
        var begin_loc = self->this_tok_loc();
        var res = self->type_convert_gen();
        while (self->lookahead(tok_kind::tok_mul) ||
               self->lookahead(tok_kind::tok_div) ||
               self->lookahead(tok_kind::tok_rem)) {
            var kind = binary_kind::mul;
            match(self->this_tok()->kind) {
                tok_kind::tok_mul => kind = binary_kind::mul;
                tok_kind::tok_div => kind = binary_kind::div;
                tok_kind::tok_rem => kind = binary_kind::rem;
            }
            var binary = ast_binary_operator::new(begin_loc->copy(), kind);
            self->match_token(self->this_tok()->kind);
            binary->left = res;
            binary->right = self->type_convert_gen();
            res = binary => ast*;
        }
        self->update_location(res);
        return res;
    }

    func additive_gen(self) -> ast* {
        var begin_loc = self->this_tok_loc();
        var res = self->multive_gen();
        while (self->lookahead(tok_kind::tok_add) ||
               self->lookahead(tok_kind::tok_sub)) {
            var binary = nil => ast_binary_operator*;
            match(self->this_tok()->kind) {
                tok_kind::tok_add => {
                    binary = ast_binary_operator::new(
                        begin_loc->copy(),
                        binary_kind::add
                    );
                }
                tok_kind::tok_sub => {
                    binary = ast_binary_operator::new(
                        begin_loc->copy(),
                        binary_kind::sub
                    );
                }
            }
            self->match_token(self->this_tok()->kind);
            binary->left = res;
            binary->right = self->multive_gen();
            res = binary => ast*;
        }
        self->update_location(res);
        return res;
    }

    func bitwise_and_gen(self) -> ast* {
        var begin_loc = self->this_tok_loc();
        var res = self->additive_gen();
        while (self->lookahead(tok_kind::tok_bit_and)) {
            var binary = ast_binary_operator::new(
                begin_loc->copy(),
                binary_kind::band
            );
            self->match_token(tok_kind::tok_bit_and);
            binary->left = res;
            binary->right = self->additive_gen();
            res = binary => ast*;
        }
        self->update_location(res);
        return res;
    }

    func bitwise_xor_gen(self) -> ast* {
        var begin_loc = self->this_tok_loc();
        var res = self->bitwise_and_gen();
        while (self->lookahead(tok_kind::tok_bit_xor)) {
            var binary = ast_binary_operator::new(
                begin_loc->copy(),
                binary_kind::bxor
            );
            self->match_token(tok_kind::tok_bit_xor);
            binary->left = res;
            binary->right = self->bitwise_and_gen();
            res = binary => ast*;
        }
        self->update_location(res);
        return res;
    }

    func bitwise_or_gen(self) -> ast* {
        var begin_loc = self->this_tok_loc();
        var res = self->bitwise_xor_gen();
        while (self->lookahead(tok_kind::tok_bit_or)) {
            var binary = ast_binary_operator::new(
                begin_loc->copy(),
                binary_kind::bor
            );
            self->match_token(tok_kind::tok_bit_or);
            binary->left = res;
            binary->right = self->bitwise_xor_gen();
            res = binary => ast*;
        }
        self->update_location(res);
        return res;
    }

    func compare_gen(self) -> ast* {
        var begin_loc = self->this_tok_loc();
        var res = self->bitwise_or_gen();
        while (self->lookahead(tok_kind::tok_cmp_eq) ||
               self->lookahead(tok_kind::tok_neq) ||
               self->lookahead(tok_kind::tok_less) ||
               self->lookahead(tok_kind::tok_leq) ||
               self->lookahead(tok_kind::tok_grt) ||
               self->lookahead(tok_kind::tok_geq)) {
            var kind = binary_kind::add;
            match (self->this_tok()->kind) {
                tok_kind::tok_cmp_eq => kind = binary_kind::cmpeq;
                tok_kind::tok_neq => kind = binary_kind::cmpne;
                tok_kind::tok_less => kind = binary_kind::less;
                tok_kind::tok_leq => kind = binary_kind::leq;
                tok_kind::tok_grt => kind = binary_kind::grt;
                tok_kind::tok_geq => kind = binary_kind::geq;
            }
            var binary = ast_binary_operator::new(begin_loc->copy(), kind);
            self->match_token(self->this_tok()->kind);
            binary->left = res;
            binary->right = self->bitwise_or_gen();
            res = binary => ast*;
        }
        self->update_location(res);
        return res;
    }

    func not_expression_gen(self) -> ast* {
        var begin_loc = self->this_tok_loc();
        if (!self->lookahead(tok_kind::tok_op_not)) {
            return self->compare_gen();
        }
        self->match_token(tok_kind::tok_op_not);
        var value = self->compare_gen();
        var res = ast_unary_operator::new(begin_loc->copy(), unary_kind::lnot);
        res->value = value;
        self->update_location(res => ast*);
        return res => ast*;
    }

    func and_expression_gen(self) -> ast* {
        var begin_loc = self->this_tok_loc();
        var res = self->not_expression_gen();
        if (!self->lookahead(tok_kind::tok_op_and)) {
            return res;
        }
        var binary = ast_binary_operator::new(
            begin_loc->copy(),
            binary_kind::cmpand
        );
        binary->left = res;
        self->match_token(tok_kind::tok_op_and);
        binary->right = self->and_expression_gen();
        self->update_location(binary => ast*);
        return binary => ast*;
    }

    func or_expression_gen(self) -> ast* {
        var begin_loc = self->this_tok_loc();
        var res = self->and_expression_gen();
        if (!self->lookahead(tok_kind::tok_op_or)) {
            return res;
        }
        var binary = ast_binary_operator::new(
            begin_loc->copy(),
            binary_kind::cmpor
        );
        binary->left = res;
        self->match_token(tok_kind::tok_op_or);
        binary->right = self->or_expression_gen();
        self->update_location(binary => ast*);
        return binary => ast*;
    }

    func calculation_gen(self) -> ast* {
        var begin_loc = self->this_tok_loc();
        var res = self->or_expression_gen();
        if (res->kind != ast_kind::ast_call) {
            return res;
        }
        // if is call node, check assignment syntax
        if (self->lookahead(tok_kind::tok_addeq) ||
            self->lookahead(tok_kind::tok_subeq) ||
            self->lookahead(tok_kind::tok_muleq) ||
            self->lookahead(tok_kind::tok_diveq) ||
            self->lookahead(tok_kind::tok_remeq) ||
            self->lookahead(tok_kind::tok_bit_and_eq) ||
            self->lookahead(tok_kind::tok_bit_xor_eq) ||
            self->lookahead(tok_kind::tok_bit_or_eq) ||
            self->lookahead(tok_kind::tok_eq)) {
            var assignment = ast_assignment::new(begin_loc->copy());
            assignment->left = res => ast_call*;
            match (self->this_tok()->kind) {
                tok_kind::tok_addeq => assignment->kind = assignment_kind::addeq;
                tok_kind::tok_subeq => assignment->kind = assignment_kind::subeq;
                tok_kind::tok_muleq => assignment->kind = assignment_kind::muleq;
                tok_kind::tok_diveq => assignment->kind = assignment_kind::diveq;
                tok_kind::tok_remeq => assignment->kind = assignment_kind::remeq;
                tok_kind::tok_bit_and_eq => assignment->kind = assignment_kind::andeq;
                tok_kind::tok_bit_xor_eq => assignment->kind = assignment_kind::xoreq;
                tok_kind::tok_bit_or_eq => assignment->kind = assignment_kind::oreq;
                tok_kind::tok_eq => assignment->kind = assignment_kind::eq;
            }
            self->match_token(self->this_tok()->kind);
            assignment->right = self->calculation_gen();
            self->update_location(assignment => ast*);
            return assignment => ast*;
        }
        self->update_location(res);
        return res;
    }

    func type_def_gen(self) -> ast_type_def* {
        var res = ast_type_def::new(self->this_tok_loc_copy());
        if (self->lookahead(tok_kind::tok_const)) {
            self->match_token(tok_kind::tok_const);
            res->is_const = true;
        }
        res->name = self->identifier_gen();
        if (self->lookahead_generic()) {
            res->generic_types = self->generic_type_list_gen();
        }
        while (self->lookahead(tok_kind::tok_mul)) {
            res->pointer_depth += 1;
            self->match_token(tok_kind::tok_mul);
        }
        self->update_location(res => ast*);
        return res;
    }

    func generic_type_list_gen(self) -> ast_generic_type_list* {
        var res = ast_generic_type_list::new(self->this_tok_loc_copy());
        self->match_token(tok_kind::tok_less);
        while (self->lookahead(tok_kind::tok_id)) {
            // generic type does not allow pointer or other forms
            var type_node = ast_type_def::new(self->this_tok_loc_copy());
            type_node->name = self->identifier_gen();
            res->types.push(type_node => ast*);
            if (self->lookahead(tok_kind::tok_comma)) {
                self->match_token(tok_kind::tok_comma);
            } else if (self->lookahead(tok_kind::tok_id)) {
                self->err->error(self->this_tok_loc(), "expected comma here.");
            }
        }
        self->match_token(tok_kind::tok_grt);
        self->update_location(res => ast*);
        return res;
    }

    func struct_field_gen(self) -> ast_struct_field* {
        var res = ast_struct_field::new(self->this_tok_loc_copy());
        res->name = self->identifier_gen();
        self->match_token(tok_kind::tok_colon);
        res->type = self->type_def_gen();
        self->update_location(res => ast*);
        return res;
    }

    func struct_decl_gen(self) -> ast_struct_decl* {
        var begin_loc = self->this_tok_loc_copy();
        self->match_token(tok_kind::tok_struct);
        var res = ast_struct_decl::new(
            begin_loc,
            self->this_tok()->content
        );
        self->match_token(tok_kind::tok_id);
        if (self->lookahead_generic()) {
            res->generic_types = self->generic_type_list_gen();
        }
        self->match_token(tok_kind::tok_lbrace);
        while (!self->lookahead(tok_kind::tok_rbrace)) {
            res->fields.push(self->struct_field_gen() => ast*);
            if (self->lookahead(tok_kind::tok_comma)) {
                self->match_token(tok_kind::tok_comma);
            } else {
                break;
            }
        }
        self->match_token(tok_kind::tok_rbrace);
        self->update_location(res => ast*);
        return res;
    }

    func enum_member_gen(self) -> ast_enum_member* {
        var res = ast_enum_member::new(self->this_tok_loc_copy());
        res->name = self->identifier_gen();
        if (self->lookahead(tok_kind::tok_eq)) {
            self->match_token(tok_kind::tok_eq);
            res->value = self->number_literal_gen();
        }
        self->update_location(res => ast*);
        return res;
    }

    func enum_decl_gen(self) -> ast_enum_decl* {
        var begin_loc = self->this_tok_loc_copy();
        self->match_token(tok_kind::tok_enum);
        var res = ast_enum_decl::new(
            begin_loc,
            self->this_tok()->content
        );
        self->match_token(tok_kind::tok_id);
        self->match_token(tok_kind::tok_lbrace);
        while (!self->lookahead(tok_kind::tok_rbrace)) {
            res->members.push(self->enum_member_gen() => ast*);
            if (self->lookahead(tok_kind::tok_comma)) {
                self->match_token(tok_kind::tok_comma);
            } else {
                break;
            }
        }
        self->match_token(tok_kind::tok_rbrace);
        self->update_location(res => ast*);
        return res;
    }

    func use_stmt_gen(self) -> ast_use_stmt* {
        var res = ast_use_stmt::new(self->this_tok_loc_copy());
        self->match_token(tok_kind::tok_use);
        res->module_path.push(self->identifier_gen() => ast*);
        while (self->lookahead(tok_kind::tok_coloncolon)) {
            self->match_token(tok_kind::tok_coloncolon);
            if (self->lookahead(tok_kind::tok_lbrace) ||
                self->lookahead(tok_kind::tok_mul)) {
                break;
            }
            res->module_path.push(self->identifier_gen() => ast*);
        }
        if (self->lookahead(tok_kind::tok_lbrace)) {
            self->match_token(tok_kind::tok_lbrace);
            while (self->lookahead(tok_kind::tok_id)) {
                res->import_symbol.push(self->identifier_gen() => ast*);
                if (self->lookahead(tok_kind::tok_comma)) {
                    self->match_token(tok_kind::tok_comma);
                } else {
                    break;
                }
            }
            self->match_token(tok_kind::tok_rbrace);
        } else if (!self->lookahead(tok_kind::tok_mul)) {
            var last = res->module_path.back();
            res->module_path.pop();
            res->import_symbol.push(last);
        } else {
            self->match_token(tok_kind::tok_mul);
        }
        self->update_location(res => ast*);
        self->match_token(tok_kind::tok_semi);
        return res;
    }

    func param_gen(self) -> ast_param* {
        var res = ast_param::new(self->this_tok_loc_copy());
        res->name = self->identifier_gen();
        if (self->lookahead(tok_kind::tok_colon)) {
            self->match_token(tok_kind::tok_colon);
            res->type = self->type_def_gen();
        }
        self->update_location(res => ast*);
        return res;
    }

    func param_list_gen(self) -> ast_param_list* {
        var res = ast_param_list::new(self->this_tok_loc_copy());
        self->match_token(tok_kind::tok_lparen);
        while (!self->lookahead(tok_kind::tok_rparen)) {
            res->params.push(self->param_gen() => ast*);
            if (self->lookahead(tok_kind::tok_comma)) {
                self->match_token(tok_kind::tok_comma);
            } else {
                break;
            }
        }
        self->match_token(tok_kind::tok_rparen);
        self->update_location(res => ast*);
        return res;
    }

    func function_decl_gen(self) -> ast_func_decl* {
        var begin_loc = self->this_tok_loc_copy();
        self->match_token(tok_kind::tok_func);
        var res = ast_func_decl::new(
            begin_loc,
            self->this_tok()->content
        );
        self->match_token(tok_kind::tok_id);
        if (self->lookahead_generic()) {
            res->generic_types = self->generic_type_list_gen();
        }
        res->params = self->param_list_gen();
        if (self->lookahead(tok_kind::tok_arrow)) {
            self->match_token(tok_kind::tok_arrow);
            res->return_type = self->type_def_gen();
        }
        if (self->lookahead(tok_kind::tok_semi)) {
            self->match_token(tok_kind::tok_semi);
            self->update_location(res => ast*);
            return res;
        }
        res->body = self->block_gen(false);
        self->update_location(res => ast*);
        return res;
    }

    func impl_gen(self) -> ast_impl* {
        var begin_loc = self->this_tok_loc_copy();
        self->match_token(tok_kind::tok_impl);
        var res = ast_impl::new(
            begin_loc,
            self->this_tok()->content
        );
        self->match_token(tok_kind::tok_id);
        if (self->lookahead_generic()) {
            res->generic_types = self->generic_type_list_gen();
        }
        self->match_token(tok_kind::tok_lbrace);
        while (!self->lookahead(tok_kind::tok_rbrace)) {
            var is_pub = false;
            if (self->lookahead(tok_kind::tok_pub)) {
                self->match_token(tok_kind::tok_pub);
                is_pub = true;
            }
            var tmp = self->function_decl_gen();
            tmp->is_public = is_pub;
            res->methods.push(tmp => ast*);
        }
        self->match_token(tok_kind::tok_rbrace);
        self->update_location(res => ast*);
        return res;
    }

    func block_gen(self, flag_allow_single_stmt_without_brace: bool) -> ast_code_block* {
        var res = ast_code_block::new(self->this_tok_loc_copy());
        if (flag_allow_single_stmt_without_brace &&
            !self->lookahead(tok_kind::tok_lbrace)) {
            res->stmts.push(self->stmt_gen());
            self->update_location(res => ast*);
            return res;
        }
        
        self->match_token(tok_kind::tok_lbrace);
        while (!self->lookahead(tok_kind::tok_rbrace)) {
            res->stmts.push(self->stmt_gen());
        }
        self->match_token(tok_kind::tok_rbrace);
        self->update_location(res => ast*);
        return res;
    }
}

impl parser {
    func stmt_gen(self) -> ast* {
        match (self->this_tok()->kind) {
            tok_kind::tok_var => return self->definition_gen() => ast*;
            tok_kind::tok_lparen => return self->in_stmt_expr_gen() => ast*;
            tok_kind::tok_nil => return self->in_stmt_expr_gen() => ast*;
            tok_kind::tok_num => return self->in_stmt_expr_gen() => ast*;
            tok_kind::tok_str => return self->in_stmt_expr_gen() => ast*;
            tok_kind::tok_id => return self->in_stmt_expr_gen() => ast*;
            tok_kind::tok_if => return self->cond_stmt_gen() => ast*;
            tok_kind::tok_match => return self->match_stmt_gen() => ast*;
            tok_kind::tok_while => return self->while_stmt_gen() => ast*;
            tok_kind::tok_for => return self->for_stmt_gen() => ast*;
            tok_kind::tok_return => return self->return_gen() => ast*;
            tok_kind::tok_continue => return self->continue_gen() => ast*;
            tok_kind::tok_break => return self->break_gen() => ast*;
            tok_kind::tok_semi => {
                self->match_token(tok_kind::tok_semi);
                return ast_null::new() => ast*;
            }
        }

        self->err->error(
            self->this_tok()->location,
            "expected statement here."
        );
        self->next();
        return ast_null::new() => ast*;
    }

    func definition_gen(self) -> ast_definition* {
        var begin_loc = self->this_tok_loc_copy();
        self->match_token(tok_kind::tok_var);
        var res = ast_definition::new(
            begin_loc,
            self->this_tok()->content
        );
        self->match_token(tok_kind::tok_id);
        if (self->lookahead(tok_kind::tok_colon)) {
            self->match_token(tok_kind::tok_colon);
            res->type = self->type_def_gen();
        }
        self->match_token(tok_kind::tok_eq);
        res->value = self->calculation_gen();
        self->update_location(res => ast*);
        self->match_token(tok_kind::tok_semi);
        return res;
    }

    func cond_stmt_gen(self) -> ast_cond_stmt* {
        var res = ast_cond_stmt::new(self->this_tok_loc_copy());
        
        var new_if = ast_if_stmt::new(self->this_tok_loc_copy());
        self->match_token(tok_kind::tok_if);
        self->match_token(tok_kind::tok_lparen);
        new_if->condition = self->calculation_gen();
        self->match_token(tok_kind::tok_rparen);
        new_if->body = self->block_gen(true);
        self->update_location(new_if => ast*);
        res->stmts.push(new_if => ast*);

        while (self->lookahead(tok_kind::tok_elsif)) {
            var new_elsif = ast_if_stmt::new(self->this_tok_loc_copy());
            self->match_token(tok_kind::tok_elsif);
            self->match_token(tok_kind::tok_lparen);
            new_elsif->condition = self->calculation_gen();
            self->match_token(tok_kind::tok_rparen);
            new_elsif->body = self->block_gen(true);
            self->update_location(new_elsif => ast*);
            res->stmts.push(new_elsif => ast*);
        }

        if (self->lookahead(tok_kind::tok_else)) {
            var new_else = ast_if_stmt::new(self->this_tok_loc_copy());
            self->match_token(tok_kind::tok_else);
            new_else->body = self->block_gen(true);
            self->update_location(new_else => ast*);
            res->stmts.push(new_else => ast*);
        }

        self->update_location(res => ast*);
        return res;
    }

    func match_stmt_gen(self) -> ast_match_stmt* {
        var res = ast_match_stmt::new(self->this_tok_loc_copy());
        self->match_token(tok_kind::tok_match);
        self->match_token(tok_kind::tok_lparen);
        res->value = self->calculation_gen();
        self->match_token(tok_kind::tok_rparen);

        self->match_token(tok_kind::tok_lbrace);
        while(!self->lookahead(tok_kind::tok_rbrace)) {
            var new_case = ast_match_case::new(self->this_tok_loc_copy());
            new_case->pattern = self->call_gen();
            self->match_token(tok_kind::tok_wide_arrow);
            new_case->body = self->block_gen(true);
            res->cases.push(new_case => ast*);
        }
        self->match_token(tok_kind::tok_rbrace);
        self->update_location(res => ast*);
        return res;
    }

    func while_stmt_gen(self) -> ast_while_stmt* {
        var res = ast_while_stmt::new(self->this_tok_loc_copy());
        self->match_token(tok_kind::tok_while);
        self->match_token(tok_kind::tok_lparen);
        res->condition = self->calculation_gen();
        self->match_token(tok_kind::tok_rparen);
        res->body = self->block_gen(true);
        self->update_location(res => ast*);
        return res;
    }

    func for_stmt_gen(self) -> ast_for_stmt* {
        var res = ast_for_stmt::new(self->this_tok_loc_copy());
        self->match_token(tok_kind::tok_for);
        self->match_token(tok_kind::tok_lparen);
        if (self->lookahead(tok_kind::tok_var)) {
            res->init = self->definition_gen();
        } else {
            self->match_token(tok_kind::tok_semi);
        }
        if (!self->lookahead(tok_kind::tok_semi)) {
            res->condition = self->calculation_gen();
        }
        self->match_token(tok_kind::tok_semi);
        if (!self->lookahead(tok_kind::tok_rparen)) {
            res->update = self->calculation_gen();
        }
        self->match_token(tok_kind::tok_rparen);
        res->body = self->block_gen(true);
        self->update_location(res => ast*);
        return res;
    }

    func in_stmt_expr_gen(self) -> ast_in_stmt_expr* {
        var res = ast_in_stmt_expr::new(self->this_tok_loc_copy());
        res->value = self->calculation_gen();
        self->match_token(tok_kind::tok_semi);
        return res;
    }

    func return_gen(self) -> ast_ret_stmt* {
        var res = ast_ret_stmt::new(self->this_tok_loc_copy());
        self->match_token(tok_kind::tok_return);
        if (!self->lookahead(tok_kind::tok_semi)) {
            res->value = self->calculation_gen();
        }
        self->update_location(res => ast*);
        self->match_token(tok_kind::tok_semi);
        return res;
    }

    func continue_gen(self) -> ast_continue_stmt* {
        var res = ast_continue_stmt::new(self->this_tok_loc_copy());
        self->match_token(tok_kind::tok_continue);
        self->match_token(tok_kind::tok_semi);
        return res;
    }

    func break_gen(self) -> ast_break_stmt* {
        var res = ast_break_stmt::new(self->this_tok_loc_copy());
        self->match_token(tok_kind::tok_break);
        self->match_token(tok_kind::tok_semi);
        return res;
    }
}

impl parser {
    func pub_decl_gen(self) -> ast* {
        self->match_token(tok_kind::tok_pub);
        if (self->lookahead(tok_kind::tok_extern)) {
            var res = self->extern_decl_gen();
            if (res->kind == ast_kind::ast_func_decl) {
                var tmp = res => ast_func_decl*;
                tmp->is_public = true;
                return tmp => ast*;
            } elsif (res->kind == ast_kind::ast_struct_decl) {
                var tmp = res => ast_struct_decl*;
                tmp->is_public = true;
                return tmp => ast*;
            } else {
                self->err->error(res->location, "unreachable, please report bug.");
            }
        } elsif (self->lookahead(tok_kind::tok_func)) {
            var res = self->function_decl_gen();
            res->is_public = true;
            return res => ast*;
        } elsif (self->lookahead(tok_kind::tok_struct)) {
            var res = self->struct_decl_gen();
            res->is_public = true;
            return res => ast*;
        } elsif (self->lookahead(tok_kind::tok_enum)) {
            var res = self->enum_decl_gen();
            res->is_public = true;
            return res => ast*;
        }
    
        self->err->error(self->this_tok_loc(), "expect function, struct or enum.");
        return ast_null::new() => ast*;
    }

    func extern_decl_gen(self) -> ast* {
        self->match_token(tok_kind::tok_extern);
        if (self->lookahead(tok_kind::tok_func)) {
            var res = self->function_decl_gen();
            res->is_extern = true;
            return res => ast*;
        }
        if (self->lookahead(tok_kind::tok_struct)) {
            var res = self->struct_decl_gen();
            res->is_extern = true;
            return res => ast*;
        }
        self->err->error(self->this_tok_loc(), "expect function or struct.");
        return ast_null::new() => ast*;
    }
}

impl parser {
    pub func parse(self) {
        self->index = 0;
        self->root = root::new(self->this_tok_loc_copy());
        if (self->lookahead(tok_kind::tok_eof)) {
            return;
        }
        while (self->lookahead(tok_kind::tok_use)) {
            self->root->imports.push(self->use_stmt_gen() => ast*);
        }
        while (!self->lookahead(tok_kind::tok_eof)) {
            var flag_is_public = false;
            var flag_is_extern = false;
            var pub_loc = nil => span*;
            var extern_loc = nil => span*;
            var cond_comp: ast_cond_compile* = nil => ast_cond_compile*;
            if (self->lookahead(tok_kind::tok_sharp)) {
                cond_comp = self->conditional_compilation();
            }
            while (self->lookahead(tok_kind::tok_pub) || self->lookahead(tok_kind::tok_extern)) {
                if (self->lookahead(tok_kind::tok_pub) && !flag_is_public) {
                    flag_is_public = true;
                    pub_loc = self->this_tok_loc();
                } else if (self->lookahead(tok_kind::tok_pub) && flag_is_public) {
                    self->err->error(self->this_tok_loc(), "duplicate 'pub' modifier.");
                }
                if (self->lookahead(tok_kind::tok_extern) && !flag_is_extern) {
                    flag_is_extern = true;
                    extern_loc = self->this_tok_loc();
                } else if (self->lookahead(tok_kind::tok_extern) && flag_is_extern) {
                    self->err->error(self->this_tok_loc(), "duplicate 'extern' modifier.");
                }
                self->next();
            }

            var decl_node: ast* = nil => ast*;
            match (self->this_tok()->kind) {
                tok_kind::tok_struct => {
                    var tmp = self->struct_decl_gen();
                    tmp->is_public = flag_is_public;
                    tmp->is_extern = flag_is_extern;
                    decl_node = tmp => ast*;
                }
                tok_kind::tok_enum => {
                    var tmp = self->enum_decl_gen();
                    tmp->is_public = flag_is_public;
                    if (flag_is_extern) {
                        self->err->error(extern_loc, "extern enum not supported.");
                    }
                    decl_node = tmp => ast*;
                }
                tok_kind::tok_func => {
                    var tmp = self->function_decl_gen();
                    tmp->is_public = flag_is_public;
                    tmp->is_extern = flag_is_extern;
                    decl_node = tmp => ast*;
                }
                tok_kind::tok_impl => {
                    if (flag_is_public) {
                        self->err->error(pub_loc, "cannot use 'pub' with 'impl'.");
                    }
                    if (flag_is_extern) {
                        self->err->error(extern_loc, "cannot use 'extern' with 'impl'.");
                    }
                    decl_node = self->impl_gen() => ast*;
                }
            }
            // embed decl node into cond_comp node
            if (cond_comp => i8* != nil && decl_node => i8* != nil) {
                cond_comp->enabled_decl = decl_node;
                self->root->decls.push(cond_comp => ast*);
                continue;
            }
            // error occurred, cond_comp node accepts nothing, delete it
            if (cond_comp => i8* != nil && decl_node => i8* == nil) {
                cond_comp->delete();
                free(cond_comp => i8*);
            }
            // cond_comp not used, insert directly
            if (decl_node => i8* != nil) {
                self->root->decls.push(decl_node => ast*);
                continue;
            }
            self->next();
        }
        self->update_location(self->root => ast*);

        remove_disabled_node(self->root);
    }
}

impl parser {
    pub func dump(self) {
        var dumper = ast_dumper::instance();
        dumper.dump(self->root => ast*, io::stdout());
        dumper.delete();
    }
}