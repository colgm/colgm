use ast::ast::*;
use std::str::{ str };
use std::io::{ io };

struct ast_dumper {
    indent: str
}

impl ast_dumper {
    func instance() -> ast_dumper {
        var res = ast_dumper {
            indent: str::instance()
        };
        res.indent.clear();
        return res;
    }

    func delete(self) {
        self->indent.delete();
    }

    func push_indent(self) {
        self->indent.append_i8_vec("  ");
    }

    func pop_indent(self) {
        self->indent.pop();
        self->indent.pop();
    }
}

impl ast_dumper {
    func dump(self, node: ast*, out: io) {
        match(node->kind) {
            ast_kind::ast_null => return;
            ast_kind::ast_root => self->dump_root(node => root*, out);
            ast_kind::ast_code_block =>
                self->dump_code_block(node => ast_code_block*, out);
            ast_kind::ast_identifier =>
                self->dump_identifier(node => ast_identifier*, out);
            ast_kind::ast_nil_literal =>
                self->dump_nil_literal(node => ast_nil_literal*, out);
            ast_kind::ast_number_literal =>
                self->dump_number_literal(node => ast_number_literal*, out);
            ast_kind::ast_string_literal =>
                self->dump_string_literal(node => ast_string_literal*, out);
            ast_kind::ast_char_literal =>
                self->dump_char_literal(node => ast_char_literal*, out);
            ast_kind::ast_bool_literal =>
                self->dump_bool_literal(node => ast_bool_literal*, out);
            ast_kind::ast_use_stmt =>
                self->dump_use_stmt(node => ast_use_stmt*, out);
            ast_kind::ast_type_def =>
                self->dump_type_def(node => ast_type_def*, out);
            ast_kind::ast_enum_member =>
                self->dump_enum_member(node => ast_enum_member*, out);
            ast_kind::ast_enum_decl =>
                self->dump_enum_decl(node => ast_enum_decl*, out);
            ast_kind::ast_struct_field =>
                self->dump_struct_field(node => ast_struct_field*, out);
            ast_kind::ast_struct_decl =>
                self->dump_struct_decl(node => ast_struct_decl*, out);
            ast_kind::ast_param =>
                self->dump_param(node => ast_param*, out);
            ast_kind::ast_param_list =>
                self->dump_param_list(node => ast_param_list*, out);
            ast_kind::ast_func_decl => 
                self->dump_func_decl(node => ast_func_decl*, out);
        }
    }

    func dump_root(self, node: root*, out: io) {
        out.out(self->indent.c_str).out("root -> ");
        node->base.location->dump(out);

        self->push_indent();
        for (var index = 0 => u64; index < node->imports.size; index += 1 => u64) {
            self->dump(node->imports.data[index], out);
        }
        for (var index = 0 => u64; index < node->decls.size; index += 1 => u64) {
            self->dump(node->decls.data[index], out);
        }
        self->pop_indent();
    }

    func dump_identifier(self, node: ast_identifier*, out: io) {
        out.out(self->indent.c_str)
           .out("identifier: ")
           .out(node->name.c_str)
           .out(" -> ");
        node->base.location->dump(out);
    }

    func dump_nil_literal(self, node: ast_nil_literal*, out: io) {
        out.out(self->indent.c_str)
           .out("nil-literal -> ");
        node->base.location->dump(out);
    }

    func dump_number_literal(self, node: ast_number_literal*, out: io) {
        out.out(self->indent.c_str)
           .out("number-literal: ")
           .out(node->literal.c_str)
           .out(" -> ");
        node->base.location->dump(out);
    }

    func dump_string_literal(self, node: ast_string_literal*, out: io) {
        out.out(self->indent.c_str)
           .out("string-literal: ")
           .out(node->literal.c_str)
           .out(" -> ");
        node->base.location->dump(out);
    }

    func dump_char_literal(self, node: ast_char_literal*, out: io) {
        out.out(self->indent.c_str)
           .out("char-literal: ")
           .out_ch(node->literal)
           .out(" -> ");
        node->base.location->dump(out);
    }

    func dump_bool_literal(self, node: ast_bool_literal*, out: io) {
        out.out(self->indent.c_str)
           .out("bool-literal: ");
        if (node->flag) {
            out.out("true");
        } else {
            out.out("false");
        }
        out.out(" -> ");
        node->base.location->dump(out);
    }

    func dump_use_stmt(self, node: ast_use_stmt*, out: io) {
        out.out(self->indent.c_str).out("use -> ");
        node->base.location->dump(out);

        self->push_indent();

        out.out(self->indent.c_str).out("module\n");
        self->push_indent();
        for (var index = 0 => u64; index < node->module_path.size; index += 1 => u64) {
            self->dump(node->module_path.data[index], out);
        }
        self->pop_indent();

        if (node->import_symbol.size == 0 => u64) {
            out.out(self->indent.c_str).out("import-all\n");
        } else {
            out.out(self->indent.c_str).out("import-specified\n");
            self->push_indent();
            for (var index = 0 => u64; index < node->import_symbol.size; index += 1 => u64) {
                self->dump(node->import_symbol.data[index], out);
            }
            self->pop_indent();
        }

        self->pop_indent();
    }

    func dump_type_def(self, node: ast_type_def*, out: io) {
        out.out(self->indent.c_str).out("type-def [pointer depth=")
           .out_i64(node->pointer_depth).out("] -> ");
        node->base.location->dump(out);

        self->push_indent();
        self->dump_identifier(node->name, out);
        self->pop_indent();
    }

    func dump_enum_member(self, node: ast_enum_member*, out: io) {
        out.out(self->indent.c_str).out("enum-member -> ");
        node->base.location->dump(out);

        self->push_indent();
        self->dump_identifier(node->name, out);
        if (node->value => i8* != nil) {
            self->dump_number_literal(node->value, out);
        }
        self->pop_indent();
    }

    func dump_enum_decl(self, node: ast_enum_decl*, out: io) {
        out.out(self->indent.c_str).out("enum-decl [")
           .out(node->name.c_str).out("] -> ");
        node->base.location->dump(out);

        self->push_indent();
        for (var index = 0 => u64; index < node->members.size; index += 1 => u64) {
            self->dump(node->members.data[index], out);
        }
        self->pop_indent();
    }

    func dump_struct_field(self, node: ast_struct_field*, out: io) {
        out.out(self->indent.c_str).out("struct-field -> ");
        node->base.location->dump(out);

        self->push_indent();
        self->dump_identifier(node->name, out);
        self->dump_type_def(node->type, out);
        self->pop_indent();
    }

    func dump_struct_decl(self, node: ast_struct_decl*, out: io) {
        out.out(self->indent.c_str).out("struct-decl [")
           .out(node->name.c_str).out("] -> ");
        node->base.location->dump(out);

        self->push_indent();
        for (var index = 0 => u64; index < node->fields.size; index += 1 => u64) {
            self->dump(node->fields.data[index], out);
        }
        self->pop_indent();
    }

    func dump_param(self, node: ast_param*, out: io) {
        out.out(self->indent.c_str).out("param -> ");
        node->base.location->dump(out);
        self->push_indent();
        self->dump_identifier(node->name, out);
        if (node->type => i8* != nil) {
            self->dump_type_def(node->type, out);
        }
        self->pop_indent();
    }

    func dump_param_list(self, node: ast_param_list*, out: io) {
        out.out(self->indent.c_str).out("param-list -> ");
        node->base.location->dump(out);

        self->push_indent();
        for (var index = 0 => u64; index < node->params.size; index += 1 => u64) {
            self->dump(node->params.data[index], out);
        }
        self->pop_indent();
    }

    func dump_func_decl(self, node: ast_func_decl*, out: io) {
        out.out(self->indent.c_str).out("func-decl [")
           .out(node->name.c_str).out("] -> ");
        node->base.location->dump(out);

        self->push_indent();
        self->dump_param_list(node->params, out);
        if (node->return_type => i8* != nil) {
            self->dump_type_def(node->return_type, out);
        }
        if (node->body => i8* != nil) {
            self->dump_code_block(node->body, out);
        }
        self->pop_indent();
    }

    func dump_code_block(self, node: ast_code_block*, out: io) {
        out.out(self->indent.c_str).out("code-block -> ");
        node->base.location->dump(out);
        self->push_indent();
        for (var index = 0 => u64; index < node->stmts.size; index += 1 => u64) {
            self->dump(node->stmts.data[index], out);
        }
        self->pop_indent();
    }
}