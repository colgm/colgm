use err::span::{ span };

use std::panic::{ panic, unreachable };
use std::libc::{ free };
use std::io::{ io };
use std::str::{ str };
use std::map::{ hashmap };
use std::vec::{ vec };

use sema::type::{ type };

pub enum ast_kind {
    ast_null,
    ast_root,
    ast_unary_operator,
    ast_binary_operator,
    ast_type_convert,
    ast_identifier,
    ast_nil_literal,
    ast_number_literal,
    ast_string_literal,
    ast_char_literal,
    ast_bool_literal,
    ast_array_list,
    ast_call_index,
    ast_call_func_args,
    ast_get_field,
    ast_ptr_get_field,
    ast_init_pair,
    ast_initializer,
    ast_call_path,
    ast_call_id,
    ast_call,
    ast_assignment,
    ast_cond_compile,
    ast_type_def,
    ast_generic_type_list,
    ast_enum_member,
    ast_enum_decl,
    ast_field_pair,
    ast_struct_decl,
    ast_tagged_union_decl,
    ast_param,
    ast_param_list,
    ast_func_decl,
    ast_impl,
    ast_use_stmt,
    ast_definition,
    ast_cond_stmt,
    ast_if_stmt,
    ast_match_case,
    ast_match_stmt,
    ast_while_stmt,
    ast_for_stmt,
    ast_forindex,
    ast_foreach,
    ast_in_stmt_expr,
    ast_defer_stmt,
    ast_ret_stmt,
    ast_continue_stmt,
    ast_break_stmt,
    ast_code_block
}

pub func ast_kind_name(k: ast_kind) -> i8* {
    match (k) {
        ast_kind::ast_null => return "ast_null";
        ast_kind::ast_root => return "ast_root";
        ast_kind::ast_unary_operator => return "ast_unary_operator";
        ast_kind::ast_binary_operator => return "ast_binary_operator";
        ast_kind::ast_type_convert => return "ast_type_convert";
        ast_kind::ast_identifier => return "ast_identifier";
        ast_kind::ast_nil_literal => return "ast_nil_literal";
        ast_kind::ast_number_literal => return "ast_number_literal";
        ast_kind::ast_string_literal => return "ast_string_literal";
        ast_kind::ast_char_literal => return "ast_char_literal";
        ast_kind::ast_bool_literal => return "ast_bool_literal";
        ast_kind::ast_array_list => return "ast_array_list";
        ast_kind::ast_call_index => return "ast_call_index";
        ast_kind::ast_call_func_args => return "ast_call_func_args";
        ast_kind::ast_get_field => return "ast_get_field";
        ast_kind::ast_ptr_get_field => return "ast_ptr_get_field";
        ast_kind::ast_init_pair => return "ast_init_pair";
        ast_kind::ast_initializer => return "ast_initializer";
        ast_kind::ast_call_path => return "ast_call_path";
        ast_kind::ast_call_id => return "ast_call_id";
        ast_kind::ast_call => return "ast_call";
        ast_kind::ast_assignment => return "ast_assignment";
        ast_kind::ast_cond_compile => return "ast_cond_compile";
        ast_kind::ast_type_def => return "ast_type_def";
        ast_kind::ast_generic_type_list => return "ast_generic_type_list";
        ast_kind::ast_enum_member => return "ast_enum_member";
        ast_kind::ast_enum_decl => return "ast_enum_decl";
        ast_kind::ast_field_pair => return "ast_field_pair";
        ast_kind::ast_struct_decl => return "ast_struct_decl";
        ast_kind::ast_tagged_union_decl => return "ast_tagged_union_decl";
        ast_kind::ast_param => return "ast_param";
        ast_kind::ast_param_list => return "ast_param_list";
        ast_kind::ast_func_decl => return "ast_func_decl";
        ast_kind::ast_impl => return "ast_impl";
        ast_kind::ast_use_stmt => return "ast_use_stmt";
        ast_kind::ast_definition => return "ast_definition";
        ast_kind::ast_cond_stmt => return "ast_cond_stmt";
        ast_kind::ast_if_stmt => return "ast_if";
        ast_kind::ast_match_case => return "ast_match_case";
        ast_kind::ast_match_stmt => return "ast_match";
        ast_kind::ast_while_stmt => return "ast_while";
        ast_kind::ast_for_stmt => return "ast_for";
        ast_kind::ast_forindex => return "ast_forindex";
        ast_kind::ast_foreach => return "ast_foreach";
        ast_kind::ast_in_stmt_expr => return "ast_in_stmt_expr";
        ast_kind::ast_defer_stmt => return "ast_defer_stmt";
        ast_kind::ast_ret_stmt => return "ast_ret";
        ast_kind::ast_continue_stmt => return "ast_continue";
        ast_kind::ast_break_stmt => return "ast_break";
        ast_kind::ast_code_block => return "ast_code_block";
    }

    return "unknown";
}

pub enum unary_kind {
    neg,
    bnot,
    lnot
}

pub enum binary_kind {
    add,
    sub,
    mul,
    div,
    rem,
    cmpeq,
    cmpne,
    less,
    leq,
    grt,
    geq,
    cmpand,
    cmpor,
    band,
    bor,
    bxor
}

pub enum assignment_kind {
    eq,
    addeq,
    subeq,
    muleq,
    diveq,
    remeq,
    andeq,
    xoreq,
    oreq
}

pub struct ast {
    kind: ast_kind,         // ast node kind
    location: span,         // location of ast node
    redirect_location: str, // redirect location, used by generic types
    resolved_type: type     // resolved type, filled by semantic analysis
}

impl ast {
    pub func instance(k: ast_kind, loc: span&) -> ast {
        return ast {
            kind: k,
            location: loc.clone(),
            redirect_location: str::from(""),
            resolved_type: type::instance("", "")
        };
    }

    pub func is_redirected(self) -> bool {
        return !self.redirect_location.empty();
    }

    pub func set_redirect_location(self, loc: str&) {
        self.redirect_location.clear();
        self.redirect_location.append_str(loc);
    }

    pub func delete(self) {
        self.location.delete();
        self.redirect_location.delete();
        self.resolved_type.delete();

        match (self.kind) {
            ast_kind::ast_null => {}
            ast_kind::ast_root => {
                var tmp = self.__ptr__() => root*;
                tmp->delete();
            }
            ast_kind::ast_unary_operator => {
                var tmp = self.__ptr__() => ast_unary_operator*;
                tmp->delete();
            }
            ast_kind::ast_binary_operator => {
                var tmp = self.__ptr__() => ast_binary_operator*;
                tmp->delete();
            }
            ast_kind::ast_type_convert => {
                var tmp = self.__ptr__() => ast_type_convert*;
                tmp->delete();
            }
            ast_kind::ast_identifier => {
                var tmp = self.__ptr__() => ast_identifier*;
                tmp->delete();
            }
            ast_kind::ast_nil_literal => {}
            ast_kind::ast_number_literal => {
                var tmp = self.__ptr__() => ast_number_literal*;
                tmp->delete();
            }
            ast_kind::ast_string_literal => {
                var tmp = self.__ptr__() => ast_string_literal*;
                tmp->delete();
            }
            ast_kind::ast_char_literal => {
                var tmp = self.__ptr__() => ast_char_literal*;
                tmp->delete();
            }
            ast_kind::ast_bool_literal => {}
            ast_kind::ast_array_list => {
                var tmp = self.__ptr__() => ast_array_list*;
                tmp->delete();
            }
            ast_kind::ast_call_index => {
                var tmp = self.__ptr__() => ast_call_index*;
                tmp->delete();
            }
            ast_kind::ast_call_func_args => {
                var tmp = self.__ptr__() => ast_call_func_args*;
                tmp->delete();
            }
            ast_kind::ast_get_field => {
                var tmp = self.__ptr__() => ast_get_field*;
                tmp->delete();
            }
            ast_kind::ast_ptr_get_field => {
                var tmp = self.__ptr__() => ast_ptr_get_field*;
                tmp->delete();
            }
            ast_kind::ast_init_pair => {
                var tmp = self.__ptr__() => ast_init_pair*;
                tmp->delete();
            }
            ast_kind::ast_initializer => {
                var tmp = self.__ptr__() => ast_initializer*;
                tmp->delete();
            }
            ast_kind::ast_call_path => {
                var tmp = self.__ptr__() => ast_call_path*;
                tmp->delete();
            }
            ast_kind::ast_call_id => {
                var tmp = self.__ptr__() => ast_call_id*;
                tmp->delete();
            }
            ast_kind::ast_call => {
                var tmp = self.__ptr__() => ast_call*;
                tmp->delete();
            }
            ast_kind::ast_assignment => {
                var tmp = self.__ptr__() => ast_assignment*;
                tmp->delete();
            }
            ast_kind::ast_cond_compile => {
                var tmp = self.__ptr__() => ast_cond_compile*;
                tmp->delete();
            }
            ast_kind::ast_type_def => {
                var tmp = self.__ptr__() => ast_type_def*;
                tmp->delete();
            }
            ast_kind::ast_generic_type_list => {
                var tmp = self.__ptr__() => ast_generic_type_list*;
                tmp->delete();
            }
            ast_kind::ast_enum_member => {
                var tmp = self.__ptr__() => ast_enum_member*;
                tmp->delete();
            }
            ast_kind::ast_enum_decl => {
                var tmp = self.__ptr__() => ast_enum_decl*;
                tmp->delete();
            }
            ast_kind::ast_field_pair => {
                var tmp = self.__ptr__() =>ast_field_pair*;
                tmp->delete();
            }
            ast_kind::ast_struct_decl => {
                var tmp = self.__ptr__() => ast_struct_decl*;
                tmp->delete();
            }
            ast_kind::ast_tagged_union_decl => {
                var tmp = self.__ptr__() => ast_tagged_union_decl*;
                tmp->delete();
            }
            ast_kind::ast_param => {
                var tmp = self.__ptr__() => ast_param*;
                tmp->delete();
            }
            ast_kind::ast_param_list => {
                var tmp = self.__ptr__() => ast_param_list*;
                tmp->delete();
            }
            ast_kind::ast_func_decl => {
                var tmp = self.__ptr__() => ast_func_decl*;
                tmp->delete();
            }
            ast_kind::ast_impl => {
                var tmp = self.__ptr__() => ast_impl*;
                tmp->delete();
            }
            ast_kind::ast_use_stmt => {
                var tmp = self.__ptr__() => ast_use_stmt*;
                tmp->delete();
            }
            ast_kind::ast_definition => {
                var tmp = self.__ptr__() => ast_definition*;
                tmp->delete();
            }
            ast_kind::ast_cond_stmt => {
                var tmp = self.__ptr__() => ast_cond_stmt*;
                tmp->delete();
            }
            ast_kind::ast_if_stmt => {
                var tmp = self.__ptr__() => ast_if_stmt*;
                tmp->delete();
            }
            ast_kind::ast_match_case => {
                var tmp = self.__ptr__() => ast_match_case*;
                tmp->delete();
            }
            ast_kind::ast_match_stmt => {
                var tmp = self.__ptr__() => ast_match_stmt*;
                tmp->delete();
            }
            ast_kind::ast_while_stmt => {
                var tmp = self.__ptr__() => ast_while_stmt*;
                tmp->delete();
            }
            ast_kind::ast_for_stmt => {
                var tmp = self.__ptr__() => ast_for_stmt*;
                tmp->delete();
            }
            ast_kind::ast_forindex => {
                var tmp = self.__ptr__() => ast_forindex*;
                tmp->delete();
            }
            ast_kind::ast_foreach => {
                var tmp = self.__ptr__() => ast_foreach*;
                tmp->delete();
            }
            ast_kind::ast_in_stmt_expr => {
                var tmp = self.__ptr__() => ast_in_stmt_expr*;
                tmp->delete();
            }
            ast_kind::ast_defer_stmt => {
                var tmp = self.__ptr__() => ast_defer_stmt*;
                tmp->delete();
            }
            ast_kind::ast_ret_stmt => {
                var tmp = self.__ptr__() => ast_ret_stmt*;
                tmp->delete();
            }
            ast_kind::ast_continue_stmt => {}
            ast_kind::ast_break_stmt => {}
            ast_kind::ast_code_block => {
                var tmp = self.__ptr__() => ast_code_block*;
                tmp->delete();
            }
            _ => { panic("unknown ast kind"); }
        }
    }

    pub func get_real_location_file(self) -> str& {
        if (self.is_redirected()) {
            return self.redirect_location;
        }
        return self.location.file;
    }
}

impl ast {
    pub func is(self, kind: ast_kind) -> bool {
        return self.kind == kind;
    }

    pub func copy(self) -> ast* {
        match (self.kind) {
            ast_kind::ast_null => {
                var tmp = self.__ptr__() => ast_null*;
                return tmp->copy() => ast*;
            }
            ast_kind::ast_root => {
                var tmp = self.__ptr__() => root*;
                return tmp->copy() => ast*;
            }
            ast_kind::ast_unary_operator => {
                var tmp = self.__ptr__() => ast_unary_operator*;
                return tmp->copy() => ast*;
            }
            ast_kind::ast_binary_operator => {
                var tmp = self.__ptr__() => ast_binary_operator*;
                return tmp->copy() => ast*;
            }
            ast_kind::ast_type_convert => {
                var tmp = self.__ptr__() => ast_type_convert*;
                return tmp->copy() => ast*;
            }
            ast_kind::ast_identifier => {
                var tmp = self.__ptr__() => ast_identifier*;
                return tmp->copy() => ast*;
            }
            ast_kind::ast_nil_literal => {
                var tmp = self.__ptr__() => ast_nil_literal*;
                return tmp->copy() => ast*;
            }
            ast_kind::ast_number_literal => {
                var tmp = self.__ptr__() => ast_number_literal*;
                return tmp->copy() => ast*;
            }
            ast_kind::ast_string_literal => {
                var tmp = self.__ptr__() => ast_string_literal*;
                return tmp->copy() => ast*;
            }
            ast_kind::ast_char_literal => {
                var tmp = self.__ptr__() => ast_char_literal*;
                return tmp->copy() => ast*;
            }
            ast_kind::ast_bool_literal => {
                var tmp = self.__ptr__() => ast_bool_literal*;
                return tmp->copy() => ast*;
            }
            ast_kind::ast_array_list => {
                var tmp = self.__ptr__() => ast_array_list*;
                return tmp->copy() => ast*;
            }
            ast_kind::ast_call_index => {
                var tmp = self.__ptr__() => ast_call_index*;
                return tmp->copy() => ast*;
            }
            ast_kind::ast_call_func_args => {
                var tmp = self.__ptr__() => ast_call_func_args*;
                return tmp->copy() => ast*;
            }
            ast_kind::ast_get_field => {
                var tmp = self.__ptr__() => ast_get_field*;
                return tmp->copy() => ast*;
            }
            ast_kind::ast_ptr_get_field => {
                var tmp = self.__ptr__() => ast_ptr_get_field*;
                return tmp->copy() => ast*;
            }
            ast_kind::ast_init_pair => {
                var tmp = self.__ptr__() => ast_init_pair*;
                return tmp->copy() => ast*;
            }
            ast_kind::ast_initializer => {
                var tmp = self.__ptr__() => ast_initializer*;
                return tmp->copy() => ast*;
            }
            ast_kind::ast_call_path => {
                var tmp = self.__ptr__() => ast_call_path*;
                return tmp->copy() => ast*;
            }
            ast_kind::ast_call_id => {
                var tmp = self.__ptr__() => ast_call_id*;
                return tmp->copy() => ast*;
            }
            ast_kind::ast_call => {
                var tmp = self.__ptr__() => ast_call*;
                return tmp->copy() => ast*;
            }
            ast_kind::ast_assignment => {
                var tmp = self.__ptr__() => ast_assignment*;
                return tmp->copy() => ast*;
            }
            ast_kind::ast_cond_compile => {
                var tmp = self.__ptr__() => ast_cond_compile*;
                return tmp->copy() => ast*;
            }
            ast_kind::ast_type_def => {
                var tmp = self.__ptr__() => ast_type_def*;
                return tmp->copy() => ast*;
            }
            ast_kind::ast_generic_type_list => {
                var tmp = self.__ptr__() => ast_generic_type_list*;
                return tmp->copy() => ast*;
            }
            ast_kind::ast_enum_member => {
                var tmp = self.__ptr__() => ast_enum_member*;
                return tmp->copy() => ast*;
            }
            ast_kind::ast_enum_decl => {
                var tmp = self.__ptr__() => ast_enum_decl*;
                return tmp->copy() => ast*;
            }
            ast_kind::ast_field_pair => {
                var tmp = self.__ptr__() =>ast_field_pair*;
                return tmp->copy() => ast*;
            }
            ast_kind::ast_struct_decl => {
                var tmp = self.__ptr__() => ast_struct_decl*;
                return tmp->copy() => ast*;
            }
            ast_kind::ast_tagged_union_decl => {
                var tmp = self.__ptr__() => ast_tagged_union_decl*;
                return tmp->copy() => ast*;
            }
            ast_kind::ast_param => {
                var tmp = self.__ptr__() => ast_param*;
                return tmp->copy() => ast*;
            }
            ast_kind::ast_param_list => {
                var tmp = self.__ptr__() => ast_param_list*;
                return tmp->copy() => ast*;
            }
            ast_kind::ast_func_decl => {
                var tmp = self.__ptr__() => ast_func_decl*;
                return tmp->copy() => ast*;
            }
            ast_kind::ast_impl => {
                var tmp = self.__ptr__() => ast_impl*;
                return tmp->copy() => ast*;
            }
            ast_kind::ast_use_stmt => {
                var tmp = self.__ptr__() => ast_use_stmt*;
                return tmp->copy() => ast*;
            }
            ast_kind::ast_definition => {
                var tmp = self.__ptr__() => ast_definition*;
                return tmp->copy() => ast*;
            }
            ast_kind::ast_cond_stmt => {
                var tmp = self.__ptr__() => ast_cond_stmt*;
                return tmp->copy() => ast*;
            }
            ast_kind::ast_if_stmt => {
                var tmp = self.__ptr__() => ast_if_stmt*;
                return tmp->copy() => ast*;
            }
            ast_kind::ast_match_case => {
                var tmp = self.__ptr__() => ast_match_case*;
                return tmp->copy() => ast*;
            }
            ast_kind::ast_match_stmt => {
                var tmp = self.__ptr__() => ast_match_stmt*;
                return tmp->copy() => ast*;
            }
            ast_kind::ast_while_stmt => {
                var tmp = self.__ptr__() => ast_while_stmt*;
                return tmp->copy() => ast*;
            }
            ast_kind::ast_for_stmt => {
                var tmp = self.__ptr__() => ast_for_stmt*;
                return tmp->copy() => ast*;
            }
            ast_kind::ast_forindex => {
                var tmp = self.__ptr__() => ast_forindex*;
                return tmp->copy() => ast*;
            }
            ast_kind::ast_foreach => {
                var tmp = self.__ptr__() => ast_foreach*;
                return tmp->copy() => ast*;
            }
            ast_kind::ast_in_stmt_expr => {
                var tmp = self.__ptr__() => ast_in_stmt_expr*;
                return tmp->copy() => ast*;
            }
            ast_kind::ast_defer_stmt => {
                var tmp = self.__ptr__() => ast_defer_stmt*;
                return tmp->copy() => ast*;
            }
            ast_kind::ast_ret_stmt => {
                var tmp = self.__ptr__() => ast_ret_stmt*;
                return tmp->copy() => ast*;
            }
            ast_kind::ast_continue_stmt => {
                var tmp = self.__ptr__() => ast_continue_stmt*;
                return tmp->copy() => ast*;
            }
            ast_kind::ast_break_stmt => {
                var tmp = self.__ptr__() => ast_break_stmt*;
                return tmp->copy() => ast*;
            }
            ast_kind::ast_code_block => {
                var tmp = self.__ptr__() => ast_code_block*;
                return tmp->copy() => ast*;
            }
            _ => { panic("unknown ast kind"); }
        }
        unreachable();
        return nil;
    }
}

pub struct ast_null { base: ast }

impl ast_null {
    pub func new() -> ast_null* {
        var null_span = span::null();
        defer null_span.delete();

        var res = ast_null::__alloc__();
        res->base = ast::instance(
            ast_kind::ast_null,
            null_span
        );
        return res;
    }

    pub func copy(self) -> ast_null* {
        return ast_null::new();
    }
}

pub struct root {
    base: ast,
    imports: vec<ast*>,
    decls: vec<ast*>
}

impl root {
    pub func new(loc: span&) -> root* {
        var res = root::__alloc__();
        res->base = ast::instance(ast_kind::ast_root, loc);
        res->imports = vec<ast*>::instance();
        res->decls = vec<ast*>::instance();
        return res;
    }

    pub func copy(self) -> root* {
        var res = root::__alloc__();
        res->base = ast::instance(
            ast_kind::ast_root,
            self.base.location
        );
        res->imports = vec<ast*>::instance();
        foreach (var i; self.imports) {
            res->imports.push(i.get()->copy());
        }
        res->decls = vec<ast*>::instance();
        foreach (var i; self.decls) {
            res->decls.push(i.get()->copy());
        }
        return res;
    }

    pub func delete(self) {
        foreach (var i; self.imports) {
            i.get()->delete();
            free(i.get() => i8*);
        }
        self.imports.delete();
        foreach (var i; self.decls) {
            i.get()->delete();
            free(i.get() => i8*);
        }
        self.decls.delete();
    }
}

// expressions

pub struct ast_unary_operator {
    base: ast,
    kind: unary_kind,
    value: ast*
}

impl ast_unary_operator {
    pub func new(loc: span&, kind: unary_kind) -> ast_unary_operator* {
        var res = ast_unary_operator::__alloc__();
        res->base = ast::instance(ast_kind::ast_unary_operator, loc);
        res->kind = kind;
        res->value = nil;
        return res;
    }

    pub func copy(self) -> ast_unary_operator* {
        var res = ast_unary_operator::__alloc__();
        res->base = ast::instance(
            ast_kind::ast_unary_operator,
            self.base.location
        );
        res->kind = self.kind;
        if (self.value != nil) {
            res->value = self.value->copy();
        } else {
            res->value = nil;
        }
        return res;
    }

    pub func delete(self) {
        if (self.value != nil) {
            self.value->delete();
            free(self.value => i8*);
        }
    }
}

pub struct ast_binary_operator {
    base: ast,
    kind: binary_kind,
    left: ast*,
    right: ast*
}

impl ast_binary_operator {
    pub func new(loc: span&, kind: binary_kind) -> ast_binary_operator* {
        var res = ast_binary_operator::__alloc__();
        res->base = ast::instance(ast_kind::ast_binary_operator, loc);
        res->kind = kind;
        res->left = nil;
        res->right = nil;
        return res;
    }

    pub func copy(self) -> ast_binary_operator* {
        var res = ast_binary_operator::__alloc__();
        res->base = ast::instance(
            ast_kind::ast_binary_operator,
            self.base.location
        );
        res->kind = self.kind;
        if (self.left != nil) {
            res->left = self.left->copy();
        } else {
            res->left = nil;
        }
        if (self.right != nil) {
            res->right = self.right->copy();
        } else {
            res->right = nil;
        }
        return res;
    }

    pub func delete(self) {
        if (self.left != nil) {
            self.left->delete();
            free(self.left => i8*);
        }
        if (self.right != nil) {
            self.right->delete();
            free(self.right => i8*);
        }
    }
}

pub struct ast_type_convert {
    base: ast,
    from: ast*,
    to: ast_type_def*
}

impl ast_type_convert {
    pub func new(loc: span&) -> ast_type_convert* {
        var res = ast_type_convert::__alloc__();
        res->base = ast::instance(ast_kind::ast_type_convert, loc);
        res->from = nil;
        res->to = nil;
        return res;
    }

    pub func copy(self) -> ast_type_convert* {
        var res = ast_type_convert::__alloc__();
        res->base = ast::instance(
            ast_kind::ast_type_convert,
            self.base.location
        );
        if (self.from != nil) {
            res->from = self.from->copy();
        } else {
            res->from = nil;
        }
        if (self.to != nil) {
            res->to = self.to->copy();
        } else {
            res->to = nil;
        }
        return res;
    }

    pub func delete(self) {
        if (self.from != nil) {
            self.from->delete();
            free(self.from => i8*);
        }
        if (self.to != nil) {
            var n = self.to => ast*;
            n->delete();
            free(n => i8*);
        }
    }
}

pub struct ast_identifier {
    base: ast,
    content: str
}

impl ast_identifier {
    pub func new(loc: span&, name: str&) -> ast_identifier* {
        var res = ast_identifier::__alloc__();
        res->base = ast::instance(ast_kind::ast_identifier, loc);
        res->content = name.clone();
        return res;
    }

    pub func copy(self) -> ast_identifier* {
        var res = ast_identifier::__alloc__();
        res->base = ast::instance(
            ast_kind::ast_identifier,
            self.base.location
        );
        res->content = self.content.clone();
        return res;
    }

    pub func delete(self) {
        self.content.delete();
    }
}

pub struct ast_nil_literal {
    base: ast
}

impl ast_nil_literal {
    pub func new(loc: span&) -> ast_nil_literal* {
        var res = ast_nil_literal::__alloc__();
        res->base = ast::instance(ast_kind::ast_nil_literal, loc);
        return res;
    }

    pub func copy(self) -> ast_nil_literal* {
        return ast_nil_literal::new(self.base.location);
    }
}

pub struct ast_number_literal {
    base: ast,
    literal: str
}

impl ast_number_literal {
    pub func new(loc: span&, literal: const i8*) -> ast_number_literal* {
        var res = ast_number_literal::__alloc__();
        res->base = ast::instance(ast_kind::ast_number_literal, loc);
        res->literal = str::from(literal);
        return res;
    }

    pub func copy(self) -> ast_number_literal* {
        var res = ast_number_literal::__alloc__();
        res->base = ast::instance(
            ast_kind::ast_number_literal,
            self.base.location
        );
        res->literal = self.literal.clone();
        return res;
    }

    pub func delete(self) {
        self.literal.delete();
    }
}

pub struct ast_string_literal {
    base: ast,
    literal: str
}

impl ast_string_literal {
    pub func new(loc: span&, literal: const i8*) -> ast_string_literal* {
        var res = ast_string_literal::__alloc__();
        res->base = ast::instance(ast_kind::ast_string_literal, loc);
        res->literal = str::from(literal);
        return res;
    }

    pub func copy(self) -> ast_string_literal* {
        var res = ast_string_literal::__alloc__();
        res->base = ast::instance(
            ast_kind::ast_string_literal,
            self.base.location
        );
        res->literal = self.literal.clone();
        return res;
    }

    pub func delete(self) {
        self.literal.delete();
    }
}

pub struct ast_char_literal {
    base: ast,
    literal: str
}

impl ast_char_literal {
    pub func new(loc: span&, literal: str*) -> ast_char_literal* {
        var res = ast_char_literal::__alloc__();
        res->base = ast::instance(ast_kind::ast_char_literal, loc);
        res->literal = literal->clone();
        return res;
    }

    pub func copy(self) -> ast_char_literal* {
        var res = ast_char_literal::__alloc__();
        res->base = ast::instance(
            ast_kind::ast_char_literal,
            self.base.location
        );
        res->literal = self.literal.clone();
        return res;
    }

    pub func delete(self) {
        self.literal.delete();
    }
}

pub struct ast_bool_literal {
    base: ast,
    flag: bool
}

impl ast_bool_literal {
    pub func new(loc: span&, flag: bool) -> ast_bool_literal* {
        var res = ast_bool_literal::__alloc__();
        res->base = ast::instance(ast_kind::ast_bool_literal, loc);
        res->flag = flag;
        return res;
    }

    pub func copy(self) -> ast_bool_literal* {
        return ast_bool_literal::new(self.base.location, self.flag);
    }
}

pub struct ast_array_list {
    base: ast,
    value: vec<ast*>
}

impl ast_array_list {
    pub func new(loc: span&) -> ast_array_list* {
        var res = ast_array_list::__alloc__();
        res->base = ast::instance(ast_kind::ast_array_list, loc);
        res->value = vec<ast*>::instance();
        return res;
    }

    pub func copy(self) -> ast_array_list* {
        var res = ast_array_list::__alloc__();
        res->base = ast::instance(
            ast_kind::ast_array_list,
            self.base.location
        );
        res->value = vec<ast*>::instance();
        foreach (var i; self.value) {
            res->value.push(i.get()->copy());
        }
        return res;
    }

    pub func delete(self) {
        foreach (var i; self.value) {
            i.get()->delete();
            free(i.get() => i8*);
        }
        self.value.delete();
    }
}


pub struct ast_call_index {
    base: ast,
    index: ast*
}

impl ast_call_index {
    pub func new(loc: span&) -> ast_call_index* {
        var res = ast_call_index::__alloc__();
        res->base = ast::instance(ast_kind::ast_call_index, loc);
        res->index = nil;
        return res;
    }

    pub func copy(self) -> ast_call_index* {
        var res = ast_call_index::__alloc__();
        res->base = ast::instance(
            ast_kind::ast_call_index,
            self.base.location
        );
        if (self.index != nil) {
            res->index = self.index->copy();
        } else {
            res->index = nil;
        }
        return res;
    }

    pub func delete(self) {
        if (self.index != nil) {
            self.index->delete();
            free(self.index => i8*);
        }
    }
}

pub struct ast_call_func_args {
    base: ast,
    args: vec<ast*>,
    args_is_ref: vec<bool>
}

impl ast_call_func_args {
    pub func new(loc: span&) -> ast_call_func_args* {
        var res = ast_call_func_args::__alloc__();
        res->base = ast::instance(ast_kind::ast_call_func_args, loc);
        res->args = vec<ast*>::instance();
        res->args_is_ref = vec<bool>::instance();
        return res;
    }

    pub func copy(self) -> ast_call_func_args* {
        var res = ast_call_func_args::__alloc__();
        res->base = ast::instance(
            ast_kind::ast_call_func_args,
            self.base.location
        );
        res->args = vec<ast*>::instance();
        res->args_is_ref = vec<bool>::instance();
        foreach (var i; self.args) {
            res->args.push(i.get()->copy());
            res->args_is_ref.push(self.args_is_ref.get(i.index()));
        }
        return res;
    }

    pub func delete(self) {
        foreach (var i; self.args) {
            i.get()->delete();
            free(i.get() => i8*);
        }
        self.args.delete();
        self.args_is_ref.delete();
    }
}

pub struct ast_get_field {
    base: ast,
    operator_location: span,
    name: str
}

impl ast_get_field {
    pub func new(loc: span&, opr_loc: span&, name: const i8*) -> ast_get_field* {
        var res = ast_get_field::__alloc__();
        res->base = ast::instance(ast_kind::ast_get_field, loc);
        res->operator_location = opr_loc.clone();
        res->name = str::from(name);
        return res;
    }

    pub func copy(self) -> ast_get_field* {
        var res = ast_get_field::__alloc__();
        res->base = ast::instance(
            ast_kind::ast_get_field,
            self.base.location
        );
        res->operator_location = self.operator_location.clone();
        res->name = self.name.clone();
        return res;
    }

    pub func delete(self) {
        self.operator_location.delete();
        self.name.delete();
    }
}

pub struct ast_ptr_get_field {
    base: ast,
    operator_location: span,
    name: str
}

impl ast_ptr_get_field {
    pub func new(loc: span&, opr_loc: span&, name: const i8*) -> ast_ptr_get_field* {
        var res = ast_ptr_get_field::__alloc__();
        res->base = ast::instance(ast_kind::ast_ptr_get_field, loc);
        res->operator_location = opr_loc.clone();
        res->name = str::from(name);
        return res;
    }

    pub func copy(self) -> ast_ptr_get_field* {
        var res = ast_ptr_get_field::__alloc__();
        res->base = ast::instance(
            ast_kind::ast_ptr_get_field,
            self.base.location
        );
        res->operator_location = self.operator_location.clone();
        res->name = self.name.clone();
        return res;
    }

    pub func delete(self) {
        self.operator_location.delete();
        self.name.delete();
    }
}

pub struct ast_init_pair {
    base: ast,
    field: ast_identifier*,
    value: ast*
}

impl ast_init_pair {
    pub func new(loc: span&) -> ast_init_pair* {
        var res = ast_init_pair::__alloc__();
        res->base = ast::instance(ast_kind::ast_init_pair, loc);
        res->field = nil;
        res->value = nil;
        return res;
    }

    pub func copy(self) -> ast_init_pair* {
        var res = ast_init_pair::__alloc__();
        res->base = ast::instance(
            ast_kind::ast_init_pair,
            self.base.location
        );
        if (self.field != nil) {
            res->field = self.field->copy();
        } else {
            res->field = nil;
        }
        if (self.value != nil) {
            res->value = self.value->copy();
        } else {
            res->value = nil;
        }
        return res;
    }

    pub func delete(self) {
        if (self.field != nil) {
            var n = self.field => ast*;
            n->delete();
            free(n => i8*);
        }
        if (self.value != nil) {
            self.value->delete();
            free(self.value => i8*);
        }
    }
}

pub struct ast_initializer {
    base: ast,
    pairs: vec<ast*>
}

impl ast_initializer {
    pub func new(loc: span&) -> ast_initializer* {
        var res = ast_initializer::__alloc__();
        res->base = ast::instance(ast_kind::ast_initializer, loc);
        res->pairs = vec<ast*>::instance();
        return res;
    }

    pub func copy(self) -> ast_initializer* {
        var res = ast_initializer::__alloc__();
        res->base = ast::instance(
            ast_kind::ast_initializer,
            self.base.location
        );
        res->pairs = vec<ast*>::instance();
        foreach (var i; self.pairs) {
            res->pairs.push(i.get()->copy());
        }
        return res;
    }

    pub func delete(self) {
        foreach (var i; self.pairs) {
            i.get()->delete();
            free(i.get() => i8*);
        }
        self.pairs.delete();
    }
}

pub struct ast_call_path {
    base: ast,
    name: str
}

impl ast_call_path {
    pub func new(loc: span&, name: str*) -> ast_call_path* {
        var res = ast_call_path::__alloc__();
        res->base = ast::instance(ast_kind::ast_call_path, loc);
        res->name = name->clone();
        return res;
    }

    pub func copy(self) -> ast_call_path* {
        var res = ast_call_path::__alloc__();
        res->base = ast::instance(
            ast_kind::ast_call_path,
            self.base.location
        );
        res->name = self.name.clone();
        return res;
    }

    pub func delete(self) {
        self.name.delete();
    }
}

pub struct ast_call_id {
    base: ast,
    id: ast_identifier*,
    generic_types: ast_generic_type_list*
}

impl ast_call_id {
    pub func new(loc: span&) -> ast_call_id* {
        var res = ast_call_id::__alloc__();
        res->base = ast::instance(ast_kind::ast_call_id, loc);
        res->id = nil;
        res->generic_types = nil;
        return res;
    }

    pub func copy(self) -> ast_call_id* {
        var res = ast_call_id::__alloc__();
        res->base = ast::instance(
            ast_kind::ast_call_id,
            self.base.location
        );
        if (self.id != nil) {
            res->id = self.id->copy();
        } else {
            res->id = nil;
        }
        if (self.generic_types != nil) {
            res->generic_types = self.generic_types->copy();
        } else {
            res->generic_types = nil;
        }
        return res;
    }

    pub func delete(self) {
        if (self.id != nil) {
            var n = self.id => ast*;
            n->delete();
            free(n => i8*);
        }
        if (self.generic_types != nil) {
            var n = self.generic_types => ast*;
            n->delete();
            free(n => i8*);
        }
    }
}

pub struct ast_call {
    base: ast,
    head: ast_call_id*,
    chain: vec<ast*>
}

impl ast_call {
    pub func new(loc: span&) -> ast_call* {
        var res = ast_call::__alloc__();
        res->base = ast::instance(ast_kind::ast_call, loc);
        res->head = nil;
        res->chain = vec<ast*>::instance();
        return res;
    }

    pub func copy(self) -> ast_call* {
        var res = ast_call::__alloc__();
        res->base = ast::instance(
            ast_kind::ast_call,
            self.base.location
        );
        if (self.head != nil) {
            res->head = self.head->copy();
        } else {
            res->head = nil;
        }
        res->chain = vec<ast*>::instance();
        foreach (var i; self.chain) {
            res->chain.push(i.get()->copy());
        }
        return res;
    }

    pub func delete(self) {
        if (self.head != nil) {
            var n = self.head => ast*;
            n->delete();
            free(n => i8*);
        }
        foreach (var i; self.chain) {
            i.get()->delete();
            free(i.get() => i8*);
        }
        self.chain.delete();
    }
}

pub struct ast_assignment {
    base: ast,
    kind: assignment_kind,
    left: ast_call*,
    right: ast*
}

impl ast_assignment {
    pub func new(loc: span&) -> ast_assignment* {
        var res = ast_assignment::__alloc__();
        res->base = ast::instance(ast_kind::ast_assignment, loc);
        res->left = nil;
        res->right = nil;
        return res;
    }

    pub func copy(self) -> ast_assignment* {
        var res = ast_assignment::__alloc__();
        res->base = ast::instance(
            ast_kind::ast_assignment,
            self.base.location
        );
        res->kind = self.kind;
        if (self.left != nil) {
            res->left = self.left->copy();
        } else {
            res->left= nil;
        }
        if (self.right != nil) {
            res->right = self.right->copy();
        } else {
            res->right = nil;
        }
        return res;
    }

    pub func delete(self) {
        if (self.left != nil) {
            var n = self.left => ast*;
            n->delete();
            free(n => i8*);
        }
        if (self.right != nil) {
            self.right->delete();
            free(self.right => i8*);
        }
    }
}

// declarations

pub struct ast_cond_compile {
    base: ast,
    cond_name: str,
    ordered_conds: vec<str>,
    conds: hashmap<str, str>
}

impl ast_cond_compile {
    pub func new(loc: span&, cond_name: str*) -> ast_cond_compile* {
        var res = ast_cond_compile::__alloc__();
        res->base = ast::instance(ast_kind::ast_cond_compile, loc);
        res->cond_name = cond_name->clone();
        res->ordered_conds = vec<str>::instance();
        res->conds = hashmap<str, str>::instance();
        return res;
    }

    pub func copy(self) -> ast_cond_compile* {
        var res = ast_cond_compile::__alloc__();
        res->base = ast::instance(
            ast_kind::ast_cond_compile,
            self.base.location
        );
        res->cond_name = self.cond_name.clone();
        res->ordered_conds = self.ordered_conds.clone();
        res->conds = self.conds.clone();
        return res;
    }

    pub func delete(self) {
        self.cond_name.delete();
        self.ordered_conds.delete();
        self.conds.delete();
    }

    pub func add_condition(self, key: str&, value: str&) {
        self.ordered_conds.push(key);
        self.conds.insert(key, value);
    }

    pub func get_text(self) -> str {
        var text = str::from("#[");
        text.append_str(self.cond_name).append_char('(');
        foreach (var i; self.ordered_conds) {
            text.append(i.get().c_str);
            if (!self.conds.get(i.get()).empty()) {
                text.append(" = ");
                text.append_str(self.conds.get(i.get()));
            }
            text.append_char(',');
        }
        if (text.back() == ',') {
            text.pop_back();
        }
        text.append(")]");
        return text;
    }
}

pub struct ast_type_def {
    base: ast,
    name: ast_identifier*,
    generic_types: ast_generic_type_list*,

    pointer_depth: i64,
    is_const: bool,

    array_length: ast_number_literal*,
    is_array: bool,

    is_reference: bool
}

impl ast_type_def {
    pub func new(loc: span&) -> ast_type_def* {
        var res = ast_type_def::__alloc__();
        res->base = ast::instance(ast_kind::ast_type_def, loc);
        res->name = nil;
        res->generic_types = nil;
        res->pointer_depth = 0;
        res->is_const = false;
        res->array_length = nil;
        res->is_array = false;
        res->is_reference = false;
        return res;
    }

    pub func copy(self) -> ast_type_def* {
        var res = ast_type_def::__alloc__();
        res->base = ast::instance(
            ast_kind::ast_type_def,
            self.base.location
        );
        if (self.name != nil) {
            res->name = self.name->copy();
        } else {
            res->name = nil;
        }
        if (self.generic_types != nil) {
            res->generic_types = self.generic_types->copy();
        } else {
            res->generic_types = nil;
        }
        res->pointer_depth = self.pointer_depth;
        res->is_const = self.is_const;

        if (self.array_length != nil) {
            res->array_length = self.array_length->copy();
        } else {
            res->array_length = nil;
        }
        res->is_array = self.is_array;
        res->is_reference = self.is_reference;
        return res;
    }

    pub func delete(self) {
        if (self.name != nil) {
            var n = self.name => ast*;
            n->delete();
            free(n => i8*);
        }
        if (self.generic_types != nil) {
            var n = self.generic_types => ast*;
            n->delete();
            free(n => i8*);
        }
        if (self.array_length != nil) {
            var n = self.array_length => ast*;
            n->delete();
            free(n => i8*);
        }
    }
}

pub struct ast_generic_type_list {
    base: ast,
    types: vec<ast*>
}

impl ast_generic_type_list {
    pub func new(loc: span&) -> ast_generic_type_list* {
        var res = ast_generic_type_list::__alloc__();
        res->base = ast::instance(ast_kind::ast_generic_type_list, loc);
        res->types = vec<ast*>::instance();
        return res;
    }

    pub func copy(self) -> ast_generic_type_list* {
        var res = ast_generic_type_list::__alloc__();
        res->base = ast::instance(
            ast_kind::ast_generic_type_list,
            self.base.location
        );
        res->types = vec<ast*>::instance();
        foreach (var i; self.types) {
            res->types.push(i.get()->copy());
        }
        return res;
    }

    pub func delete(self) {
        foreach (var i; self.types) {
            i.get()->delete();
            free(i.get() => i8*);
        }
        self.types.delete();
    }
}

pub struct ast_enum_member {
    base: ast,
    name: ast_identifier*,
    value: ast_number_literal*
}

impl ast_enum_member {
    pub func new(loc: span&) -> ast_enum_member* {
        var res = ast_enum_member::__alloc__();
        res->base = ast::instance(ast_kind::ast_enum_member, loc);
        res->name = nil;
        res->value = nil;
        return res;
    }

    pub func copy(self) -> ast_enum_member* {
        var res = ast_enum_member::__alloc__();
        res->base = ast::instance(
            ast_kind::ast_enum_member,
            self.base.location
        );
        if (self.name != nil) {
            res->name = self.name->copy();
        } else {
            res->name = nil;
        }
        if (self.value != nil) {
            res->value = self.value->copy();
        } else {
            res->value = nil;
        }
        return res;
    }

    pub func delete(self) {
        if (self.name != nil) {
            var n = self.name => ast*;
            n->delete();
            free(n => i8*);
        }
        if (self.value != nil) {
            var n = self.value => ast*;
            n->delete();
            free(n => i8*);
        }
    }
}

pub struct ast_enum_decl {
    base: ast,
    members: vec<ast*>,
    name: str,
    conds: vec<ast_cond_compile*>,
    is_public: bool
}

impl ast_enum_decl {
    pub func new(loc: span&, name: str*) -> ast_enum_decl* {
        var res = ast_enum_decl::__alloc__();
        res->base = ast::instance(ast_kind::ast_enum_decl, loc);
        res->members = vec<ast*>::instance();
        res->name = name->clone();
        res->conds = vec<ast_cond_compile*>::instance();
        res->is_public = false;
        return res;
    }

    pub func copy(self) -> ast_enum_decl* {
        var res = ast_enum_decl::__alloc__();
        res->base = ast::instance(
            ast_kind::ast_enum_decl,
            self.base.location
        );
        res->members = vec<ast*>::instance();
        foreach (var i; self.members) {
            res->members.push(i.get()->copy());
        }
        res->conds = vec<ast_cond_compile*>::instance();
        foreach (var i; self.conds) {
            res->conds.push(i.get()->copy());
        }
        res->name = self.name.clone();
        res->is_public = self.is_public;
        return res;
    }

    pub func delete(self) {
        foreach (var i; self.members) {
            i.get()->delete();
            free(i.get() => i8*);
        }
        foreach (var i; self.conds) {
            var n = i.get() => ast*;
            n->delete();
            free(n => i8*);
        }
        self.members.delete();
        self.conds.delete();
        self.name.delete();
    }

    pub func set_conds(self, conds: vec<ast_cond_compile*>*) {
        foreach (var i; conds) {
            self.conds.push(i.get());
        }
    }
}

pub struct ast_field_pair {
    base: ast,
    name: ast_identifier*,
    type: ast_type_def*
}

impl ast_field_pair {
    pub func new(loc: span&) -> ast_field_pair* {
        var res = ast_field_pair::__alloc__();
        res->base = ast::instance(ast_kind::ast_field_pair, loc);
        res->name = nil;
        res->type = nil;
        return res;
    }

    pub func copy(self) -> ast_field_pair* {
        var res = ast_field_pair::__alloc__();
        res->base = ast::instance(
            ast_kind::ast_field_pair,
            self.base.location
        );
        if (self.name != nil) {
            res->name = self.name->copy();
        } else {
            res->name = nil;
        }
        if (self.type != nil) {
            res->type = self.type->copy();
        } else {
            res->type = nil;
        }
        return res;
    }

    pub func delete(self) {
        if (self.name != nil) {
            var n = self.name => ast*;
            n->delete();
            free(n => i8*);
        }
        if (self.type != nil) {
            var n = self.type => ast*;
            n->delete();
            free(n => i8*);
        }
    }
}

pub struct ast_struct_decl {
    base: ast,
    fields: vec<ast_field_pair*>,
    name: str,
    generic_types: ast_generic_type_list*,
    conds: vec<ast_cond_compile*>,
    is_public: bool,
    is_extern: bool
}

impl ast_struct_decl {
    pub func new(loc: span&, name: str*) -> ast_struct_decl* {
        var res = ast_struct_decl::__alloc__();
        res->base = ast::instance(ast_kind::ast_struct_decl, loc);
        res->fields = vec<ast_field_pair*>::instance();
        res->name = name->clone();
        res->generic_types = nil;
        res->conds = vec<ast_cond_compile*>::instance();
        res->is_public = false;
        res->is_extern = false;
        return res;
    }

    pub func copy(self) -> ast_struct_decl* {
        var res = ast_struct_decl::__alloc__();
        res->base = ast::instance(
            ast_kind::ast_struct_decl,
            self.base.location
        );
        res->fields = vec<ast_field_pair*>::instance();
        foreach (var i; self.fields) {
            res->fields.push(i.get()->copy());
        }
        res->name = self.name.clone();
        if (self.generic_types != nil) {
            res->generic_types = self.generic_types->copy();
        } else {
            res->generic_types = nil;
        }
        res->conds = vec<ast_cond_compile*>::instance();
        foreach (var i; self.conds) {
            res->conds.push(i.get()->copy());
        }
        res->is_public = self.is_public;
        res->is_extern = self.is_extern;
        return res;
    }

    pub func delete(self) {
        foreach (var i; self.fields) {
            var n = i.get() => ast*;
            n->delete();
            free(n => i8*);
        }
        self.fields.delete();
        foreach (var i; self.conds) {
            var n = i.get() => ast*;
            n->delete();
            free(n => i8*);
        }
        self.conds.delete();
        self.name.delete();
        if (self.generic_types != nil) {
            var n = self.generic_types => ast*;
            n->delete();
            free(n => i8*);
        }
    }

    pub func clear_generic_types(self) {
        if (self.generic_types == nil) {
            return;
        }
        var to_ast = self.generic_types => ast*;
        to_ast->delete();
        free(to_ast => i8*);
        self.generic_types = nil;
    }

    pub func set_conds(self, conds: vec<ast_cond_compile*>*) {
        foreach (var i; conds) {
            self.conds.push(i.get());
        }
    }
}

pub struct ast_tagged_union_decl {
    base: ast,
    members: vec<ast_field_pair*>,
    name: str,
    ref_enum_name: str,
    conds: vec<ast_cond_compile*>,
    is_public: bool,
    is_extern: bool
}

impl ast_tagged_union_decl {
    pub func new(loc: span&) -> ast_tagged_union_decl* {
        var res = ast_tagged_union_decl::__alloc__();
        res->base = ast::instance(ast_kind::ast_tagged_union_decl, loc);
        res->members = vec<ast_field_pair*>::instance();
        res->name = str::from("");
        res->ref_enum_name = str::from("");
        res->conds = vec<ast_cond_compile*>::instance();
        res->is_public = false;
        res->is_extern = false;
        return res;
    }

    pub func copy(self) -> ast_tagged_union_decl* {
        var res = ast_tagged_union_decl::__alloc__();
        res->base = ast::instance(
            ast_kind::ast_tagged_union_decl,
            self.base.location
        );
        res->members = vec<ast_field_pair*>::instance();
        foreach (var i; self.members) {
            res->members.push(i.get()->copy());
        }
        res->name = self.name.clone();
        res->ref_enum_name = self.ref_enum_name.clone();
        res->conds = vec<ast_cond_compile*>::instance();
        foreach (var i; self.conds) {
            res->conds.push(i.get()->copy());
        }
        res->is_public = self.is_public;
        res->is_extern = self.is_extern;
        return res;
    }

    pub func delete(self) {
        foreach (var i; self.members) {
            var n = i.get() => ast*;
            n->delete();
            free(n => i8*);
        }
        self.members.delete();
        foreach (var i; self.conds) {
            var n = i.get() => ast*;
            n->delete();
            free(n => i8*);
        }
        self.conds.delete();
        self.name.delete();
        self.ref_enum_name.delete();
    }

    pub func set_conds(self, conds: vec<ast_cond_compile*>*) {
        foreach (var i; conds) {
            self.conds.push(i.get());
        }
    }
}

pub struct ast_param {
    base: ast,
    name: ast_identifier*,
    type: ast_type_def*
}

impl ast_param {
    pub func new(loc: span&) -> ast_param* {
        var res = ast_param::__alloc__();
        res->base = ast::instance(ast_kind::ast_param, loc);
        res->name = nil;
        res->type = nil;
        return res;
    }

    pub func copy(self) -> ast_param* {
        var res = ast_param::__alloc__();
        res->base = ast::instance(
            ast_kind::ast_param,
            self.base.location
        );
        if (self.name != nil) {
            res->name = self.name->copy();
        } else {
            res->name = nil;
        }
        if (self.type != nil) {
            res->type = self.type->copy();
        } else {
            res->type = nil;
        }
        return res;
    }

    pub func delete(self) {
        if (self.name != nil) {
            var n = self.name => ast*;
            n->delete();
            free(n => i8*);
        }
        if (self.type != nil) {
            var n = self.type => ast*;
            n->delete();
            free(n => i8*);
        }
    }
}

pub struct ast_param_list {
    base: ast,
    params: vec<ast*>
}

impl ast_param_list {
    pub func new(loc: span&) -> ast_param_list* {
        var res = ast_param_list::__alloc__();
        res->base = ast::instance(ast_kind::ast_param_list, loc);
        res->params = vec<ast*>::instance();
        return res;
    }

    pub func copy(self) -> ast_param_list* {
        var res = ast_param_list::__alloc__();
        res->base = ast::instance(
            ast_kind::ast_param_list,
            self.base.location
        );
        res->params = vec<ast*>::instance();
        foreach (var i; self.params) {
            res->params.push(i.get()->copy());
        }
        return res;
    }

    pub func delete(self) {
        foreach (var i; self.params) {
            i.get()->delete();
            free(i.get() => i8*);
        }
        self.params.delete();
   }
}

pub struct ast_func_decl {
    base: ast,
    name: str,
    monomorphic_name: str,
    generic_types: ast_generic_type_list*,
    params: ast_param_list*,
    return_type: ast_type_def*,
    body: ast_code_block*,
    conds: vec<ast_cond_compile*>,
    is_public: bool,
    is_extern: bool
}

impl ast_func_decl {
    pub func new(loc: span&, name: str*) -> ast_func_decl* {
        var res = ast_func_decl::__alloc__();
        res->base = ast::instance(ast_kind::ast_func_decl, loc);
        res->name = name->clone();
        res->monomorphic_name = str::from("");
        res->generic_types = nil;
        res->params = nil;
        res->return_type = nil;
        res->body = nil;
        res->conds = vec<ast_cond_compile*>::instance();
        res->is_public = false;
        res->is_extern = false;
        return res;
    }

    pub func copy(self) -> ast_func_decl* {
        var res = ast_func_decl::__alloc__();
        res->base = ast::instance(
            ast_kind::ast_func_decl,
            self.base.location
        );
        res->name = self.name.clone();
        res->monomorphic_name = str::from("");
        if (self.generic_types != nil) {
            res->generic_types = self.generic_types->copy();
        } else {
            res->generic_types = nil;
        }
        if (self.params != nil) {
            res->params = self.params->copy();
        } else {
            res->params = nil;
        }
        if (self.return_type != nil) {
            res->return_type = self.return_type->copy();
        } else {
            res->return_type = nil;
        }
        if (self.body != nil) {
            res->body = self.body->copy();
        } else {
            res->body = nil;
        }
        res->conds = vec<ast_cond_compile*>::instance();
        foreach (var i; self.conds) {
            res->conds.push(i.get()->copy());
        }
        res->is_public = self.is_public;
        res->is_extern = self.is_extern;
        return res;
    }

    pub func delete(self) {
        self.name.delete();
        self.monomorphic_name.delete();
        if (self.generic_types != nil) {
            var n = self.generic_types => ast*;
            n->delete();
            free(n => i8*);
        }
        if (self.params != nil) {
            var n = self.params => ast*;
            n->delete();
            free(n => i8*);
        }
        if (self.return_type != nil) {
            var n = self.return_type => ast*;
            n->delete();
            free(n => i8*);
        }
        if (self.body != nil) {
            var n = self.body => ast*;
            n->delete();
            free(n => i8*);
        }
        foreach (var i; self.conds) {
            var n = i.get() => ast*;
            n->delete();
            free(n => i8*);
        }
        self.conds.delete();
    }

    pub func clear_generic_types(self) {
        if (self.generic_types == nil) {
            return;
        }
        var to_ast = self.generic_types => ast*;
        to_ast->delete();
        free(to_ast => i8*);
        self.generic_types = nil;
    }

    pub func set_conds(self, conds: vec<ast_cond_compile*>*) {
        foreach (var i; conds) {
            self.conds.push(i.get());
        }
    }

    pub func contain_cond(self) -> bool {
        foreach (var i; self.conds) {
            var c = i.get();
            if (c->cond_name.eq_const("is_trivial") ||
                c->cond_name.eq_const("is_non_trivial") ||
                c->cond_name.eq_const("is_pointer") ||
                c->cond_name.eq_const("is_non_pointer")) {
                return true;
            }
        }
        return false;
    }

    pub func get_trivial_cond(self) -> ast_cond_compile* {
        foreach (var i; self.conds) {
            var c = i.get();
            if (c->cond_name.eq_const("is_trivial")) {
                return c;
            }
        }
        return nil;
    }

    pub func get_non_trivial_cond(self) -> ast_cond_compile* {
        foreach (var i; self.conds) {
            var c = i.get();
            if (c->cond_name.eq_const("is_non_trivial")) {
                return c;
            }
        }
        return nil;
    }

    pub func get_is_pointer_cond(self) -> ast_cond_compile* {
        foreach (var i; self.conds) {
            var c = i.get();
            if (c->cond_name.eq_const("is_pointer")) {
                return c;
            }
        }
        return nil;
    }

    pub func get_is_non_pointer_cond(self) -> ast_cond_compile* {
        foreach (var i; self.conds) {
            var c = i.get();
            if (c->cond_name.eq_const("is_non_pointer")) {
                return c;
            }
        }
        return nil;
    }

    pub func get_monomorphic_name(self) -> str& {
        if (!self.monomorphic_name.empty()) {
            return self.monomorphic_name;
        }

        var trivial_cond = str::from("");
        defer trivial_cond.delete();

        var non_trivial_cond = str::from("");
        defer non_trivial_cond.delete();

        var is_pointer_cond = str::from("");
        defer is_pointer_cond.delete();

        var is_non_pointer_cond = str::from("");
        defer is_non_pointer_cond.delete();

        foreach (var i; self.conds) {
            var c = i.get();

            var tmp = c->get_text();
            defer tmp.delete();

            if (c->cond_name.eq_const("is_trivial")) {
                trivial_cond.append_str(tmp);
            } else if (c->cond_name.eq_const("is_non_trivial")) {
                non_trivial_cond.append_str(tmp);
            } else if (c->cond_name.eq_const("is_pointer")) {
                is_pointer_cond.append_str(tmp);
            } else if (c->cond_name.eq_const("is_non_pointer")) {
                is_non_pointer_cond.append_str(tmp);
            }
        }

        if (!trivial_cond.empty()) {
            self.monomorphic_name.append_str(trivial_cond);
            self.monomorphic_name.append_char(' ');
        }
        if (!non_trivial_cond.empty()) {
            self.monomorphic_name.append_str(non_trivial_cond);
            self.monomorphic_name.append_char(' ');
        }
        if (!is_pointer_cond.empty()) {
            self.monomorphic_name.append_str(is_pointer_cond);
            self.monomorphic_name.append_char(' ');
        }
        if (!is_non_pointer_cond.empty()) {
            self.monomorphic_name.append_str(is_non_pointer_cond);
            self.monomorphic_name.append_char(' ');
        }

        self.monomorphic_name.append_str(self.name);
        return self.monomorphic_name;
    }
}

pub struct ast_impl {
    base: ast,
    name: str,
    generic_types: ast_generic_type_list*,
    methods: vec<ast*>,
    conds: vec<ast_cond_compile*>
}

impl ast_impl {
    pub func new(loc: span&, name: str*) -> ast_impl* {
        var res = ast_impl::__alloc__();
        res->base = ast::instance(ast_kind::ast_impl, loc);
        res->name = name->clone();
        res->generic_types = nil;
        res->methods = vec<ast*>::instance();
        res->conds = vec<ast_cond_compile*>::instance();
        return res;
    }

    pub func copy(self) -> ast_impl* {
        var res = ast_impl::__alloc__();
        res->base = ast::instance(
            ast_kind::ast_impl,
            self.base.location
        );
        res->name = self.name.clone();
        if (self.generic_types != nil) {
            res->generic_types = self.generic_types->copy();
        } else {
            res->generic_types = nil;
        }
        res->methods = vec<ast*>::instance();
        foreach (var i; self.methods) {
            res->methods.push(i.get()->copy());
        }
        res->conds = vec<ast_cond_compile*>::instance();
        foreach (var i; self.conds) {
            res->conds.push(i.get()->copy());
        }
        return res;
    }

    pub func delete(self) {
        self.name.delete();
        if (self.generic_types != nil) {
            var n = self.generic_types => ast*;
            n->delete();
            free(n => i8*);
        }
        foreach (var i; self.methods) {
            i.get()->delete();
            free(i.get() => i8*);
        }
        self.methods.delete();
        foreach (var i; self.conds) {
            var n = i.get() => ast*;
            n->delete();
            free(n => i8*);
        }
        self.conds.delete();
    }

    pub func clear_generic_types(self) {
        if (self.generic_types == nil) {
            return;
        }
        var to_ast = self.generic_types => ast*;
        to_ast->delete();
        free(to_ast => i8*);
        self.generic_types = nil;
    }

    pub func set_conds(self, conds: vec<ast_cond_compile*>*) {
        foreach (var i; conds) {
            self.conds.push(i.get());
        }
    }

    pub func reset_methods(self, v: vec<ast*>*) {
        self.methods.clear();
        foreach (var i; v) {
            self.methods.push(i.get());
        }
    }
}

// statements

pub struct ast_use_stmt {
    base: ast,
    module_path: vec<ast*>,
    import_symbol: vec<ast*>
}

impl ast_use_stmt {
    pub func new(loc: span&) -> ast_use_stmt* {
        var res = ast_use_stmt::__alloc__();
        res->base = ast::instance(ast_kind::ast_use_stmt, loc);
        res->module_path = vec<ast*>::instance();
        res->import_symbol = vec<ast*>::instance();
        return res;
    }

    pub func copy(self) -> ast_use_stmt* {
        var res = ast_use_stmt::__alloc__();
        res->base = ast::instance(
            ast_kind::ast_use_stmt,
            self.base.location
        );
        res->module_path = vec<ast*>::instance();
        foreach (var i; self.module_path) {
            res->module_path.push(i.get()->copy());
        }
        res->import_symbol = vec<ast*>::instance();
        foreach (var i; self.import_symbol) {
            res->import_symbol.push(i.get()->copy());
        }
        return res;
    }

    pub func delete(self) {
        foreach (var i; self.module_path) {
            i.get()->delete();
            free(i.get() => i8*);
        }
        self.module_path.delete();
        foreach (var i; self.import_symbol) {
            i.get()->delete();
            free(i.get() => i8*);
        }
        self.import_symbol.delete();
    }
}

pub struct ast_definition {
    base: ast,
    name: str,
    type: ast_type_def*,
    value: ast*
}

impl ast_definition {
    pub func new(loc: span&, name: str*) -> ast_definition* {
        var res = ast_definition::__alloc__();
        res->base = ast::instance(ast_kind::ast_definition, loc);
        res->name = name->clone();
        res->type = nil;
        res->value = nil;
        return res;
    }

    pub func copy(self) -> ast_definition* {
        var res = ast_definition::__alloc__();
        res->base = ast::instance(
            ast_kind::ast_definition,
            self.base.location
        );
        res->name = self.name.clone();
        if (self.type != nil) {
            res->type = self.type->copy();
        } else {
            res->type = nil;
        }
        if (self.value != nil) {
            res->value = self.value->copy();
        } else {
            res->value = nil;
        }
        return res;
    }

    pub func delete(self) {
        self.name.delete();
        if (self.type != nil) {
            var n = self.type => ast*;
            n->delete();
            free(n => i8*);
        }
        if (self.value != nil) {
            self.value->delete();
            free(self.value => i8*);
        }
    }
}

pub struct ast_cond_stmt {
    base: ast,
    stmts: vec<ast*>
}

impl ast_cond_stmt {
    pub func new(loc: span&) -> ast_cond_stmt* {
        var res = ast_cond_stmt::__alloc__();
        res->base = ast::instance(ast_kind::ast_cond_stmt, loc);
        res->stmts = vec<ast*>::instance();
        return res;
    }

    pub func copy(self) -> ast_cond_stmt* {
        var res = ast_cond_stmt::__alloc__();
        res->base = ast::instance(
            ast_kind::ast_cond_stmt,
            self.base.location
        );
        res->stmts = vec<ast*>::instance();
        foreach (var i; self.stmts) {
            res->stmts.push(i.get()->copy());
        }
        return res;
    }

    pub func delete(self) {
        foreach (var i; self.stmts) {
            i.get()->delete();
            free(i.get() => i8*);
        }
        self.stmts.delete();
    }
}

pub struct ast_if_stmt {
    base: ast,
    condition: ast*,
    body: ast_code_block*
}

impl ast_if_stmt {
    pub func new(loc: span&) -> ast_if_stmt* {
        var res = ast_if_stmt::__alloc__();
        res->base = ast::instance(ast_kind::ast_if_stmt, loc);
        res->condition = nil;
        res->body = nil;
        return res;
    }

    pub func copy(self) -> ast_if_stmt* {
        var res = ast_if_stmt::__alloc__();
        res->base = ast::instance(
            ast_kind::ast_if_stmt,
            self.base.location
        );
        if (self.condition != nil) {
            res->condition = self.condition->copy();
        } else {
            res->condition = nil;
        }
        if (self.body != nil) {
            res->body = self.body->copy();
        } else {
            res->body = nil;
        }
        return res;
    }

    pub func delete(self) {
        if (self.condition != nil) {
            self.condition->delete();
            free(self.condition => i8*);
        }
        if (self.body != nil) {
            var n = self.body => ast*;
            n->delete();
            free(n => i8*);
        }
    }
}

pub struct ast_match_case {
    base: ast,
    pattern: ast_call*,
    body: ast_code_block*
}

impl ast_match_case {
    pub func new(loc: span&) -> ast_match_case* {
        var res = ast_match_case::__alloc__();
        res->base = ast::instance(ast_kind::ast_match_case, loc);
        res->pattern = nil;
        res->body = nil;
        return res;
    }

    pub func copy(self) -> ast_match_case* {
        var res = ast_match_case::__alloc__();
        res->base = ast::instance(
            ast_kind::ast_match_case,
            self.base.location
        );
        if (self.pattern != nil) {
            res->pattern = self.pattern->copy();
        } else {
            res->pattern = nil;
        }
        if (self.body != nil) {
            res->body = self.body->copy();
        } else {
            res->body = nil;
        }
        return res;
    }

    pub func delete(self) {
        if (self.pattern != nil) {
            var n = self.pattern => ast*;
            n->delete();
            free(n => i8*);
        }
        if (self.body != nil) {
            var n = self.body => ast*;
            n->delete();
            free(n => i8*);
        }
    }
}

pub struct ast_match_stmt {
    base: ast,
    value: ast*,
    cases: vec<ast*>
}

impl ast_match_stmt {
    pub func new(loc: span&) -> ast_match_stmt* {
        var res = ast_match_stmt::__alloc__();
        res->base = ast::instance(ast_kind::ast_match_stmt, loc);
        res->value = nil;
        res->cases = vec<ast*>::instance();
        return res;
    }

    pub func copy(self) -> ast_match_stmt* {
        var res = ast_match_stmt::__alloc__();
        res->base = ast::instance(
            ast_kind::ast_match_stmt,
            self.base.location
        );
        if (self.value != nil) {
            res->value = self.value->copy();
        } else {
            res->value = nil;
        }
        res->cases = vec<ast*>::instance();
        foreach (var i; self.cases) {
            res->cases.push(i.get()->copy());
        }
        return res;
    }

    pub func delete(self) {
        if (self.value != nil) {
            self.value->delete();
            free(self.value => i8*);
        }
        foreach (var i; self.cases) {
            i.get()->delete();
            free(i.get() => i8*);
        }
        self.cases.delete();
    }
}

pub struct ast_while_stmt {
    base: ast,
    condition: ast*,
    body: ast_code_block*
}

impl ast_while_stmt {
    pub func new(loc: span&) -> ast_while_stmt* {
        var res = ast_while_stmt::__alloc__();
        res->base = ast::instance(ast_kind::ast_while_stmt, loc);
        res->condition = nil;
        res->body = nil;
        return res;
    }

    pub func copy(self) -> ast_while_stmt* {
        var res = ast_while_stmt::__alloc__();
        res->base = ast::instance(
            ast_kind::ast_while_stmt,
            self.base.location
        );
        if (self.condition != nil) {
            res->condition = self.condition->copy();
        } else {
            res->condition = nil;
        }
        if (self.body != nil) {
            res->body = self.body->copy();
        } else {
            res->body = nil;
        }
        return res;
    }

    pub func delete(self) {
        if (self.condition != nil) {
            self.condition->delete();
            free(self.condition => i8*);
        }
        if (self.body != nil) {
            var n = self.body => ast*;
            n->delete();
            free(n => i8*);
        }
    }
}

pub struct ast_for_stmt {
    base: ast,
    init: ast_definition*,
    condition: ast*,
    update: ast*,
    body: ast_code_block*
}

impl ast_for_stmt {
    pub func new(loc: span&) -> ast_for_stmt* {
        var res = ast_for_stmt::__alloc__();
        res->base = ast::instance(ast_kind::ast_for_stmt, loc);
        res->init = nil;
        res->condition = nil;
        res->update = nil;
        res->body = nil;
        return res;
    }

    pub func copy(self) -> ast_for_stmt* {
        var res = ast_for_stmt::__alloc__();
        res->base = ast::instance(
            ast_kind::ast_for_stmt,
            self.base.location
        );
        if (self.init != nil) {
            res->init = self.init->copy();
        } else {
            res->init = nil;
        }
        if (self.condition != nil) {
            res->condition = self.condition->copy();
        } else {
            res->condition = nil;
        }
        if (self.update != nil) {
            res->update = self.update->copy();
        } else {
            res->update = nil;
        }
        if (self.body != nil) {
            res->body = self.body->copy();
        } else {
            res->body = nil;
        }
        return res;
    }

    pub func delete(self) {
        if (self.init != nil) {
            var n = self.init => ast*;
            n->delete();
            free(n => i8*);
        }
        if (self.condition != nil) {
            self.condition->delete();
            free(self.condition => i8*);
        }
        if (self.update != nil) {
            self.update->delete();
            free(self.update => i8*);
        }
        if (self.body != nil) {
            var n = self.body => ast*;
            n->delete();
            free(n => i8*);
        }
    }
}

pub struct ast_forindex {
    base: ast,
    variable: ast_identifier*,
    container: ast_call*,
    body: ast_code_block*,

    lowered_init: ast_definition*,
    lowered_condition: ast*,
    lowered_update: ast*
}

impl ast_forindex {
    pub func new(loc: span&) -> ast_forindex* {
        var res = ast_forindex::__alloc__();
        res->base = ast::instance(ast_kind::ast_forindex, loc);
        res->variable = nil;
        res->container = nil;
        res->body = nil;

        res->lowered_init = nil;
        res->lowered_condition = nil;
        res->lowered_update = nil;
        return res;
    }

    pub func copy(self) -> ast_forindex* {
        var res = ast_forindex::__alloc__();
        res->base = ast::instance(
            ast_kind::ast_forindex,
            self.base.location
        );
        if (self.variable != nil) {
            res->variable = self.variable->copy();
        } else {
            res->variable = nil;
        }
        if (self.container != nil) {
            res->container = self.container->copy();
        } else {
            res->container = nil;
        }
        if (self.body != nil) {
            res->body = self.body->copy();
        } else {
            res->body = nil;
        }

        if (self.lowered_init != nil) {
            res->lowered_init = self.lowered_init->copy();
        } else {
            res->lowered_init = nil;
        }
        if (self.lowered_condition != nil) {
            res->lowered_condition = self.lowered_condition->copy();
        } else {
            res->lowered_condition = nil;
        }
        if (self.lowered_update != nil) {
            res->lowered_update = self.lowered_update->copy();
        } else {
            res->lowered_update = nil;
        }
        return res;
    }

    pub func delete(self) {
        if (self.variable != nil) {
            var tmp = self.variable => ast*;
            tmp->delete();
            free(tmp => i8*);
        }
        if (self.container != nil) {
            var tmp = self.container => ast*;
            tmp->delete();
            free(tmp => i8*);
        }
        if (self.body != nil) {
            var tmp = self.body => ast*;
            tmp->delete();
            free(tmp => i8*);
        }

        if (self.lowered_init != nil) {
            var tmp = self.lowered_init => ast*;
            tmp->delete();
            free(tmp => i8*);
        }
        if (self.lowered_condition != nil) {
            self.lowered_condition->delete();
            free(self.lowered_condition => i8*);
        }
        if (self.lowered_update != nil) {
            self.lowered_update->delete();
            free(self.lowered_update => i8*);
        }
    }
}

pub struct ast_foreach {
    base: ast,
    variable: ast_identifier*,
    container: ast_call*,
    body: ast_code_block*,

    lowered_init: ast_definition*,
    lowered_condition: ast*,
    lowered_update: ast*
}

impl ast_foreach {
    pub func new(loc: span&) -> ast_foreach* {
        var res = ast_foreach::__alloc__();
        res->base = ast::instance(ast_kind::ast_foreach, loc);
        res->variable = nil;
        res->container = nil;
        res->body = nil;

        res->lowered_init = nil;
        res->lowered_condition = nil;
        res->lowered_update = nil;
        return res;
    }

    pub func copy(self) -> ast_foreach* {
        var res = ast_foreach::__alloc__();
        res->base = ast::instance(
            ast_kind::ast_foreach,
            self.base.location
        );
        if (self.variable != nil) {
            res->variable = self.variable->copy();
        } else {
            res->variable = nil;
        }
        if (self.container != nil) {
            res->container = self.container->copy();
        } else {
            res->container = nil;
        }
        if (self.body != nil) {
            res->body = self.body->copy();
        } else {
            res->body = nil;
        }

        if (self.lowered_init != nil) {
            res->lowered_init = self.lowered_init->copy();
        } else {
            res->lowered_init = nil;
        }
        if (self.lowered_condition != nil) {
            res->lowered_condition = self.lowered_condition->copy();
        } else {
            res->lowered_condition = nil;
        }
        if (self.lowered_update != nil) {
            res->lowered_update = self.lowered_update->copy();
        } else {
            res->lowered_update = nil;
        }
        return res;
    }

    pub func delete(self) {
        if (self.variable != nil) {
            var tmp = self.variable => ast*;
            tmp->delete();
            free(tmp => i8*);
        }
        if (self.container != nil) {
            var tmp = self.container => ast*;
            tmp->delete();
            free(tmp => i8*);
        }
        if (self.body != nil) {
            var tmp = self.body => ast*;
            tmp->delete();
            free(tmp => i8*);
        }

        if (self.lowered_init != nil) {
            var tmp = self.lowered_init => ast*;
            tmp->delete();
            free(tmp => i8*);
        }
        if (self.lowered_condition != nil) {
            self.lowered_condition->delete();
            free(self.lowered_condition => i8*);
        }
        if (self.lowered_update != nil) {
            self.lowered_update->delete();
            free(self.lowered_update => i8*);
        }
    }
}

pub struct ast_in_stmt_expr {
    base: ast,
    value: ast*
}

impl ast_in_stmt_expr {
    pub func new(loc: span&) -> ast_in_stmt_expr* {
        var res = ast_in_stmt_expr::__alloc__();
        res->base = ast::instance(ast_kind::ast_in_stmt_expr, loc);
        res->value = nil;
        return res;
    }

    pub func copy(self) -> ast_in_stmt_expr* {
        var res = ast_in_stmt_expr::__alloc__();
        res->base = ast::instance(
            ast_kind::ast_in_stmt_expr,
            self.base.location
        );
        if (self.value != nil) {
            res->value = self.value->copy();
        } else {
            res->value = nil;
        }
        return res;
    }

    pub func delete(self) {
        if (self.value != nil) {
            self.value->delete();
            free(self.value => i8*);
        }
    }
}

pub struct ast_defer_stmt {
    base: ast,
    block: ast_code_block*
}

impl ast_defer_stmt {
    pub func new(loc: span&) -> ast_defer_stmt* {
        var res = ast_defer_stmt::__alloc__();
        res->base = ast::instance(ast_kind::ast_defer_stmt, loc);
        res->block = nil;
        return res;
    }

    pub func copy(self) -> ast_defer_stmt* {
        var res = ast_defer_stmt::__alloc__();
        res->base = ast::instance(
            ast_kind::ast_defer_stmt,
            self.base.location
        );
        if (self.block != nil) {
            res->block = self.block->copy();
        } else {
            res->block = nil;
        }
        return res;
    }

    pub func delete(self) {
        if (self.block != nil) {
            var n = self.block => ast*;
            n->delete();
            free(n => i8*);
        }
    }
}

pub struct ast_ret_stmt {
    base: ast,
    value: ast*,
    return_ref_type: bool
}

impl ast_ret_stmt {
    pub func new(loc: span&) -> ast_ret_stmt* {
        var res = ast_ret_stmt::__alloc__();
        res->base = ast::instance(ast_kind::ast_ret_stmt, loc);
        res->value = nil;
        res->return_ref_type = false;
        return res;
    }

    pub func copy(self) -> ast_ret_stmt* {
        var res = ast_ret_stmt::__alloc__();
        res->base = ast::instance(
            ast_kind::ast_ret_stmt,
            self.base.location
        );
        if (self.value != nil) {
            res->value = self.value->copy();
        } else {
            res->value = nil;
        }
        res->return_ref_type = self.return_ref_type;
        return res;
    }

    pub func delete(self) {
        if (self.value != nil) {
            self.value->delete();
            free(self.value => i8*);
        }
    }
}

pub struct ast_continue_stmt { base: ast }

impl ast_continue_stmt {
    pub func new(loc: span&) -> ast_continue_stmt* {
        var res = ast_continue_stmt::__alloc__();
        res->base = ast::instance(ast_kind::ast_continue_stmt, loc);
        return res;
    }

    pub func copy(self) -> ast_continue_stmt* {
        var res = ast_continue_stmt::__alloc__();
        res->base = ast::instance(
            ast_kind::ast_continue_stmt,
            self.base.location
        );
        return res;
    }
}

pub struct ast_break_stmt { base: ast }

impl ast_break_stmt {
    pub func new(loc: span&) -> ast_break_stmt* {
        var res = ast_break_stmt::__alloc__();
        res->base = ast::instance(ast_kind::ast_break_stmt, loc);
        return res;
    }

    pub func copy(self) -> ast_break_stmt* {
        var res = ast_break_stmt::__alloc__();
        res->base = ast::instance(
            ast_kind::ast_break_stmt,
            self.base.location
        );
        return res;
    }
}

pub struct ast_code_block {
    base: ast,
    stmts: vec<ast*>
}

impl ast_code_block {
    pub func new(loc: span&) -> ast_code_block* {
        var res = ast_code_block::__alloc__();
        res->base = ast::instance(ast_kind::ast_code_block, loc);
        res->stmts = vec<ast*>::instance();
        return res;
    }

    pub func copy(self) -> ast_code_block* {
        var res = ast_code_block::__alloc__();
        res->base = ast::instance(
            ast_kind::ast_code_block,
            self.base.location
        );
        res->stmts = vec<ast*>::instance();
        foreach (var i; self.stmts) {
            res->stmts.push(i.get()->copy());
        }
        return res;
    }

    pub func delete(self) {
        foreach (var i; self.stmts) {
            i.get()->delete();
            free(i.get() => i8*);
        }
        self.stmts.delete();
    }

    pub func reset_stmt_with(self, v: vec<ast*>*) {
        self.stmts.clear();
        foreach (var i; v) {
            self.stmts.push(i.get());
        }
    }

    pub func back_is_not_block_exit(self) -> bool {
        if (self.stmts.empty()) {
            return true;
        }
        var back = self.stmts.back();
        return back->kind != ast_kind::ast_ret_stmt &&
               back->kind != ast_kind::ast_break_stmt &&
               back->kind != ast_kind::ast_continue_stmt;
    }
}
