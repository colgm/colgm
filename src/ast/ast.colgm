use err::span::{ span };
use std::libc::{ malloc, realloc, free, exit };
use std::io::{ io };
use std::str::{ str };

enum ast_kind {
    ast_null,
    ast_root,
    ast_unary_operator,
    ast_binary_operator,
    ast_type_convert,
    ast_identifier,
    ast_nil_literal,
    ast_number_literal,
    ast_string_literal,
    ast_char_literal,
    ast_bool_literal,
    ast_call_index,
    ast_call_func_args,
    ast_get_field,
    ast_ptr_get_field,
    ast_init_pair,
    ast_initializer,
    ast_call_path,
    ast_call,
    ast_assignment,
    ast_type_def,
    ast_enum_decl,
    ast_struct_field,
    ast_struct_decl,
    ast_param,
    ast_param_list,
    ast_func_decl,
    ast_impl,
    ast_use_stmt,
    ast_definition,
    ast_cond_stmt,
    ast_if_stmt,
    ast_match_case,
    ast_match_stmt,
    ast_while_stmt,
    ast_for_stmt,
    ast_in_stmt_expr,
    ast_ret_stmt,
    ast_continue_stmt,
    ast_break_stmt,
    ast_code_block
}

struct ast {
    kind: ast_kind, # ast node kind
    location: span* # location of ast node
}

impl ast {
    func instance(k: ast_kind, loc: span*) -> ast {
        return ast {
            kind: k,
            location: loc
        };
    }

    func delete(self) {
        self->location->delete();
        free(self->location => i8*);
    }
}

struct ptr_vec {
    data: i8**,
    size: u64,
    capacity: u64
}

impl ptr_vec {
    func init(self) {
        var ptr_size = 8 => u64; # now we only support 64bit
        self->size = 0 => u64;
        self->capacity = 256 => u64;
        self->data = malloc(self->capacity * ptr_size) => i8**;
    }

    func delete(self) {
        self->size = 0 => u64;
        self->capacity = 0 => u64;
        free(self->data => i8*);
    }

    func expand(self) {
        var ptr_size = 8 => u64;
        self->capacity *= 2 => u64;
        self->data = realloc(
            self->data => i8*,
            self->capacity * ptr_size
        ) => i8**;
    }

    func push(self, item: i8*) {
        if (self->size == self->capacity) {
            self->expand();
        }
        self->data[self->size] = item;
        self->size += 1 => u64;
    }

    func back(self) -> i8* {
        if (self->size == 0 => u64) {
            return nil;
        }
        return self->data[self->size - 1 => u64];
    }

    func pop(self) {
        if (self->size == 0 => u64) {
            return;
        }
        self->size -= 1 => u64;
    }
}

struct root {
    base: ast,
    imports: ptr_vec,
    decls: ptr_vec
}

impl root {
    func new(loc: span*) -> root* {
        var res = root::__alloc__();
        res->init(loc);
        return res;
    }

    func init(self, loc: span*) {
        self->base = ast::instance(ast_kind::ast_root, loc);
        self->imports.init();
        self->decls.init();
    }

    func delete(self) {
        self->base.delete();
        self->imports.delete();
        self->decls.delete();
    }
}

# expressions

struct ast_unary_operator {
    base: ast
}

struct ast_binary_operator {
    base: ast
}

struct ast_type_convert {
    base: ast
}

struct ast_identifier {
    base: ast,
    name: str
}

impl ast_identifier {
    func new(loc: span*, name: str*) -> ast_identifier* {
        var res = ast_identifier::__alloc__();
        res->base = ast::instance(ast_kind::ast_identifier, loc);
        res->name = name->copy_instance();
        return res;
    }
}

struct ast_nil_literal {
    base: ast
}

struct ast_number_literal {
    base: ast
}

struct ast_string_literal {
    base: ast
}

struct ast_char_literal {
    base: ast
}

struct ast_bool_literal {
    base: ast
}

struct ast_call_index {
    base: ast
}

struct ast_call_func_args {
    base: ast
}

struct ast_get_field {
    base: ast
}

struct ast_ptr_get_field {
    base: ast
}

struct ast_init_pair {
    base: ast
}

struct ast_initializer {
    base: ast
}

struct ast_call_path {
    base: ast
}

struct ast_call {
    base: ast
}

struct ast_assignment {
    base: ast
}

# declarations

struct ast_type_def {
    base: ast
}

struct ast_enum_decl {
    base: ast
}

struct ast_struct_field {
    base: ast
}

struct ast_struct_decl {
    base: ast
}

struct ast_param {
    base: ast
}

struct ast_param_list {
    base: ast
}

struct ast_func_decl {
    base: ast
}

struct ast_impl {
    base: ast
}

# statements

struct ast_use_stmt {
    base: ast,
    module_path: ptr_vec,
    import_symbol: ptr_vec
}

impl ast_use_stmt {
    func new(loc: span*) -> ast_use_stmt* {
        var res = ast_use_stmt::__alloc__();
        res->base = ast::instance(ast_kind::ast_use_stmt, loc);
        res->module_path.init();
        res->import_symbol.init();
        return res;
    }
}

struct ast_definition {
    base: ast
}

struct ast_cond_stmt {
    base: ast
}

struct ast_if_stmt {
    base: ast
}

struct ast_match_case {
    base: ast
}

struct ast_match_stmt {
    base: ast
}

struct ast_while_stmt {
    base: ast
}

struct ast_for_stmt {
    base: ast
}

struct ast_in_stmt_expr {
    base: ast
}

struct ast_ret_stmt {
    base: ast
}

struct ast_continue_stmt {
    base: ast
}

struct ast_break_stmt {
    base: ast
}

struct ast_code_block {
    base: ast
}
