use err::span::{ span };
use std::libc::{ malloc, realloc, free, exit };
use std::io::{ io };
use std::str::{ str };

enum ast_kind {
    ast_null,
    ast_root,
    ast_unary_operator,
    ast_binary_operator,
    ast_type_convert,
    ast_identifier,
    ast_nil_literal,
    ast_number_literal,
    ast_string_literal,
    ast_char_literal,
    ast_bool_literal,
    ast_call_index,
    ast_call_func_args,
    ast_get_field,
    ast_ptr_get_field,
    ast_init_pair,
    ast_initializer,
    ast_call_path,
    ast_call,
    ast_assignment,
    ast_type_def,
    ast_enum_member,
    ast_enum_decl,
    ast_struct_field,
    ast_struct_decl,
    ast_param,
    ast_param_list,
    ast_func_decl,
    ast_impl,
    ast_use_stmt,
    ast_definition,
    ast_cond_stmt,
    ast_if_stmt,
    ast_match_case,
    ast_match_stmt,
    ast_while_stmt,
    ast_for_stmt,
    ast_in_stmt_expr,
    ast_ret_stmt,
    ast_continue_stmt,
    ast_break_stmt,
    ast_code_block
}

enum unary_kind {
    neg,
    bnot,
    lnot
}

enum binary_kind {
    add,
    sub,
    mult,
    div,
    rem,
    cmpeq,
    cmpneq,
    less,
    leq,
    grt,
    geq,
    cmpand,
    cmpor,
    band,
    bor,
    bxor
}

enum assignment_kind {
    eq,
    addeq,
    subeq,
    multeq,
    diveq,
    remeq,
    andeq,
    xoreq,
    oreq
}

struct ast {
    kind: ast_kind, # ast node kind
    location: span* # location of ast node
}

impl ast {
    func instance(k: ast_kind, loc: span*) -> ast {
        return ast {
            kind: k,
            location: loc
        };
    }

    func delete(self) {
        io::stderr().out("free ast ").out_i64(self => i64).endln();
        self->location->delete();
        free(self->location => i8*);
    }
}

struct ptr_vec {
    data: ast**,
    size: u64,
    capacity: u64
}

impl ptr_vec {
    func init(self) {
        var ptr_size = 8 => u64; # now we only support 64bit
        self->size = 0 => u64;
        self->capacity = 256 => u64;
        self->data = malloc(self->capacity * ptr_size) => ast**;
    }

    func delete(self) {
        self->size = 0 => u64;
        self->capacity = 0 => u64;
        for (var i = 0 => u64; i < self->size; i += 1 => u64) {
            self->data[i]->delete();
            free(self->data[i] => i8*);
        }
        free(self->data => i8*);
    }

    func expand(self) {
        var ptr_size = 8 => u64;
        self->capacity *= 2 => u64;
        self->data = realloc(
            self->data => i8*,
            self->capacity * ptr_size
        ) => ast**;
    }

    func push(self, item: ast*) {
        if (self->size == self->capacity) {
            self->expand();
        }
        self->data[self->size] = item;
        self->size += 1 => u64;
    }

    func back(self) -> ast* {
        if (self->size == 0 => u64) {
            return nil => ast*;
        }
        return self->data[self->size - 1 => u64];
    }

    func pop(self) {
        if (self->size == 0 => u64) {
            return;
        }
        self->size -= 1 => u64;
    }
}

struct root {
    base: ast,
    imports: ptr_vec,
    decls: ptr_vec
}

impl root {
    func new(loc: span*) -> root* {
        var res = root::__alloc__();
        res->base = ast::instance(ast_kind::ast_root, loc);
        res->imports.init();
        res->decls.init();
        return res;
    }

    func delete(self) {
        self->base.delete();
        self->imports.delete();
        self->decls.delete();
    }
}

# expressions

struct ast_unary_operator {
    base: ast,
    kind: unary_kind,
    value: ast*
}

impl ast_unary_operator {
    func new(loc: span*, kind: unary_kind) -> ast_unary_operator* {
        var res = ast_unary_operator::__alloc__();
        res->base = ast::instance(ast_kind::ast_unary_operator, loc);
        res->kind = kind;
        res->value = nil => ast*;
        return res;
    }

    func delete(self) {
        self->base.delete();
        if (self->value => i8* != nil) {
            self->value->delete();
        }
    }
}

struct ast_binary_operator {
    base: ast,
    kind: binary_kind,
    left: ast*,
    right: ast*
}

impl ast_binary_operator {
    func new(loc: span*, kind: binary_kind) -> ast_binary_operator* {
        var res = ast_binary_operator::__alloc__();
        res->base = ast::instance(ast_kind::ast_binary_operator, loc);
        res->kind = kind;
        res->left = nil => ast*;
        res->right = nil => ast*;
        return res;
    }

    func delete(self) {
        self->base.delete();
        if (self->left => i8* != nil) {
            self->left->delete();
        }
        if (self->right => i8* != nil) {
            self->right->delete();
        }
    }
}

struct ast_type_convert {
    base: ast,
    from: ast*,
    to: ast_type_def*
}

impl ast_type_convert {
    func new(loc: span*) -> ast_type_convert* {
        var res = ast_type_convert::__alloc__();
        res->base = ast::instance(ast_kind::ast_type_convert, loc);
        res->from = nil => ast*;
        res->to = nil => ast_type_def*;
        return res;
    }

    func delete(self) {
        self->base.delete();
        if (self->from => i8* != nil) {
            self->from->delete();
        }
        if (self->to => i8* != nil) {
            self->to->delete();
        }
    }
}

struct ast_identifier {
    base: ast,
    name: str
}

impl ast_identifier {
    func new(loc: span*, name: str*) -> ast_identifier* {
        var res = ast_identifier::__alloc__();
        res->base = ast::instance(ast_kind::ast_identifier, loc);
        res->name = name->copy_instance();
        return res;
    }

    func delete(self) {
        self->base.delete();
        self->name.delete();
    }
}

struct ast_nil_literal {
    base: ast
}

impl ast_nil_literal {
    func new(loc: span*) -> ast_nil_literal* {
        var res = ast_nil_literal::__alloc__();
        res->base = ast::instance(ast_kind::ast_nil_literal, loc);
        return res;
    }

    func delete(self) {
        self->base.delete();
    }
}

struct ast_number_literal {
    base: ast,
    literal: str
}

impl ast_number_literal {
    func new(loc: span*, literal: str*) -> ast_number_literal* {
        var res = ast_number_literal::__alloc__();
        res->base = ast::instance(ast_kind::ast_number_literal, loc);
        res->literal = literal->copy_instance();
        return res;
    }

    func delete(self) {
        self->base.delete();
        self->literal.delete();
    }
}

struct ast_string_literal {
    base: ast,
    literal: str
}

impl ast_string_literal {
    func new(loc: span*, literal: str*) -> ast_string_literal* {
        var res = ast_string_literal::__alloc__();
        res->base = ast::instance(ast_kind::ast_string_literal, loc);
        res->literal = literal->copy_instance();
        return res;
    }

    func delete(self) {
        self->base.delete();
        self->literal.delete();
    }
}

struct ast_char_literal {
    base: ast,
    literal: i8
}

impl ast_char_literal {
    func new(loc: span*, literal: i8) -> ast_char_literal* {
        var res = ast_char_literal::__alloc__();
        res->base = ast::instance(ast_kind::ast_char_literal, loc);
        res->literal = literal;
        return res;
    }

    func delete(self) {
        self->base.delete();
    }
}

struct ast_bool_literal {
    base: ast,
    flag: bool
}

impl ast_bool_literal {
    func new(loc: span*, flag: bool) -> ast_bool_literal* {
        var res = ast_bool_literal::__alloc__();
        res->base = ast::instance(ast_kind::ast_bool_literal, loc);
        res->flag = flag;
        return res;
    }

    func delete(self) {
        self->base.delete();
    }
}

struct ast_call_index {
    base: ast,
    index: ast*
}

impl ast_call_index {
    func new(loc: span*) -> ast_call_index* {
        var res = ast_call_index::__alloc__();
        res->base = ast::instance(ast_kind::ast_call_index, loc);
        res->index = nil => ast*;
        return res;
    }

    func delete(self) {
        self->base.delete();
        if (self->index => i8* != nil) {
            self->index->delete();
        }
    }
}

struct ast_call_func_args {
    base: ast,
    args: ptr_vec
}

impl ast_call_func_args {
    func new(loc: span*) -> ast_call_func_args* {
        var res = ast_call_func_args::__alloc__();
        res->base = ast::instance(ast_kind::ast_call_func_args, loc);
        res->args.init();
        return res;
    }

    func delete(self) {
        self->base.delete();
        self->args.delete();
    }
}

struct ast_get_field {
    base: ast,
    name: str
}

impl ast_get_field {
    func new(loc: span*, name: str*) -> ast_get_field* {
        var res = ast_get_field::__alloc__();
        res->base = ast::instance(ast_kind::ast_get_field, loc);
        res->name = name->copy_instance();
        return res;
    }

    func delete(self) {
        self->base.delete();
        self->name.delete();
    }
}

struct ast_ptr_get_field {
    base: ast,
    name: str
}

impl ast_ptr_get_field {
    func new(loc: span*, name: str*) -> ast_ptr_get_field* {
        var res = ast_ptr_get_field::__alloc__();
        res->base = ast::instance(ast_kind::ast_ptr_get_field, loc);
        res->name = name->copy_instance();
        return res;
    }

    func delete(self) {
        self->base.delete();
        self->name.delete();
    }
}

struct ast_init_pair {
    base: ast,
    field: ast_identifier*,
    value: ast*
}

impl ast_init_pair {
    func new(loc: span*) -> ast_init_pair* {
        var res = ast_init_pair::__alloc__();
        res->base = ast::instance(ast_kind::ast_init_pair, loc);
        res->field = nil => ast_identifier*;
        res->value = nil => ast*;
        return res;
    }

    func delete(self) {
        self->base.delete();
        if (self->field => i8* != nil) {
            self->field->delete();
        }
        if (self->value => i8* != nil) {
            self->value->delete();
        }
    }
}

struct ast_initializer {
    base: ast,
    pairs: ptr_vec
}

impl ast_initializer {
    func new(loc: span*) -> ast_initializer* {
        var res = ast_initializer::__alloc__();
        res->base = ast::instance(ast_kind::ast_initializer, loc);
        res->pairs.init();
        return res;
    }

    func delete(self) {
        self->base.delete();
        self->pairs.delete();
    }
}

struct ast_call_path {
    base: ast,
    name: str
}

impl ast_call_path {
    func new(loc: span*, name: str*) -> ast_call_path* {
        var res = ast_call_path::__alloc__();
        res->base = ast::instance(ast_kind::ast_call_path, loc);
        res->name = name->copy_instance();
        return res;
    }

    func delete(self) {
        self->base.delete();
        self->name.delete();
    }
}

struct ast_call {
    base: ast,
    head: ast_identifier*,
    chain: ptr_vec
}

impl ast_call {
    func new(loc: span*) -> ast_call* {
        var res = ast_call::__alloc__();
        res->base = ast::instance(ast_kind::ast_call, loc);
        res->head = nil => ast_identifier*;
        res->chain.init();
        return res;
    }

    func delete(self) {
        self->base.delete();
        if(self->head => i8* != nil) {
            self->head->delete();
        }
        self->chain.delete();
    }
}

struct ast_assignment {
    base: ast,
    kind: assignment_kind,
    left: ast_call*,
    right: ast*
}

impl ast_assignment {
    func new(loc: span*) -> ast_assignment* {
        var res = ast_assignment::__alloc__();
        res->base = ast::instance(ast_kind::ast_assignment, loc);
        res->left = nil => ast_call*;
        res->right = nil => ast*;
        return res;
    }

    func delete(self) {
        self->base.delete();
        if (self->left => i8* != nil) {
            self->left->delete();
        }
        if (self->right => i8* != nil) {
            self->right->delete();
        }
    }
}

# declarations

struct ast_type_def {
    base: ast,
    name: ast_identifier*,
    pointer_depth: i64
}

impl ast_type_def {
    func new(loc: span*) -> ast_type_def* {
        var res = ast_type_def::__alloc__();
        res->base = ast::instance(ast_kind::ast_type_def, loc);
        res->name = nil => ast_identifier*;
        res->pointer_depth = 0;
        return res;
    }

    func delete(self) {
        self->base.delete();
        if (self->name => i8* != nil) {
            self->name->delete();
        }
    }
}

struct ast_enum_member {
    base: ast,
    name: ast_identifier*,
    value: ast_number_literal*
}

impl ast_enum_member {
    func new(loc: span*) -> ast_enum_member* {
        var res = ast_enum_member::__alloc__();
        res->base = ast::instance(ast_kind::ast_enum_member, loc);
        res->name = nil => ast_identifier*;
        res->value = nil => ast_number_literal*;
        return res;
    }

    func delete(self) {
        self->base.delete();
        if (self->name => i8* != nil) {
            self->name->delete();
        }
        if (self->value => i8* != nil) {
            self->value->delete();
        }
    }
}

struct ast_enum_decl {
    base: ast,
    members: ptr_vec,
    name: str
}

impl ast_enum_decl {
    func new(loc: span*, name: str*) -> ast_enum_decl* {
        var res = ast_enum_decl::__alloc__();
        res->base = ast::instance(ast_kind::ast_enum_decl, loc);
        res->members.init();
        res->name = name->copy_instance();
        return res;
    }

    func delete(self) {
       self->base.delete();
       self->members.delete();
       self->name.delete();
    }
}

struct ast_struct_field {
    base: ast,
    name: ast_identifier*,
    type: ast_type_def*
}

impl ast_struct_field {
    func new(loc: span*) -> ast_struct_field* {
        var res = ast_struct_field::__alloc__();
        res->base = ast::instance(ast_kind::ast_struct_field, loc);
        res->name = nil => ast_identifier*;
        res->type = nil => ast_type_def*;
        return res;
    }

    func delete(self) {
        self->base.delete();
        if (self->name => i8* != nil) {
            self->name->delete();
        }
        if (self->type => i8* != nil) {
            self->type->delete();
        }
    }
}

struct ast_struct_decl {
    base: ast,
    fields: ptr_vec,
    name: str
}

impl ast_struct_decl {
    func new(loc: span*, name: str*) -> ast_struct_decl* {
        var res = ast_struct_decl::__alloc__();
        res->base = ast::instance(ast_kind::ast_struct_decl, loc);
        res->fields.init();
        res->name = name->copy_instance();
        return res;
    }

    func delete(self) {
        self->base.delete();
        self->fields.delete();
        self->name.delete();
    }
}

struct ast_param {
    base: ast,
    name: ast_identifier*,
    type: ast_type_def*
}

impl ast_param {
    func new(loc: span*) -> ast_param* {
        var res = ast_param::__alloc__();
        res->base = ast::instance(ast_kind::ast_param, loc);
        res->name = nil => ast_identifier*;
        res->type = nil => ast_type_def*;
        return res;
    }

    func delete(self) {
        self->base.delete();
        if (self->name => i8* != nil) {
            self->name->delete();
        }
        if (self->type => i8* != nil) {
            self->type->delete();
        }
    }
}

struct ast_param_list {
    base: ast,
    params: ptr_vec
}

impl ast_param_list {
    func new(loc: span*) -> ast_param_list* {
        var res = ast_param_list::__alloc__();
        res->base = ast::instance(ast_kind::ast_param_list, loc);
        res->params.init();
        return res;
    }

    func delete(self) {
        self->base.delete();
        self->params.delete();
   }
}

struct ast_func_decl {
    base: ast,
    name: str,
    params: ast_param_list*,
    return_type: ast_type_def*,
    body: ast_code_block*
}

impl ast_func_decl {
    func new(loc: span*, name: str*) -> ast_func_decl* {
        var res = ast_func_decl::__alloc__();
        res->base = ast::instance(ast_kind::ast_func_decl, loc);
        res->name = name->copy_instance();
        res->params = nil => ast_param_list*;
        res->return_type = nil => ast_type_def*;
        res->body = nil => ast_code_block*;
        return res;
    }

    func delete(self) {
        self->base.delete();
        self->name.delete();
        if (self->params => i8* != nil) {
            self->params->delete();
        }
        if (self->return_type => i8* != nil) {
            self->return_type->delete();
        }
        if (self->body => i8* != nil) {
            self->body->delete();
        }
    }
}

struct ast_impl {
    base: ast,
    name: str,
    methods: ptr_vec
}

impl ast_impl {
    func new(loc: span*, name: str*) -> ast_impl* {
        var res = ast_impl::__alloc__();
        res->base = ast::instance(ast_kind::ast_impl, loc);
        res->name = name->copy_instance();
        res->methods.init();
        return res;
    }

    func delete(self) {
        self->base.delete();
        self->name.delete();
    }
}

# statements

struct ast_use_stmt {
    base: ast,
    module_path: ptr_vec,
    import_symbol: ptr_vec
}

impl ast_use_stmt {
    func new(loc: span*) -> ast_use_stmt* {
        var res = ast_use_stmt::__alloc__();
        res->base = ast::instance(ast_kind::ast_use_stmt, loc);
        res->module_path.init();
        res->import_symbol.init();
        return res;
    }
}

struct ast_definition {
    base: ast,
    name: str,
    type: ast_type_def*,
    value: ast*
}

impl ast_definition {
    func new(loc: span*, name: str*) -> ast_definition* {
        var res = ast_definition::__alloc__();
        res->base = ast::instance(ast_kind::ast_definition, loc);
        res->name = name->copy_instance();
        res->type = nil => ast_type_def*;
        res->value = nil => ast*;
        return res;
    }

    func delete(self) {
        self->base.delete();
        self->name.delete();
        if (self->type => i8* != nil) {
            self->type->delete();
        }
        if (self->value => i8* != nil) {
            self->value->delete();
        }
    }
}

struct ast_cond_stmt {
    base: ast,
    stmts: ptr_vec
}

impl ast_cond_stmt {
    func new(loc: span*) -> ast_cond_stmt* {
        var res = ast_cond_stmt::__alloc__();
        res->base = ast::instance(ast_kind::ast_cond_stmt, loc);
        res->stmts.init();
        return res;
    }

    func delete(self) {
        self->base.delete();
        self->stmts.delete();
    }
}

struct ast_if_stmt {
    base: ast,
    condition: ast*,
    body: ast_code_block*
}

impl ast_if_stmt {
    func new(loc: span*) -> ast_if_stmt* {
        var res = ast_if_stmt::__alloc__();
        res->base = ast::instance(ast_kind::ast_if_stmt, loc);
        res->condition = nil => ast*;
        res->body = nil => ast_code_block*;
        return res;
    }

    func delete(self) {
        self->base.delete();
        if (self->condition => i8* != nil) {
            self->condition->delete();
        }
        if (self->body => i8* != nil) {
            self->body->delete();
        }
    }
}

struct ast_match_case {
    base: ast,
    pattern: ast*,
    body: ast_code_block*
}

impl ast_match_case {
    func new(loc: span*) -> ast_match_case* {
        var res = ast_match_case::__alloc__();
        res->base = ast::instance(ast_kind::ast_match_case, loc);
        res->pattern = nil => ast*;
        res->body = nil => ast_code_block*;
        return res;
    }

    func delete(self) {
        self->base.delete();
        if (self->pattern => i8* != nil) {
            self->pattern->delete();
        }
        if (self->body => i8* != nil) {
            self->body->delete();
        }
    }
}

struct ast_match_stmt {
    base: ast,
    value: ast*,
    cases: ptr_vec
}

impl ast_match_stmt {
    func new(loc: span*) -> ast_match_stmt* {
        var res = ast_match_stmt::__alloc__();
        res->base = ast::instance(ast_kind::ast_match_stmt, loc);
        res->value = nil => ast*;
        res->cases.init();
        return res;
    }

    func delete(self) {
        self->base.delete();
        self->value->delete();
        self->cases.delete();
    }
}

struct ast_while_stmt {
    base: ast,
    condition: ast*,
    body: ast_code_block*
}

impl ast_while_stmt {
    func new(loc: span*) -> ast_while_stmt* {
        var res = ast_while_stmt::__alloc__();
        res->base = ast::instance(ast_kind::ast_while_stmt, loc);
        res->condition = nil => ast*;
        res->body = nil => ast_code_block*;
        return res;
    }

    func delete(self) {
        self->base.delete();
        if (self->condition => i8* != nil) {
            self->condition->delete();
        }
        if (self->body => i8* != nil) {
            self->body->delete();
        }
    }
}

struct ast_for_stmt {
    base: ast,
    init: ast_definition*,
    condition: ast*,
    update: ast*,
    body: ast_code_block*
}

impl ast_for_stmt {
    func new(loc: span*) -> ast_for_stmt* {
        var res = ast_for_stmt::__alloc__();
        res->base = ast::instance(ast_kind::ast_for_stmt, loc);
        res->init = nil => ast_definition*;
        res->condition = nil => ast*;
        res->update = nil => ast*;
        res->body = nil => ast_code_block*;
        return res;
    }

    func delete(self) {
        self->base.delete();
        if (self->init => i8* != nil) {
            self->init->delete();
        }
        if (self->condition => i8* != nil) {
            self->condition->delete();
        }
        if (self->update => i8* != nil) {
            self->update->delete();
        }
        if (self->body => i8* !=nil) {
            self->body->delete();
        }
    }
}

struct ast_in_stmt_expr {
    base: ast,
    value: ast*
}

impl ast_in_stmt_expr {
    func new(loc: span*) -> ast_in_stmt_expr* {
        var res = ast_in_stmt_expr::__alloc__();
        res->base = ast::instance(ast_kind::ast_in_stmt_expr, loc);
        res->value = nil => ast*;
        return res;
    }

    func delete(self) {
        self->base.delete();
        if (self->value => i8* != nil) {
            self->value->delete();
        }
    }
}

struct ast_ret_stmt {
    base: ast,
    value: ast*
}

impl ast_ret_stmt {
    func new(loc: span*) -> ast_ret_stmt* {
        var res = ast_ret_stmt::__alloc__();
        res->base = ast::instance(ast_kind::ast_ret_stmt, loc);
        res->value = nil => ast*;
        return res;
    }

    func delete(self) {
        self->base.delete();
        if (self->value => i8* != nil) {
            self->value->delete();
        }
    }
}

struct ast_continue_stmt { base: ast }

impl ast_continue_stmt {
    func new(loc: span*) -> ast_continue_stmt* {
        var res = ast_continue_stmt::__alloc__();
        res->base = ast::instance(ast_kind::ast_continue_stmt, loc);
        return res;
    }

    func delete(self) {
        self->base.delete();
    }
}

struct ast_break_stmt { base: ast }

impl ast_break_stmt {
    func new(loc: span*) -> ast_break_stmt* {
        var res = ast_break_stmt::__alloc__();
        res->base = ast::instance(ast_kind::ast_break_stmt, loc);
        return res;
    }

    func delete(self) {
        self->base.delete();
    }
}

struct ast_code_block {
    base: ast,
    stmts: ptr_vec
}

impl ast_code_block {
    func new(loc: span*) -> ast_code_block* {
        var res = ast_code_block::__alloc__();
        res->base = ast::instance(ast_kind::ast_code_block, loc);
        res->stmts.init();
        return res;
    }

    func delete(self) {
        self->base.delete();
        self->stmts.delete();
    }
}
