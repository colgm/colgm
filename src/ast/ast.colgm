use err::span::{ span };
use std::libc::{ malloc, realloc, free, exit };
use std::io::{ io };
use std::str::{ str };

enum ast_kind {
    ast_null,
    ast_root,
    ast_unary_operator,
    ast_binary_operator,
    ast_type_convert,
    ast_identifier,
    ast_nil_literal,
    ast_number_literal,
    ast_string_literal,
    ast_char_literal,
    ast_bool_literal,
    ast_call_index,
    ast_call_func_args,
    ast_get_field,
    ast_ptr_get_field,
    ast_init_pair,
    ast_initializer,
    ast_call_path,
    ast_call,
    ast_assignment,
    ast_type_def,
    ast_enum_member,
    ast_enum_decl,
    ast_struct_field,
    ast_struct_decl,
    ast_param,
    ast_param_list,
    ast_func_decl,
    ast_impl,
    ast_use_stmt,
    ast_definition,
    ast_cond_stmt,
    ast_if_stmt,
    ast_match_case,
    ast_match_stmt,
    ast_while_stmt,
    ast_for_stmt,
    ast_in_stmt_expr,
    ast_ret_stmt,
    ast_continue_stmt,
    ast_break_stmt,
    ast_code_block
}

struct ast {
    kind: ast_kind, # ast node kind
    location: span* # location of ast node
}

impl ast {
    func instance(k: ast_kind, loc: span*) -> ast {
        return ast {
            kind: k,
            location: loc
        };
    }

    func delete(self) {
        io::stderr().out("free ast ").out_i64(self => i64).endln();
        self->location->delete();
        free(self->location => i8*);
    }
}

struct ptr_vec {
    data: ast**,
    size: u64,
    capacity: u64
}

impl ptr_vec {
    func init(self) {
        var ptr_size = 8 => u64; # now we only support 64bit
        self->size = 0 => u64;
        self->capacity = 256 => u64;
        self->data = malloc(self->capacity * ptr_size) => ast**;
    }

    func delete(self) {
        self->size = 0 => u64;
        self->capacity = 0 => u64;
        for (var i = 0 => u64; i < self->size; i += 1 => u64) {
            self->data[i]->delete();
            free(self->data[i] => i8*);
        }
        free(self->data => i8*);
    }

    func expand(self) {
        var ptr_size = 8 => u64;
        self->capacity *= 2 => u64;
        self->data = realloc(
            self->data => i8*,
            self->capacity * ptr_size
        ) => ast**;
    }

    func push(self, item: ast*) {
        if (self->size == self->capacity) {
            self->expand();
        }
        self->data[self->size] = item;
        self->size += 1 => u64;
    }

    func back(self) -> ast* {
        if (self->size == 0 => u64) {
            return nil => ast*;
        }
        return self->data[self->size - 1 => u64];
    }

    func pop(self) {
        if (self->size == 0 => u64) {
            return;
        }
        self->size -= 1 => u64;
    }
}

struct root {
    base: ast,
    imports: ptr_vec,
    decls: ptr_vec
}

impl root {
    func new(loc: span*) -> root* {
        var res = root::__alloc__();
        res->base = ast::instance(ast_kind::ast_root, loc);
        res->imports.init();
        res->decls.init();
        return res;
    }

    func delete(self) {
        self->base.delete();
        self->imports.delete();
        self->decls.delete();
    }
}

# expressions

struct ast_unary_operator {
    base: ast
}

struct ast_binary_operator {
    base: ast
}

struct ast_type_convert {
    base: ast
}

struct ast_identifier {
    base: ast,
    name: str
}

impl ast_identifier {
    func new(loc: span*, name: str*) -> ast_identifier* {
        var res = ast_identifier::__alloc__();
        res->base = ast::instance(ast_kind::ast_identifier, loc);
        res->name = name->copy_instance();
        return res;
    }

    func delete(self) {
        self->base.delete();
        self->name.delete();
    }
}

struct ast_nil_literal {
    base: ast
}

impl ast_nil_literal {
    func new(loc: span*) -> ast_nil_literal* {
        var res = ast_nil_literal::__alloc__();
        res->base = ast::instance(ast_kind::ast_nil_literal, loc);
        return res;
    }

    func delete(self) {
        self->base.delete();
    }
}

struct ast_number_literal {
    base: ast,
    literal: str
}

impl ast_number_literal {
    func new(loc: span*, literal: str*) -> ast_number_literal* {
        var res = ast_number_literal::__alloc__();
        res->base = ast::instance(ast_kind::ast_number_literal, loc);
        res->literal = literal->copy_instance();
        return res;
    }

    func delete(self) {
        self->base.delete();
        self->literal.delete();
    }
}

struct ast_string_literal {
    base: ast,
    literal: str
}

impl ast_string_literal {
    func new(loc: span*, literal: str*) -> ast_string_literal* {
        var res = ast_string_literal::__alloc__();
        res->base = ast::instance(ast_kind::ast_string_literal, loc);
        res->literal = literal->copy_instance();
        return res;
    }

    func delete(self) {
        self->base.delete();
        self->literal.delete();
    }
}

struct ast_char_literal {
    base: ast,
    literal: i8
}

impl ast_char_literal {
    func new(loc: span*, literal: i8) -> ast_char_literal* {
        var res = ast_char_literal::__alloc__();
        res->base = ast::instance(ast_kind::ast_char_literal, loc);
        res->literal = literal;
        return res;
    }

    func delete(self) {
        self->base.delete();
    }
}

struct ast_bool_literal {
    base: ast,
    flag: bool
}

impl ast_bool_literal {
    func new(loc: span*, flag: bool) -> ast_bool_literal* {
        var res = ast_bool_literal::__alloc__();
        res->base = ast::instance(ast_kind::ast_bool_literal, loc);
        res->flag = flag;
        return res;
    }

    func delete(self) {
        self->base.delete();
    }
}

struct ast_call_index {
    base: ast
}

struct ast_call_func_args {
    base: ast
}

struct ast_get_field {
    base: ast
}

struct ast_ptr_get_field {
    base: ast
}

struct ast_init_pair {
    base: ast
}

struct ast_initializer {
    base: ast
}

struct ast_call_path {
    base: ast
}

struct ast_call {
    base: ast
}

struct ast_assignment {
    base: ast
}

# declarations

struct ast_type_def {
    base: ast,
    name: ast_identifier*,
    pointer_depth: i64
}

impl ast_type_def {
    func new(loc: span*) -> ast_type_def* {
        var res = ast_type_def::__alloc__();
        res->base = ast::instance(ast_kind::ast_type_def, loc);
        res->name = nil => ast_identifier*;
        res->pointer_depth = 0;
        return res;
    }

    func delete(self) {
        self->base.delete();
        if (self->name => i8* != nil) {
            self->name->delete();
        }
    }
}

struct ast_enum_member {
    base: ast,
    name: ast_identifier*,
    value: ast_number_literal*
}

impl ast_enum_member {
    func new(loc: span*) -> ast_enum_member* {
        var res = ast_enum_member::__alloc__();
        res->base = ast::instance(ast_kind::ast_enum_member, loc);
        res->name = nil => ast_identifier*;
        res->value = nil => ast_number_literal*;
        return res;
    }

    func delete(self) {
        self->base.delete();
        if (self->name => i8* != nil) {
            self->name->delete();
        }
        if (self->value => i8* != nil) {
            self->value->delete();
        }
    }
}

struct ast_enum_decl {
    base: ast,
    members: ptr_vec,
    name: str
}

impl ast_enum_decl {
    func new(loc: span*, name: str*) -> ast_enum_decl* {
        var res = ast_enum_decl::__alloc__();
        res->base = ast::instance(ast_kind::ast_enum_decl, loc);
        res->members.init();
        res->name = name->copy_instance();
        return res;
    }

    func delete(self) {
       self->base.delete();
       self->members.delete();
       self->name.delete();
    }
}

struct ast_struct_field {
    base: ast,
    name: ast_identifier*,
    type: ast_type_def*
}

impl ast_struct_field {
    func new(loc: span*) -> ast_struct_field* {
        var res = ast_struct_field::__alloc__();
        res->base = ast::instance(ast_kind::ast_struct_field, loc);
        res->name = nil => ast_identifier*;
        res->type = nil => ast_type_def*;
        return res;
    }

    func delete(self) {
        self->base.delete();
        if (self->name => i8* != nil) {
            self->name->delete();
        }
        if (self->type => i8* != nil) {
            self->type->delete();
        }
    }
}

struct ast_struct_decl {
    base: ast,
    fields: ptr_vec,
    name: str
}

impl ast_struct_decl {
    func new(loc: span*, name: str*) -> ast_struct_decl* {
        var res = ast_struct_decl::__alloc__();
        res->base = ast::instance(ast_kind::ast_struct_decl, loc);
        res->fields.init();
        res->name = name->copy_instance();
        return res;
    }

    func delete(self) {
        self->base.delete();
        self->fields.delete();
        self->name.delete();
    }
}

struct ast_param {
    base: ast,
    name: ast_identifier*,
    type: ast_type_def*
}

impl ast_param {
    func new(loc: span*) -> ast_param* {
        var res = ast_param::__alloc__();
        res->base = ast::instance(ast_kind::ast_param, loc);
        res->name = nil => ast_identifier*;
        res->type = nil => ast_type_def*;
        return res;
    }

    func delete(self) {
        self->base.delete();
        if (self->name => i8* != nil) {
            self->name->delete();
        }
        if (self->type => i8* != nil) {
            self->type->delete();
        }
    }
}

struct ast_param_list {
    base: ast,
    params: ptr_vec
}

impl ast_param_list {
    func new(loc: span*) -> ast_param_list* {
        var res = ast_param_list::__alloc__();
        res->base = ast::instance(ast_kind::ast_param_list, loc);
        res->params.init();
        return res;
    }

    func delete(self) {
        self->base.delete();
        self->params.delete();
   }
}

struct ast_func_decl {
    base: ast,
    name: str,
    params: ast_param_list*,
    return_type: ast_type_def*,
    body: ast_code_block*
}

impl ast_func_decl {
    func new(loc: span*, name: str*) -> ast_func_decl* {
        var res = ast_func_decl::__alloc__();
        res->base = ast::instance(ast_kind::ast_func_decl, loc);
        res->name = name->copy_instance();
        res->params = nil => ast_param_list*;
        res->return_type = nil => ast_type_def*;
        res->body = nil => ast_code_block*;
        return res;
    }

    func delete(self) {
        self->base.delete();
        self->name.delete();
        if (self->params => i8* != nil) {
            self->params->delete();
        }
        if (self->return_type => i8* != nil) {
            self->return_type->delete();
        }
        if (self->body => i8* != nil) {
            self->body->delete();
        }
    }
}

struct ast_impl {
    base: ast
}

# statements

struct ast_use_stmt {
    base: ast,
    module_path: ptr_vec,
    import_symbol: ptr_vec
}

impl ast_use_stmt {
    func new(loc: span*) -> ast_use_stmt* {
        var res = ast_use_stmt::__alloc__();
        res->base = ast::instance(ast_kind::ast_use_stmt, loc);
        res->module_path.init();
        res->import_symbol.init();
        return res;
    }
}

struct ast_definition {
    base: ast
}

struct ast_cond_stmt {
    base: ast
}

struct ast_if_stmt {
    base: ast
}

struct ast_match_case {
    base: ast
}

struct ast_match_stmt {
    base: ast
}

struct ast_while_stmt {
    base: ast
}

struct ast_for_stmt {
    base: ast
}

struct ast_in_stmt_expr {
    base: ast
}

struct ast_ret_stmt {
    base: ast
}

struct ast_continue_stmt {
    base: ast
}

struct ast_break_stmt {
    base: ast
}

struct ast_code_block {
    base: ast,
    stmts: ptr_vec
}

impl ast_code_block {
    func new(loc: span*) -> ast_code_block* {
        var res = ast_code_block::__alloc__();
        res->base = ast::instance(ast_kind::ast_code_block, loc);
        res->stmts.init();
        return res;
    }

    func delete(self) {
        self->base.delete();
        self->stmts.delete();
    }
}
