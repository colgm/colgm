use err::report::{ report };
use err::span::{ span };

use ast::ast::*;
use util::cli::{ cli_option };
use util::package::{ package };

use std::str::{ str };
use std::map::{ hashmap };
use std::io::{ io };
use std::vec::{ vec };
use std::ptr::{ ptr };
use std::libc::{ free };

use sema::type::{ type };
use sema::generic_data::{ generic_data };
use sema::symbol_info::{ symbol_kind, symbol_info };
use sema::context::{ sema_context };
use sema::type_resolve::{ type_resolve };
use sema::function::{ colgm_func };
use sema::structure::{ colgm_struct };
use sema::module::{ colgm_module };
use sema::type_replace::{ type_replace_pass };

pub struct generic_visitor {
    err: report*,
    pkg: package*,
    ctx: sema_context*,
    root: root*,
    tr: type_resolve,
    co: cli_option*,
    generic_type_map: hashmap<str, generic_data>,
    // avoid too deep template instantiation
    visit_count: u64,
    MAX_RECURSIVE_DEPTH: u64
}

impl generic_visitor {
    pub func instance(e: report*,
                      c: sema_context*,
                      p: package*,
                      co: cli_option*) -> generic_visitor {
        return generic_visitor {
            err: e,
            pkg: p,
            ctx: c,
            root: nil,
            tr: type_resolve::instance(e, c, p),
            co: co,
            generic_type_map: hashmap<str, generic_data>::instance(),
            visit_count: 0,
            MAX_RECURSIVE_DEPTH: 16
        };
    }

    pub func delete(self) {
        self->generic_type_map.delete();
    }

    func report_recursive_generic_generation(self) {
        var info_head = str::from("template instantiation depth exceeds maximum of ");
        info_head.append_u64(self->MAX_RECURSIVE_DEPTH);
        info_head.append_i8_vec(":\n");

        foreach (var i; self->generic_type_map) {
            var gd = i.value();
            var generic_name = gd->generic_type.generic_name(self->pkg);
            
            var domain_file = gd->generic_type.loc_file.__ptr__();
            if (!self->ctx->has_domain(domain_file)) {
                generic_name.delete();
                continue;
            }

            var dm = self->ctx->get_domain(domain_file);
            if (dm->structs.has(generic_name.__ptr__()) ||
                dm->functions.has(generic_name.__ptr__())) {
                generic_name.delete();
                continue;
            }

            var loc: span* = nil;
            if (dm->generic_structs.has(gd->generic_type.name.__ptr__())) {
                loc = dm->generic_structs
                        .get(gd->generic_type.name.__ptr__())
                        ->location.__ptr__();
            } else if (dm->generic_functions.has(gd->generic_type.name.__ptr__())) {
                loc = dm->generic_functions
                        .get(gd->generic_type.name.__ptr__())
                        ->location.__ptr__();
            }

            var info = info_head.copy_instance();
            info.append_i8_vec("  --> ");
            info.append_str(generic_name.__ptr__());
            self->err->error(loc, info.c_str);

            generic_name.delete();
            info.delete();
        }

        info_head.delete();
    }

    pub func scan_and_insert(self, n: root*) {
        self->root = n;
        self->visit_count = 0;

        var scan_count = 0;
        self->generic_type_map.clear();
        self->visit_root(n);
        while (self->insert_into_symbol_table() != 0) {
            scan_count += 1;
            self->generic_type_map.clear();
            self->visit_root(n);
        }

        if (scan_count > 0 && self->co->VIEW_TYPE_REPLACE_INFO) {
            io::stdout().out("[generic_visitor] generate generics of ")
                        .white().out(n->base.location.file.c_str).reset()
                        .out(" after ").out_i64(scan_count).out(" scan(s)")
                        .endln();
        }
    }
}

impl generic_visitor {
    func check_generic_exists(self, dm: colgm_module*, type_name: str*, n: ast*) -> bool {
        // check this symbol exists
        if (!dm->global_symbol.has(type_name) &&
            !dm->generic_symbol.has(type_name)) {
            var info = str::from("unknown type \"");
            info.append_str(type_name)->append_i8_vec("\"");
            self->err->error(n->location.__ptr__(), info.c_str);
            info.delete();
            return false;
        }

        // check this symbol is generic type
        if (!dm->generic_symbol.has(type_name)) {
            var info = str::from("\"");
            info.append_str(type_name);
            info.append_i8_vec("\" is not a generic type");
            self->err->error(n->location.__ptr__(), info.c_str);
            info.delete();
            return false;
        }

        return true;
    }

    func scan_generic_type(self, n: ast_type_def*) {
        var type_name = n->name->content.__ptr__();
        var domain_file: str* = nil;
        if (n->base.is_redirected()) {
            domain_file = n->base.redirect_location.__ptr__();
        } else {
            domain_file = n->base.location.file.__ptr__();
        }

        var dm = self->ctx->get_domain(domain_file);
        if (!self->check_generic_exists(dm, type_name, n => ast*)) {
            return;
        }

        var sym = dm->generic_symbol.get(type_name);
        if (sym->kind != symbol_kind::struct_kind) {
            var info = str::from("\"");
            info.append_str(type_name);
            info.append_i8_vec("\" is not a struct type");
            self->err->error(n->base.location.__ptr__(), info.c_str);
            info.delete();
            return;
        }

        var sym_belonged_dm = self->ctx->get_domain(sym->loc_file.__ptr__());
        var generic_struct = sym_belonged_dm->generic_structs.get(type_name);
        var generic_template = generic_struct->generic_template.__ptr__();
        self->check_generic_type(n => ast*,
                                 type_name,
                                 sym,
                                 n->generic_types,
                                 generic_template);
    }

    func check_generic_type(self,
                            n: ast*,
                            type_name: str*,
                            sym: symbol_info*,
                            type_list_node: ast_generic_type_list*,
                            generic_template: vec<str>*) {
        var type_list = type_list_node->types.__ptr__();
        // check size match
        if (type_list->size != generic_template->size) {
            self->err->error(n->location.__ptr__(),
                "generic type count does not match"
            );
            return;
        }

        var ss = str::from("");
        ss.append_str(type_name)->append_char('<');
        foreach (var i; type_list) {
            var r_type = self->tr.resolve(i.get().unwrap() => ast_type_def*);
            var r_type_fpn = r_type.full_path_name(self->pkg, true);
            ss.append_str(r_type_fpn.__ptr__());
            r_type_fpn.delete();
            if (i.index() != type_list->size - 1) {
                ss.append_char(',');
            }
            r_type.delete();
        }
        ss.append_char('>');
        if (self->err->error_count > 0) {
            ss.delete();
            return;
        }

        // insert data, use symbols location file to avoid duplication of name
        var unique_name = sym->loc_file.copy_instance();
        unique_name.append_i8_vec("|")->append_str(ss.__ptr__());
        if (self->generic_type_map.has(unique_name.__ptr__())) {
            ss.delete();
            unique_name.delete();
            return;
        }

        // load useful data into generic_data
        var g_data = generic_data::instance();
        g_data.name.append_str(ss.__ptr__());
        g_data.generic_type.name.append_str(type_name);
        g_data.generic_type.loc_file.append_str(sym->loc_file.__ptr__());

        foreach (var i; type_list) {
            var r_type = self->tr.resolve(i.get().unwrap() => ast_type_def*);
            g_data.generic_type.generics.push(r_type.__ptr__());
            g_data.types.insert(generic_template->get(i.index()), r_type.__ptr__());
        }

        self->generic_type_map.insert(unique_name.__ptr__(), g_data.__ptr__());

        ss.delete();
        unique_name.delete();
        g_data.delete();
        return;
    }
}

impl generic_visitor {
    func visit_ast(self, n: ast*) {
        match (n->kind) {
            ast_kind::ast_unary_operator =>
                self->visit_unary_operator(n => ast_unary_operator*);
            ast_kind::ast_binary_operator =>
                self->visit_binary_operator(n => ast_binary_operator*);
            ast_kind::ast_type_convert =>
                self->visit_type_convert(n => ast_type_convert*);
            ast_kind::ast_array_list =>
                self->visit_array_list(n => ast_array_list*);
            ast_kind::ast_call_index =>
                self->visit_call_index(n => ast_call_index*);
            ast_kind::ast_call_func_args =>
                self->visit_call_func_args(n => ast_call_func_args*);
            ast_kind::ast_init_pair =>
                self->visit_init_pair(n => ast_init_pair*);
            ast_kind::ast_initializer =>
                self->visit_initializer(n => ast_initializer*);
            ast_kind::ast_call_id =>
                self->visit_call_id(n => ast_call_id*);
            ast_kind::ast_call => self->visit_call(n => ast_call*);
            ast_kind::ast_assignment =>
                self->visit_assignment(n => ast_assignment*);
            ast_kind::ast_type_def =>
                self->visit_type_def(n => ast_type_def*);
            ast_kind::ast_generic_type_list =>
                self->visit_generic_type_list(n => ast_generic_type_list*);
            ast_kind::ast_struct_field =>
                self->visit_struct_field(n => ast_struct_field*);
            ast_kind::ast_struct_decl =>
                self->visit_struct_decl(n => ast_struct_decl*);
            ast_kind::ast_param =>
                self->visit_param(n => ast_param*);
            ast_kind::ast_param_list =>
                self->visit_param_list(n => ast_param_list*);
            ast_kind::ast_func_decl => 
                self->visit_func_decl(n => ast_func_decl*);
            ast_kind::ast_impl =>
                self->visit_impl(n => ast_impl*);
            ast_kind::ast_definition =>
                self->visit_definition(n => ast_definition*);
            ast_kind::ast_cond_stmt =>
                self->visit_cond_stmt(n => ast_cond_stmt*);
            ast_kind::ast_if_stmt =>
                self->visit_if_stmt(n => ast_if_stmt*);
            ast_kind::ast_match_case =>
                self->visit_match_case(n => ast_match_case*);
            ast_kind::ast_match_stmt =>
                self->visit_match_stmt(n => ast_match_stmt*);
            ast_kind::ast_while_stmt =>
                self->visit_while_stmt(n => ast_while_stmt*);
            ast_kind::ast_for_stmt =>
                self->visit_for_stmt(n => ast_for_stmt*);
            ast_kind::ast_forindex =>
                self->visit_forindex(n => ast_forindex*);
            ast_kind::ast_foreach =>
                self->visit_foreach(n => ast_foreach*);
            ast_kind::ast_in_stmt_expr =>
                self->visit_in_stmt_expr(n => ast_in_stmt_expr*);
            ast_kind::ast_ret_stmt =>
                self->visit_ret_stmt(n => ast_ret_stmt*);
            ast_kind::ast_code_block =>
                self->visit_code_block(n => ast_code_block*);
            _ => {}
        }
    }
}

impl generic_visitor {
    func visit_root(self, n: root*) {
        foreach (var i; n->decls) {
            var d = i.get().unwrap();
            match (d->kind) {
                ast_kind::ast_struct_decl => {
                    self->visit_struct_decl(d => ast_struct_decl*);
                }
                ast_kind::ast_func_decl => {
                    self->visit_func_decl(d => ast_func_decl*);
                }
                ast_kind::ast_impl => {
                    self->visit_impl(d => ast_impl*);
                }
                _ => {}
            }
        }
    }

    func visit_struct_decl(self, n: ast_struct_decl*) {
        if (n->generic_types != nil) {
            return;
        }
        foreach (var i; n->fields) {
            var f = i.get().unwrap();
            if (!f->is(ast_kind::ast_struct_field)) {
                continue;
            }
            self->visit_struct_field(f => ast_struct_field*);
        }
    }

    func visit_func_decl(self, n: ast_func_decl*) {
        if (n->generic_types != nil) {
            return;
        }
        self->visit_param_list(n->params);
        if (n->return_type != nil) {
            self->visit_type_def(n->return_type);
        }
        if (n->body != nil) {
            self->visit_code_block(n->body);
        }
    }

    func visit_impl(self, n: ast_impl*) {
        if (n->generic_types != nil) {
            return;
        }
        foreach (var i; n->methods) {
            var f = i.get().unwrap();
            if (!f->is(ast_kind::ast_func_decl)) {
                continue;
            }
            self->visit_func_decl(f => ast_func_decl*);
        }
    }

    func visit_unary_operator(self, n: ast_unary_operator*) {
        self->visit_ast(n->value);
    }

    func visit_binary_operator(self, n: ast_binary_operator*) {
        self->visit_ast(n->left);
        self->visit_ast(n->right);
    }

    func visit_type_convert(self, n: ast_type_convert*) {
        self->visit_ast(n->from);
        self->visit_type_def(n->to);
    }

    func visit_array_list(self, n: ast_array_list*) {
        foreach (var i; n->value) {
            self->visit_ast(i.get().unwrap());
        }
    }

    func visit_call_index(self, n: ast_call_index*) {
        self->visit_ast(n->index);
    }

    func visit_call_func_args(self, n: ast_call_func_args*) {
        foreach (var i; n->args) {
            self->visit_ast(i.get().unwrap());
        }
    }

    func visit_init_pair(self, n: ast_init_pair*) {
        self->visit_ast(n->value);
    }

    func visit_initializer(self, n: ast_initializer*) {
        foreach (var i; n->pairs) {
            self->visit_ast(i.get().unwrap());
        }
    }

    func visit_call_id(self, n: ast_call_id*) {
        if (n->generic_types == nil) {
            return;
        }
        self->visit_generic_type_list(n->generic_types);

        var type_name = n->id->content.__ptr__();
        var domain_file: str* = nil;
        if (n->base.is_redirected()) {
            domain_file = n->base.redirect_location.__ptr__();
        } else {
            domain_file = n->base.location.file.__ptr__();
        }

        var dm = self->ctx->get_domain(domain_file);
        if (!self->check_generic_exists(dm, type_name, n => ast*)) {
            return;
        }

        var sym = dm->generic_symbol.get(type_name);
        if (sym->kind != symbol_kind::struct_kind &&
            sym->kind != symbol_kind::func_kind) {
            var info = str::from("\"");
            info.append_str(type_name);
            info.append_i8_vec("\" is not a struct type");
            self->err->error(n->base.location.__ptr__(), info.c_str);
            info.delete();
            return;
        }

        var sym_belonged_dm = self->ctx->get_domain(sym->loc_file.__ptr__());
        var generic_template: vec<str>* = nil;
        if (sym->kind == symbol_kind::struct_kind) {
            var generic_struct = sym_belonged_dm->generic_structs.get(type_name);
            generic_template = generic_struct->generic_template.__ptr__();
        } else {
            var generic_func = sym_belonged_dm->generic_functions.get(type_name);
            generic_template = generic_func->generic_template.__ptr__();
        }
        self->check_generic_type(n => ast*,
                                 type_name,
                                 sym,
                                 n->generic_types,
                                 generic_template);
    }

    func visit_call(self, n: ast_call*) {
        self->visit_call_id(n->head);
        foreach (var i; n->chain) {
            self->visit_ast(i.get().unwrap());
        }
    }

    func visit_assignment(self, n: ast_assignment*) {
        self->visit_call(n->left);
        self->visit_ast(n->right);
    }

    func visit_type_def(self, n: ast_type_def*) {
        if (n->generic_types != nil) {
            self->visit_generic_type_list(n->generic_types);
            self->scan_generic_type(n);
        }
    }

    func visit_generic_type_list(self, n: ast_generic_type_list*) {
        foreach (var i; n->types) {
            self->visit_ast(i.get().unwrap());
        }
    }

    func visit_struct_field(self, n: ast_struct_field*) {
        self->visit_type_def(n->type);
    }

    func visit_param(self, n: ast_param*) {
        if (n->type != nil) {
            self->visit_type_def(n->type);
        }
    }

    func visit_param_list(self, n: ast_param_list*) {
        foreach (var i; n->params) {
            self->visit_ast(i.get().unwrap());
        }
    }

    func visit_definition(self, n: ast_definition*) {
        if (n->type != nil) {
            self->visit_type_def(n->type);
        }
        self->visit_ast(n->value);
    }

    func visit_cond_stmt(self, n: ast_cond_stmt*) {
        foreach (var i; n->stmts) {
            self->visit_ast(i.get().unwrap());
        }
    }

    func visit_if_stmt(self, n: ast_if_stmt*) {
        if (n->condition != nil) {
            self->visit_ast(n->condition);
        }
        if (n->body != nil) {
            self->visit_code_block(n->body);
        }
    }

    func visit_match_case(self, n: ast_match_case*) {
        self->visit_call(n->pattern);
        if (n->body != nil) {
            self->visit_code_block(n->body);
        }
    }

    func visit_match_stmt(self, n: ast_match_stmt*) {
        self->visit_ast(n->value);
        foreach (var i; n->cases) {
            self->visit_ast(i.get().unwrap());
        }
    }

    func visit_while_stmt(self, n: ast_while_stmt*) {
        if (n->condition != nil) {
            self->visit_ast(n->condition);
        }
        if (n->body != nil) {
            self->visit_code_block(n->body);
        }
    }

    func visit_for_stmt(self, n: ast_for_stmt*) {
        if (n->init != nil) {
            self->visit_definition(n->init);
        }
        if (n->condition != nil) {
            self->visit_ast(n->condition);
        }
        if (n->update != nil) {
            self->visit_ast(n->update);
        }
        if (n->body != nil) {
            self->visit_code_block(n->body);
        }
    }

    func visit_forindex(self, n: ast_forindex*) {
        if (n->variable != nil) {
            self->visit_ast(n->variable => ast*);
        }
        if (n->container != nil) {
            self->visit_call(n->container);
        }
        if (n->body != nil) {
            self->visit_code_block(n->body);
        }

        if (n->lowered_init != nil) {
            self->visit_definition(n->lowered_init);
        }
        if (n->lowered_condition != nil) {
            self->visit_ast(n->lowered_condition);
        }
        if (n->lowered_update != nil) {
            self->visit_ast(n->lowered_update);
        }
    }

    func visit_foreach(self, n: ast_foreach*) {
        if (n->variable != nil) {
            self->visit_ast(n->variable => ast*);
        }
        if (n->container != nil) {
            self->visit_call(n->container);
        }
        if (n->body != nil) {
            self->visit_code_block(n->body);
        }

        if (n->lowered_init != nil) {
            self->visit_definition(n->lowered_init);
        }
        if (n->lowered_condition != nil) {
            self->visit_ast(n->lowered_condition);
        }
        if (n->lowered_update != nil) {
            self->visit_ast(n->lowered_update);
        }
    }

    func visit_in_stmt_expr(self, n: ast_in_stmt_expr*) {
        self->visit_ast(n->value);
    }

    func visit_ret_stmt(self, n: ast_ret_stmt*) {
        if (n->value != nil) {
            self->visit_ast(n->value);
        }
    }

    func visit_code_block(self, n: ast_code_block*) {
        foreach (var i; n->stmts) {
            self->visit_ast(i.get().unwrap());
        }
    }
}

impl generic_visitor {
    func insert_struct(self, dm: colgm_module*, gd: generic_data*, gn: str*) {
        if (dm->structs.has(gn)) {
            return;
        }

        var struct_info = dm->generic_structs.get(gd->generic_type.name.__ptr__())->copy();
        struct_info->name.clear();
        struct_info->name.append_str(gn);
        struct_info->generic_template.clear();
        dm->structs.insert(gn, struct_info);

        var sym_info = symbol_info::instance(
            symbol_kind::struct_kind,
            struct_info->location.file.c_str,
            struct_info->is_public,
        );
        self->ctx->global_symbol()->insert(gn, sym_info.__ptr__());
        sym_info.delete();

        self->replace_struct_type(dm->structs.get(gn), gd);

        struct_info->delete();
        free(struct_info => i8*);
    }

    func insert_function(self, dm: colgm_module*, gd: generic_data*, gn: str*) {
        if (dm->functions.has(gn)) {
            return;
        }

        var func_info = dm->generic_functions.get(gd->generic_type.name.__ptr__())->copy();
        func_info->name.clear();
        func_info->name.append_str(gn);
        func_info->generic_template.clear();
        dm->functions.insert(gn, func_info);

        var sym_info = symbol_info::instance(
            symbol_kind::func_kind,
            func_info->location.file.c_str,
            func_info->is_public
        );
        self->ctx->global_symbol()->insert(gn, sym_info.__ptr__());
        sym_info.delete();

        self->replace_func_type(dm->functions.get(gn), gd);

        func_info->delete();
        free(func_info => i8*);
    }

    func insert_into_symbol_table(self) -> u64 {
        self->visit_count += 1;
        if (self->visit_count > self->MAX_RECURSIVE_DEPTH) {
            self->report_recursive_generic_generation();
            return 0;
        }
        var insert_count: u64 = 0;
        foreach (var i; self->generic_type_map) {
            var g_data = i.value();
            var generic_name = g_data->generic_type.generic_name(self->pkg);
            
            var domain_file = g_data->generic_type.loc_file.__ptr__();
            if (!self->ctx->has_domain(domain_file)) {
                generic_name.delete();
                continue;
            }

            var dm = self->ctx->get_domain(domain_file);
            if (dm->generic_structs.has(g_data->generic_type.name.__ptr__())) {
                if (dm->structs.has(generic_name.__ptr__())) {
                    continue;
                }
                insert_count += 1;
                self->insert_struct(dm, g_data, generic_name.__ptr__());
            } else if (dm->generic_functions.has(g_data->generic_type.name.__ptr__())) {
                if (dm->functions.has(generic_name.__ptr__())) {
                    continue;
                }
                insert_count += 1;
                self->insert_function(dm, g_data, generic_name.__ptr__());
            }

            generic_name.delete();
        }
        return insert_count;
    }

    func replace_type(self, t: type*, g_data: generic_data*) {
        if (g_data->types.has(t->name.__ptr__())) {
            var real = g_data->types.get(t->name.__ptr__());
            t->name.clear();
            t->name.append_str(real->name.__ptr__());
            t->loc_file.clear();
            t->loc_file.append_str(real->loc_file.__ptr__());
            t->generics.clear();
            foreach (var i; real->generics) {
                t->generics.push(i.get()); // will do deep copy
            }
            // should add to t.pointer_depth, for example: func foo(a: T*) {}
            // we should replace T with bar, expected result is: bar*
            // if we do not add pointer_depth, the result will be bar
            t->pointer_depth += real->pointer_depth;
        }
        if (t->generics.empty()) {
            return;
        }
        foreach (var i; t->generics) {
            self->replace_type(i.get(), g_data);
        }
    }

    func replace_struct_type(self, s: colgm_struct*, g_data: generic_data*) {
        foreach (var i; s->fields) {
            var field = i.value();
            self->replace_type(field, g_data);
        }
        foreach (var i; s->ordered_fields) {
            var field = i.get();
            self->replace_type(field->type.__ptr__(), g_data);
        }
        foreach (var i; s->static_method) {
            var method = i.value();
            self->replace_func_type(method, g_data);
        }
        foreach (var i; s->method) {
            var method = i.value();
            self->replace_func_type(method, g_data);
        }

        var trp = type_replace_pass {
            err: self->err,
            ctx: self->ctx,
            pkg: self->pkg,
            co: self->co,
            g_data: g_data
        };
        if (s->generic_struct_decl != nil) {
            trp.replace_struct(s->generic_struct_decl);
            self->root->decls.push(ptr<ast>::wrap(s->generic_struct_decl => ast*));
            // s.name is generated with generic
            // for example original name is "foo",
            // but now it should be replaced with "foo<int, bool>"
            s->generic_struct_decl->name.clear();
            s->generic_struct_decl->name.append_str(s->name.__ptr__());
            s->generic_struct_decl->clear_generic_types();
            s->generic_struct_decl = nil;
        }
        foreach (var i; s->generic_struct_impl) {
            var i_n = i.get().unwrap();
            trp.replace_impl(i_n);
            self->root->decls.push(ptr<ast>::wrap(i_n => ast*));
            // s.name is generated with generic
            // for example original name is "foo",
            // but now it should be replaced with "foo<int, bool>"
            i_n->name.clear();
            i_n->name.append_str(s->name.__ptr__());
            i_n->clear_generic_types();
        }
        s->generic_struct_impl.clear();
    }

    func replace_func_type(self, f: colgm_func*, g_data: generic_data*) {
        self->replace_type(f->return_type.__ptr__(), g_data);
        foreach (var i; f->param_type) {
            var param_type = i.get();
            self->replace_type(param_type, g_data);
        }
        foreach (var i; f->unordered_params) {
            var param_type = i.value();
            self->replace_type(param_type, g_data);
        }

        if (f->generic_func_decl != nil) {
            var trp = type_replace_pass {
                err: self->err,
                ctx: self->ctx,
                pkg: self->pkg,
                co: self->co,
                g_data: g_data
            };
            trp.replace_func(f->generic_func_decl);
            self->root->decls.push(ptr<ast>::wrap(f->generic_func_decl => ast*));
            f->generic_func_decl->name.clear();
            f->generic_func_decl->name.append_str(f->name.__ptr__());
            f->generic_func_decl->clear_generic_types();
            f->generic_func_decl = nil;
        }
    }
}