use err::report::{ report };
use err::span::{ span };

use ast::ast::*;
use package::{ package };

use std::str::{ str };
use std::map::{ hashmap };
use std::io::{ io };
use std::vec::{ vec };
use std::libc::{ free };
use std::ptr::{ ptr };

use sema::type::{ type };
use sema::context::{ sema_context };
use sema::symbol_info::{ symbol_kind, symbol_info };
use sema::type_resolve::{ type_resolve };
use sema::function::{ colgm_func };
use sema::structure::{ colgm_struct };
use sema::module::{ colgm_module };

struct generic_data {
    // generic type itself
    generic_type: type,
    // replaced types, key is the generic name, type is the real type
    types: hashmap<str, type>
}

impl generic_data {
    pub func instance() -> generic_data {
        return generic_data {
            generic_type: type::instance(),
            types: hashmap<str, type>::instance()
        };
    }
    pub func new() -> generic_data* {
        var res = generic_data::__alloc__();
        res->generic_type = type::instance();
        res->types = hashmap<str, type>::instance();
        return res;
    }

    pub func delete(self) {
        self->generic_type.delete();
        self->types.delete();
    }

    pub func copy(self) -> generic_data* {
        var res = generic_data::__alloc__();
        res->generic_type = self->generic_type.copy_instance();
        res->types = self->types.copy_instance();
        return res;
    }
}

pub struct type_replace_pass {
    err: report*,
    ctx: sema_context*,
    pkg: package*,
    g_data: generic_data*
}

impl type_replace_pass {
    pub func replace_func(self, n: ast_func_decl*) {
        self->visit_func_decl(n);
    }

    pub func replace_impl(self, n: ast_impl*) {
        self->visit_impl(n);
    }

    pub func replace_struct(self, n: ast_struct_decl*) {
        self->visit_struct_decl(n);
    }
}

impl type_replace_pass {
    func generate_generic_type(self, t: type*, loc: span*) -> ast_type_def* {
        var new_def = ast_type_def::new(loc->copy());
        new_def->name = ast_identifier::new(loc->copy(), t->name.__ptr__());
        new_def->name->base.redirect_location.append_str(t->loc_file.__ptr__());
        new_def->base.redirect_location.append_str(t->loc_file.__ptr__());
        new_def->is_const = t->is_immutable;
        new_def->pointer_depth = t->pointer_depth;
        if (t->generics.size > 0) {
            new_def->generic_types = ast_generic_type_list::new(loc->copy());
            for (var i = t->generics.iter(); !i.is_end(); i = i.next()) {
                new_def->generic_types->types.push(ptr<ast>::wrap(
                    self->generate_generic_type(i.get(), loc) => ast*
                ));
            }
        }
        return new_def;
    }
}

impl type_replace_pass {
    func visit_ast(self, n: ast*) {
        match(n->kind) {
            ast_kind::ast_unary_operator =>
                self->visit_unary_operator(n => ast_unary_operator*);
            ast_kind::ast_binary_operator =>
                self->visit_binary_operator(n => ast_binary_operator*);
            ast_kind::ast_type_convert =>
                self->visit_type_convert(n => ast_type_convert*);
            ast_kind::ast_array_literal =>
                self->visit_array_literal(n => ast_array_literal*);
            ast_kind::ast_call_index =>
                self->visit_call_index(n => ast_call_index*);
            ast_kind::ast_call_func_args =>
                self->visit_call_func_args(n => ast_call_func_args*);
            ast_kind::ast_init_pair =>
                self->visit_init_pair(n => ast_init_pair*);
            ast_kind::ast_initializer =>
                self->visit_initializer(n => ast_initializer*);
            ast_kind::ast_call_id =>
                self->visit_call_id(n => ast_call_id*);
            ast_kind::ast_call => self->visit_call(n => ast_call*);
            ast_kind::ast_assignment =>
                self->visit_assignment(n => ast_assignment*);
            ast_kind::ast_cond_compile =>
                self->visit_cond_compile(n => ast_cond_compile*);
            ast_kind::ast_type_def =>
                self->visit_type_def(n => ast_type_def*);
            ast_kind::ast_generic_type_list =>
                self->visit_generic_type_list(n => ast_generic_type_list*);
            ast_kind::ast_struct_field =>
                self->visit_struct_field(n => ast_struct_field*);
            ast_kind::ast_struct_decl =>
                self->visit_struct_decl(n => ast_struct_decl*);
            ast_kind::ast_param =>
                self->visit_param(n => ast_param*);
            ast_kind::ast_param_list =>
                self->visit_param_list(n => ast_param_list*);
            ast_kind::ast_func_decl => 
                self->visit_func_decl(n => ast_func_decl*);
            ast_kind::ast_impl =>
                self->visit_impl(n => ast_impl*);
            ast_kind::ast_definition =>
                self->visit_definition(n => ast_definition*);
            ast_kind::ast_cond_stmt =>
                self->visit_cond_stmt(n => ast_cond_stmt*);
            ast_kind::ast_if_stmt =>
                self->visit_if_stmt(n => ast_if_stmt*);
            ast_kind::ast_match_case =>
                self->visit_match_case(n => ast_match_case*);
            ast_kind::ast_match_stmt =>
                self->visit_match_stmt(n => ast_match_stmt*);
            ast_kind::ast_while_stmt =>
                self->visit_while_stmt(n => ast_while_stmt*);
            ast_kind::ast_for_stmt =>
                self->visit_for_stmt(n => ast_for_stmt*);
            ast_kind::ast_in_stmt_expr =>
                self->visit_in_stmt_expr(n => ast_in_stmt_expr*);
            ast_kind::ast_ret_stmt =>
                self->visit_ret_stmt(n => ast_ret_stmt*);
            ast_kind::ast_code_block =>
                self->visit_code_block(n => ast_code_block*);
            _ => {}
        }
    }

    func visit_struct_decl(self, n: ast_struct_decl*) {
        for (var i = n->fields.iter(); !i.is_end(); i = i.next()) {
            var f = i.get().unwrap();
            if (!f->is(ast_kind::ast_struct_field)) {
                continue;
            }
            self->visit_struct_field(f => ast_struct_field*);
        }
    }

    func visit_func_decl(self, n: ast_func_decl*) {
        self->visit_param_list(n->params);
        if (n->return_type != nil) {
            self->visit_type_def(n->return_type);
        }
        if (n->body != nil) {
            self->visit_code_block(n->body);
        }
    }

    func visit_impl(self, n: ast_impl*) {
        for (var i = n->methods.iter(); !i.is_end(); i = i.next()) {
            var f = i.get().unwrap();
            if (!f->is(ast_kind::ast_func_decl)) {
                continue;
            }
            self->visit_func_decl(f => ast_func_decl*);
        }
    }

    func visit_unary_operator(self, n: ast_unary_operator*) {
        self->visit_ast(n->value);
    }

    func visit_binary_operator(self, n: ast_binary_operator*) {
        self->visit_ast(n->left);
        self->visit_ast(n->right);
    }

    func visit_type_convert(self, n: ast_type_convert*) {
        self->visit_ast(n->from);
        self->visit_type_def(n->to);
    }

    func visit_array_literal(self, n: ast_array_literal*) {
        if (n->type != nil) {
            self->visit_type_def(n->type);
        }
    }

    func visit_call_index(self, n: ast_call_index*) {
        self->visit_ast(n->index);
    }

    func visit_call_func_args(self, n: ast_call_func_args*) {
        for (var i = n->args.iter(); !i.is_end(); i = i.next()) {
            self->visit_ast(i.get().unwrap());
        }
    }

    func visit_init_pair(self, n: ast_init_pair*) {
        self->visit_ast(n->value);
    }

    func visit_initializer(self, n: ast_initializer*) {
        for (var i = n->pairs.iter(); !i.is_end(); i = i.next()) {
            self->visit_ast(i.get().unwrap());
        }
    }

    func visit_call_id(self, n: ast_call_id*) {
        var name = n->id->content.__ptr__();
        if (self->g_data->types.has(name)) {
            var select_type = self->g_data->types.get(name);

            if (select_type->pointer_depth > 0) {
                var st_full_name = select_type->full_path_name(self->pkg, true);
                var info = str::from("replace generic type with pointer type \"");
                info.append_str(st_full_name.__ptr__());
                info.append_i8_vec("\", which is not allowed here");
                self->err->error(n->base.location, info.c_str);
                
                st_full_name.delete();
                info.delete();
            }

            // cannot replace T in T<K> with another generic V<X>
            // because V<X><K> is not a valid type
            if (select_type->generics.size > 0 &&
                n->generic_types != nil) {
                var info = str::from("try to replace generic \"");
                var st_full_name = select_type->full_path_name(self->pkg, true);
                info.append_str(name);
                info.append_i8_vec("\" with \"");
                info.append_str(st_full_name.__ptr__());
                info.append_i8_vec("\", which is already a generic type");
                self->err->error(n->base.location, info.c_str);
                info.delete();
                st_full_name.delete();
            }

            n->id->content.clear();
            n->id->content.append_str(select_type->name.__ptr__());
            n->id->base.redirect_location.append_str(select_type->loc_file.__ptr__());
            n->base.redirect_location.append_str(select_type->loc_file.__ptr__());

            if (select_type->generics.size > 0 &&
                n->generic_types == nil) {
                n->generic_types = ast_generic_type_list::new(n->base.location->copy());
                for (var i = select_type->generics.iter(); !i.is_end(); i = i.next()) {
                    n->generic_types->types.push(ptr<ast>::wrap(
                        self->generate_generic_type(i.get(), n->base.location) => ast*
                    ));
                }
            }

            // io::stdout().out("[type_replace] call_id");
            // var st_full_name = select_type->generic_name(self->pkg);
            // io::stdout().out(" replace with ").out(st_full_name.c_str).out(" ");
            // n->base.location->dump(io::stdout());
            // st_full_name.delete();
        }

        if (n->generic_types != nil) {
            self->visit_generic_type_list(n->generic_types);
        }
    }

    func visit_call(self, n: ast_call*) {
        self->visit_call_id(n->head);
        for (var i = n->chain.iter(); !i.is_end(); i = i.next()) {
            self->visit_ast(i.get().unwrap());
        }
    }

    func visit_assignment(self, n: ast_assignment*) {
        self->visit_call(n->left);
        self->visit_ast(n->right);
    }

    func visit_cond_compile(self, n: ast_cond_compile*) {
        self->visit_ast(n->enabled_decl);
    }

    func visit_type_def(self, n: ast_type_def*) {
        var name = n->name->content.__ptr__();
        if (self->g_data->types.has(name)) {
            var select_type = self->g_data->types.get(name);

            // cannot replace T in T<K> with another generic V<X>
            // because V<X><K> is not a valid type
            if (select_type->generics.size > 0 &&
                n->generic_types != nil) {
                var info = str::from("try to replace generic \"");
                var st_full_name = select_type->full_path_name(self->pkg, true);
                info.append_str(name);
                info.append_i8_vec("\" with \"");
                info.append_str(st_full_name.__ptr__());
                info.append_i8_vec("\", which is already a generic type");
                self->err->error(n->base.location, info.c_str);
                info.delete();
                st_full_name.delete();
            }

            n->name->content.clear();
            n->name->content.append_str(select_type->name.__ptr__());
            n->name->base.redirect_location.append_str(select_type->loc_file.__ptr__());
            n->base.redirect_location.append_str(select_type->loc_file.__ptr__());

            n->pointer_depth += select_type->pointer_depth;

            if (select_type->generics.size > 0 &&
                n->generic_types == nil) {
                n->generic_types = ast_generic_type_list::new(n->base.location->copy());
                for (var i = select_type->generics.iter(); !i.is_end(); i = i.next()) {
                    n->generic_types->types.push(ptr<ast>::wrap(
                        self->generate_generic_type(i.get(), n->base.location) => ast*
                    ));
                }
            }

            // io::stdout().out("[type_replace] type_def");
            // var st_full_name = select_type->generic_name(self->pkg);
            // io::stdout().out(" replace with ").out(st_full_name.c_str).out(" ");
            // n->base.location->dump(io::stdout());
            // st_full_name.delete();
        }

        if (n->generic_types != nil) {
            self->visit_generic_type_list(n->generic_types);
        }
    }

    func visit_generic_type_list(self, n: ast_generic_type_list*) {
        for (var i = n->types.iter(); !i.is_end(); i = i.next()) {
            self->visit_ast(i.get().unwrap());
        }
    }

    func visit_struct_field(self, n: ast_struct_field*) {
        self->visit_type_def(n->type);
    }

    func visit_param(self, n: ast_param*) {
        if (n->type != nil) {
            self->visit_type_def(n->type);
        }
    }

    func visit_param_list(self, n: ast_param_list*) {
        for (var i = n->params.iter(); !i.is_end(); i = i.next()) {
            self->visit_ast(i.get().unwrap());
        }
    }

    func visit_definition(self, n: ast_definition*) {
        if (n->type != nil) {
            self->visit_type_def(n->type);
        }
        self->visit_ast(n->value);
    }

    func visit_cond_stmt(self, n: ast_cond_stmt*) {
        for (var i = n->stmts.iter(); !i.is_end(); i = i.next()) {
            self->visit_ast(i.get().unwrap());
        }
    }

    func visit_if_stmt(self, n: ast_if_stmt*) {
        if (n->condition != nil) {
            self->visit_ast(n->condition);
        }
        if (n->body != nil) {
            self->visit_code_block(n->body);
        }
    }

    func visit_match_case(self, n: ast_match_case*) {
        self->visit_call(n->pattern);
        if (n->body != nil) {
            self->visit_code_block(n->body);
        }
    }

    func visit_match_stmt(self, n: ast_match_stmt*) {
        self->visit_ast(n->value);
        for (var i = n->cases.iter(); !i.is_end(); i = i.next()) {
            self->visit_ast(i.get().unwrap());
        }
    }

    func visit_while_stmt(self, n: ast_while_stmt*) {
        if (n->condition != nil) {
            self->visit_ast(n->condition);
        }
        if (n->body != nil) {
            self->visit_code_block(n->body);
        }
    }

    func visit_for_stmt(self, n: ast_for_stmt*) {
        if (n->init != nil) {
            self->visit_definition(n->init);
        }
        if (n->condition != nil) {
            self->visit_ast(n->condition);
        }
        if (n->update != nil) {
            self->visit_ast(n->update);
        }
        if (n->body != nil) {
            self->visit_code_block(n->body);
        }
    }

    func visit_in_stmt_expr(self, n: ast_in_stmt_expr*) {
        self->visit_ast(n->value);
    }

    func visit_ret_stmt(self, n: ast_ret_stmt*) {
        if (n->value != nil) {
            self->visit_ast(n->value);
        }
    }

    func visit_code_block(self, n: ast_code_block*) {
        for (var i = n->stmts.iter(); !i.is_end(); i = i.next()) {
            self->visit_ast(i.get().unwrap());
        }
    }
}

pub struct generic_visitor {
    err: report*,
    pkg: package*,
    ctx: sema_context*,
    root: root*,
    tr: type_resolve,
    generic_type_map: hashmap<str, generic_data>
}

impl generic_visitor {
    pub func instance(e: report*, c: sema_context*, p: package*) -> generic_visitor {
        return generic_visitor {
            err: e,
            pkg: p,
            ctx: c,
            root: nil,
            tr: type_resolve::instance(e, c, p),
            generic_type_map: hashmap<str, generic_data>::instance()
        };
    }

    pub func delete(self) {
        self->generic_type_map.delete();
    }

    pub func scan_and_insert(self, n: root*) {
        self->root = n;

        var scan_count = 0;
        self->generic_type_map.clear();
        self->visit_root(n);
        while (self->insert_into_symbol_table() != 0) {
            scan_count += 1;
            self->generic_type_map.clear();
            self->visit_root(n);
        }
        if (scan_count > 0) {
            io::stdout().out("[generic_visitor] generate generics of ")
                        .out(n->base.location->file.c_str).out(" after ")
                        .out_i64(scan_count).out(" scan(s)").endln();
        }
    }
}

impl generic_visitor {
    func check_generic_exists(self, dm: colgm_module*, type_name: str*, n: ast*) -> bool {
        // check this symbol exists
        if (!dm->global_symbol.has(type_name) &&
            !dm->generic_symbol.has(type_name)) {
            var info = str::from("unknown type \"");
            info.append_str(type_name)->append_i8_vec("\"");
            self->err->error(n->location, info.c_str);
            info.delete();
            return false;
        }

        // check this symbol is generic type
        if (!dm->generic_symbol.has(type_name)) {
            var info = str::from("\"");
            info.append_str(type_name);
            info.append_i8_vec("\" is not a generic type");
            self->err->error(n->location, info.c_str);
            info.delete();
            return false;
        }

        return true;
    }

    func scan_generic_type(self, n: ast_type_def*) {
        var type_name = n->name->content.__ptr__();
        var domain_file: str* = nil;
        if (n->base.is_redirected()) {
            domain_file = n->base.redirect_location.__ptr__();
        } else {
            domain_file = n->base.location->file.__ptr__();
        }

        var dm = self->ctx->get_domain(domain_file);
        if (!self->check_generic_exists(dm, type_name, n => ast*)) {
            return;
        }

        var sym = dm->generic_symbol.get(type_name);
        if (sym->kind != symbol_kind::struct_kind) {
            var info = str::from("\"");
            info.append_str(type_name);
            info.append_i8_vec("\" is not a struct type");
            self->err->error(n->base.location, info.c_str);
            info.delete();
            return;
        }

        var sym_belonged_dm = self->ctx->get_domain(sym->loc_file.__ptr__());
        var generic_struct = sym_belonged_dm->generic_structs.get(type_name);
        var generic_template = generic_struct->generic_template.__ptr__();
        self->check_generic_type(n => ast*,
                                 type_name,
                                 sym,
                                 n->generic_types,
                                 generic_template);
    }

    func check_generic_type(self,
                            n: ast*,
                            type_name: str*,
                            sym: symbol_info*,
                            type_list_node: ast_generic_type_list*,
                            generic_template: vec<str>*) {
        var type_list = type_list_node->types.__ptr__();
        // check size match
        if (type_list->size != generic_template->size) {
            self->err->error(n->location,
                "generic type count does not match"
            );
            return;
        }

        var ss = str::from("");
        ss.append_str(type_name)->append_char('<');
        for (var i = type_list->iter(); !i.is_end(); i = i.next()) {
            var r_type = self->tr.resolve(i.get().unwrap() => ast_type_def*);
            var r_type_fpn = r_type.full_path_name(self->pkg, true);
            ss.append_str(r_type_fpn.__ptr__());
            r_type_fpn.delete();
            if (i.index() != type_list->size - 1) {
                ss.append_char(',');
            }
            r_type.delete();
        }
        ss.append_char('>');
        if (self->err->error_count > 0) {
            ss.delete();
            return;
        }

        // insert data
        if (self->generic_type_map.has(ss.__ptr__())) {
            ss.delete();
            return;
        }

        var g_data = generic_data::instance();
        g_data.generic_type.name.append_str(type_name);
        g_data.generic_type.loc_file.append_str(sym->loc_file.__ptr__());
        for (var i = type_list->iter(); !i.is_end(); i = i.next()) {
            var r_type = self->tr.resolve(i.get().unwrap() => ast_type_def*);
            g_data.generic_type.generics.push(r_type.__ptr__());
            g_data.types.insert(generic_template->get(i.index()), r_type.__ptr__());
        }

        self->generic_type_map.insert(ss.__ptr__(), g_data.__ptr__());

        ss.delete();
        g_data.delete();
        return;
    }
}

impl generic_visitor {
    func visit_ast(self, n: ast*) {
        match(n->kind) {
            ast_kind::ast_unary_operator =>
                self->visit_unary_operator(n => ast_unary_operator*);
            ast_kind::ast_binary_operator =>
                self->visit_binary_operator(n => ast_binary_operator*);
            ast_kind::ast_type_convert =>
                self->visit_type_convert(n => ast_type_convert*);
            ast_kind::ast_array_literal =>
                self->visit_array_literal(n => ast_array_literal*);
            ast_kind::ast_call_index =>
                self->visit_call_index(n => ast_call_index*);
            ast_kind::ast_call_func_args =>
                self->visit_call_func_args(n => ast_call_func_args*);
            ast_kind::ast_init_pair =>
                self->visit_init_pair(n => ast_init_pair*);
            ast_kind::ast_initializer =>
                self->visit_initializer(n => ast_initializer*);
            ast_kind::ast_call_id =>
                self->visit_call_id(n => ast_call_id*);
            ast_kind::ast_call => self->visit_call(n => ast_call*);
            ast_kind::ast_assignment =>
                self->visit_assignment(n => ast_assignment*);
            ast_kind::ast_cond_compile =>
                self->visit_cond_compile(n => ast_cond_compile*);
            ast_kind::ast_type_def =>
                self->visit_type_def(n => ast_type_def*);
            ast_kind::ast_generic_type_list =>
                self->visit_generic_type_list(n => ast_generic_type_list*);
            ast_kind::ast_struct_field =>
                self->visit_struct_field(n => ast_struct_field*);
            ast_kind::ast_struct_decl =>
                self->visit_struct_decl(n => ast_struct_decl*);
            ast_kind::ast_param =>
                self->visit_param(n => ast_param*);
            ast_kind::ast_param_list =>
                self->visit_param_list(n => ast_param_list*);
            ast_kind::ast_func_decl => 
                self->visit_func_decl(n => ast_func_decl*);
            ast_kind::ast_impl =>
                self->visit_impl(n => ast_impl*);
            ast_kind::ast_definition =>
                self->visit_definition(n => ast_definition*);
            ast_kind::ast_cond_stmt =>
                self->visit_cond_stmt(n => ast_cond_stmt*);
            ast_kind::ast_if_stmt =>
                self->visit_if_stmt(n => ast_if_stmt*);
            ast_kind::ast_match_case =>
                self->visit_match_case(n => ast_match_case*);
            ast_kind::ast_match_stmt =>
                self->visit_match_stmt(n => ast_match_stmt*);
            ast_kind::ast_while_stmt =>
                self->visit_while_stmt(n => ast_while_stmt*);
            ast_kind::ast_for_stmt =>
                self->visit_for_stmt(n => ast_for_stmt*);
            ast_kind::ast_in_stmt_expr =>
                self->visit_in_stmt_expr(n => ast_in_stmt_expr*);
            ast_kind::ast_ret_stmt =>
                self->visit_ret_stmt(n => ast_ret_stmt*);
            ast_kind::ast_code_block =>
                self->visit_code_block(n => ast_code_block*);
            _ => {}
        }
    }
}

impl generic_visitor {
    func visit_root(self, n: root*) {
        for (var i = n->decls.iter(); !i.is_end(); i = i.next()) {
            var d = i.get().unwrap();
            match (d->kind) {
                ast_kind::ast_struct_decl => {
                    self->visit_struct_decl(d => ast_struct_decl*);
                }
                ast_kind::ast_func_decl => {
                    self->visit_func_decl(d => ast_func_decl*);
                }
                ast_kind::ast_impl => {
                    self->visit_impl(d => ast_impl*);
                }
                ast_kind::ast_cond_compile => {
                    self->visit_cond_compile(d => ast_cond_compile*);
                }
                _ => {}
            }
        }
    }

    func visit_struct_decl(self, n: ast_struct_decl*) {
        if (n->generic_types != nil) {
            return;
        }
        for (var i = n->fields.iter(); !i.is_end(); i = i.next()) {
            var f = i.get().unwrap();
            if (!f->is(ast_kind::ast_struct_field)) {
                continue;
            }
            self->visit_struct_field(f => ast_struct_field*);
        }
    }

    func visit_func_decl(self, n: ast_func_decl*) {
        if (n->generic_types != nil) {
            return;
        }
        self->visit_param_list(n->params);
        if (n->return_type != nil) {
            self->visit_type_def(n->return_type);
        }
        if (n->body != nil) {
            self->visit_code_block(n->body);
        }
    }

    func visit_impl(self, n: ast_impl*) {
        if (n->generic_types != nil) {
            return;
        }
        for (var i = n->methods.iter(); !i.is_end(); i = i.next()) {
            var f = i.get().unwrap();
            if (!f->is(ast_kind::ast_func_decl)) {
                continue;
            }
            self->visit_func_decl(f => ast_func_decl*);
        }
    }

    func visit_unary_operator(self, n: ast_unary_operator*) {
        self->visit_ast(n->value);
    }

    func visit_binary_operator(self, n: ast_binary_operator*) {
        self->visit_ast(n->left);
        self->visit_ast(n->right);
    }

    func visit_type_convert(self, n: ast_type_convert*) {
        self->visit_ast(n->from);
        self->visit_type_def(n->to);
    }

    func visit_array_literal(self, n: ast_array_literal*) {
        if (n->type != nil) {
            self->visit_type_def(n->type);
        }
    }

    func visit_call_index(self, n: ast_call_index*) {
        self->visit_ast(n->index);
    }

    func visit_call_func_args(self, n: ast_call_func_args*) {
        for (var i = n->args.iter(); !i.is_end(); i = i.next()) {
            self->visit_ast(i.get().unwrap());
        }
    }

    func visit_init_pair(self, n: ast_init_pair*) {
        self->visit_ast(n->value);
    }

    func visit_initializer(self, n: ast_initializer*) {
        for (var i = n->pairs.iter(); !i.is_end(); i = i.next()) {
            self->visit_ast(i.get().unwrap());
        }
    }

    func visit_call_id(self, n: ast_call_id*) {
        if (n->generic_types == nil) {
            return;
        }
        self->visit_generic_type_list(n->generic_types);

        var type_name = n->id->content.__ptr__();
        var domain_file: str* = nil;
        if (n->base.is_redirected()) {
            domain_file = n->base.redirect_location.__ptr__();
        } else {
            domain_file = n->base.location->file.__ptr__();
        }

        var dm = self->ctx->get_domain(domain_file);
        if (!self->check_generic_exists(dm, type_name, n => ast*)) {
            return;
        }

        var sym = dm->generic_symbol.get(type_name);
        if (sym->kind != symbol_kind::struct_kind &&
            sym->kind != symbol_kind::func_kind) {
            var info = str::from("\"");
            info.append_str(type_name);
            info.append_i8_vec("\" is not a struct type");
            self->err->error(n->base.location, info.c_str);
            info.delete();
            return;
        }

        var sym_belonged_dm = self->ctx->get_domain(sym->loc_file.__ptr__());
        var generic_template: vec<str>* = nil;
        if (sym->kind == symbol_kind::struct_kind) {
            var generic_struct = sym_belonged_dm->generic_structs.get(type_name);
            generic_template = generic_struct->generic_template.__ptr__();
        } else {
            var generic_func = sym_belonged_dm->generic_functions.get(type_name);
            generic_template = generic_func->generic_template.__ptr__();
        }
        self->check_generic_type(n => ast*,
                                 type_name,
                                 sym,
                                 n->generic_types,
                                 generic_template);
    }

    func visit_call(self, n: ast_call*) {
        self->visit_call_id(n->head);
        for (var i = n->chain.iter(); !i.is_end(); i = i.next()) {
            self->visit_ast(i.get().unwrap());
        }
    }

    func visit_assignment(self, n: ast_assignment*) {
        self->visit_call(n->left);
        self->visit_ast(n->right);
    }

    func visit_cond_compile(self, n: ast_cond_compile*) {
        self->visit_ast(n->enabled_decl);
    }

    func visit_type_def(self, n: ast_type_def*) {
        if (n->generic_types != nil) {
            self->visit_generic_type_list(n->generic_types);
            self->scan_generic_type(n);
        }
    }

    func visit_generic_type_list(self, n: ast_generic_type_list*) {
        for (var i = n->types.iter(); !i.is_end(); i = i.next()) {
            self->visit_ast(i.get().unwrap());
        }
    }

    func visit_struct_field(self, n: ast_struct_field*) {
        self->visit_type_def(n->type);
    }

    func visit_param(self, n: ast_param*) {
        if (n->type != nil) {
            self->visit_type_def(n->type);
        }
    }

    func visit_param_list(self, n: ast_param_list*) {
        for (var i = n->params.iter(); !i.is_end(); i = i.next()) {
            self->visit_ast(i.get().unwrap());
        }
    }

    func visit_definition(self, n: ast_definition*) {
        if (n->type != nil) {
            self->visit_type_def(n->type);
        }
        self->visit_ast(n->value);
    }

    func visit_cond_stmt(self, n: ast_cond_stmt*) {
        for (var i = n->stmts.iter(); !i.is_end(); i = i.next()) {
            self->visit_ast(i.get().unwrap());
        }
    }

    func visit_if_stmt(self, n: ast_if_stmt*) {
        if (n->condition != nil) {
            self->visit_ast(n->condition);
        }
        if (n->body != nil) {
            self->visit_code_block(n->body);
        }
    }

    func visit_match_case(self, n: ast_match_case*) {
        self->visit_call(n->pattern);
        if (n->body != nil) {
            self->visit_code_block(n->body);
        }
    }

    func visit_match_stmt(self, n: ast_match_stmt*) {
        self->visit_ast(n->value);
        for (var i = n->cases.iter(); !i.is_end(); i = i.next()) {
            self->visit_ast(i.get().unwrap());
        }
    }

    func visit_while_stmt(self, n: ast_while_stmt*) {
        if (n->condition != nil) {
            self->visit_ast(n->condition);
        }
        if (n->body != nil) {
            self->visit_code_block(n->body);
        }
    }

    func visit_for_stmt(self, n: ast_for_stmt*) {
        if (n->init != nil) {
            self->visit_definition(n->init);
        }
        if (n->condition != nil) {
            self->visit_ast(n->condition);
        }
        if (n->update != nil) {
            self->visit_ast(n->update);
        }
        if (n->body != nil) {
            self->visit_code_block(n->body);
        }
    }

    func visit_in_stmt_expr(self, n: ast_in_stmt_expr*) {
        self->visit_ast(n->value);
    }

    func visit_ret_stmt(self, n: ast_ret_stmt*) {
        if (n->value != nil) {
            self->visit_ast(n->value);
        }
    }

    func visit_code_block(self, n: ast_code_block*) {
        for (var i = n->stmts.iter(); !i.is_end(); i = i.next()) {
            self->visit_ast(i.get().unwrap());
        }
    }
}

impl generic_visitor {
    func insert_struct(self, dm: colgm_module*, gd: generic_data*, gn: str*) {
        if (dm->structs.has(gn)) {
            return;
        }

        var struct_info = dm->generic_structs.get(gd->generic_type.name.__ptr__())->copy();
        struct_info->name.clear();
        struct_info->name.append_str(gn);
        struct_info->generic_template.clear();
        dm->structs.insert(gn, struct_info);

        var sym_info = symbol_info::new();
        sym_info->kind = symbol_kind::struct_kind;
        sym_info->loc_file.append_str(struct_info->location.file.__ptr__());
        sym_info->is_public = struct_info->is_public;
        self->ctx->global_symbol()->insert(gn, sym_info);
        sym_info->delete();
        free(sym_info => i8*);

        self->replace_struct_type(dm->structs.get(gn), gd);

        struct_info->delete();
        free(struct_info => i8*);
    }

    func insert_function(self, dm: colgm_module*, gd: generic_data*, gn: str*) {
        if (dm->functions.has(gn)) {
            return;
        }

        var func_info = dm->generic_functions.get(gd->generic_type.name.__ptr__())->copy();
        func_info->name.clear();
        func_info->name.append_str(gn);
        func_info->generic_template.clear();
        dm->functions.insert(gn, func_info);

        var sym_info = symbol_info::new();
        sym_info->kind = symbol_kind::func_kind;
        sym_info->loc_file.append_str(func_info->location.file.__ptr__());
        sym_info->is_public = func_info->is_public;
        self->ctx->global_symbol()->insert(gn, sym_info);
        sym_info->delete();
        free(sym_info => i8*);

        self->replace_func_type(dm->functions.get(gn), gd);

        func_info->delete();
        free(func_info => i8*);
    }

    func insert_into_symbol_table(self) -> u64 {
        var insert_count: u64 = 0;
        for (var i = self->generic_type_map.iter(); !i.is_end(); i = i.next()) {
            var g_data = i.value();
            var generic_name = g_data->generic_type.generic_name(self->pkg);
            
            var domain_file = g_data->generic_type.loc_file.__ptr__();
            if (!self->ctx->has_domain(domain_file)) {
                continue;
            }

            var dm = self->ctx->get_domain(domain_file);
            if (dm->generic_structs.has(g_data->generic_type.name.__ptr__()) &&
                !dm->structs.has(generic_name.__ptr__())) {
                insert_count += 1;
                self->insert_struct(dm, g_data, generic_name.__ptr__());
            }
            if (dm->generic_functions.has(g_data->generic_type.name.__ptr__()) &&
                !dm->functions.has(generic_name.__ptr__())) {
                insert_count += 1;
                self->insert_function(dm, g_data, generic_name.__ptr__());
            }

            generic_name.delete();
        }
        return insert_count;
    }

    func replace_type(self, t: type*, g_data: generic_data*) {
        if (g_data->types.has(t->name.__ptr__())) {
            var real = g_data->types.get(t->name.__ptr__());
            t->name.clear();
            t->name.append_str(real->name.__ptr__());
            t->loc_file.clear();
            t->loc_file.append_str(real->loc_file.__ptr__());
            t->generics.clear();
            for (var i = real->generics.iter(); !i.is_end(); i = i.next()) {
                t->generics.push(i.get()); // will do copy
            }
            // should add to t.pointer_depth, for example: func foo(a: T*) {}
            // we should replace T with bar, expected result is: bar*
            // if we do not add pointer_depth, the result will be bar
            t->pointer_depth += real->pointer_depth;
        }
        if (t->generics.size == 0) {
            return;
        }
        for (var i = t->generics.iter(); !i.is_end(); i = i.next()) {
            self->replace_type(i.get(), g_data);
        }
    }

    func replace_struct_type(self, s: colgm_struct*, g_data: generic_data*) {
        for (var i = s->fields.iter(); !i.is_end(); i = i.next()) {
            var field = i.value();
            self->replace_type(field->sym_type.__ptr__(), g_data);
        }
        for (var i = s->ordered_fields.iter(); !i.is_end(); i = i.next()) {
            var field = i.get();
            self->replace_type(field->sym_type.__ptr__(), g_data);
        }
        for (var i = s->static_methods.iter(); !i.is_end(); i = i.next()) {
            var method = i.value();
            self->replace_func_type(method, g_data);
        }
        for (var i = s->methods.iter(); !i.is_end(); i = i.next()) {
            var method = i.value();
            self->replace_func_type(method, g_data);
        }

        var trp = type_replace_pass {
            err: self->err,
            ctx: self->ctx,
            pkg: self->pkg,
            g_data: g_data
        };
        if (s->generic_struct_decl != nil) {
            trp.replace_struct(s->generic_struct_decl);
            self->root->decls.push(ptr<ast>::wrap(s->generic_struct_decl => ast*));
            // s.name is generated with generic
            // for example original name is "foo",
            // but now it should be replaced with "foo<int, bool>"
            s->generic_struct_decl->name.clear();
            s->generic_struct_decl->name.append_str(s->name.__ptr__());
            s->generic_struct_decl->clear_generic_types();
            s->generic_struct_decl = nil;
        }
        for (var i = s->generic_struct_impl.iter(); !i.is_end(); i = i.next()) {
            var i_n = i.get().unwrap();
            trp.replace_impl(i_n);
            self->root->decls.push(ptr<ast>::wrap(i_n => ast*));
            // s.name is generated with generic
            // for example original name is "foo",
            // but now it should be replaced with "foo<int, bool>"
            i_n->name.clear();
            i_n->name.append_str(s->name.__ptr__());
            i_n->clear_generic_types();
        }
        s->generic_struct_impl.clear();
    }

    func replace_func_type(self, f: colgm_func*, g_data: generic_data*) {
        self->replace_type(f->return_type.__ptr__(), g_data);
        for (var i = f->param_type.iter(); !i.is_end(); i = i.next()) {
            var param_type = i.get();
            self->replace_type(param_type, g_data);
        }
        for (var i = f->unordered_params.iter(); !i.is_end(); i = i.next()) {
            var param_type = i.value();
            self->replace_type(param_type, g_data);
        }

        if (f->generic_func_decl != nil) {
            var trp = type_replace_pass {
                err: self->err,
                ctx: self->ctx,
                pkg: self->pkg,
                g_data: g_data
            };
            trp.replace_func(f->generic_func_decl);
            self->root->decls.push(ptr<ast>::wrap(f->generic_func_decl => ast*));
            f->generic_func_decl->name.clear();
            f->generic_func_decl->name.append_str(f->name.__ptr__());
            f->generic_func_decl->clear_generic_types();
            f->generic_func_decl = nil;
        }
    }
}