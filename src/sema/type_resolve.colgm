use err::report::{ report };
use ast::ast::{ ast_kind, ast_type_def };
use package::{ package };

use sema::context::{ sema_context };
use sema::type::{ type };
use sema::symbol_info::{ symbol_kind };

use std::io::{ io };
use std::str::{ str };

pub struct type_resolve {
    err: report*,
    ctx: sema_context*,
    pkg: package*
}

impl type_resolve {
    pub func instance(e: report*, c: sema_context*, p: package*) -> type_resolve {
        return type_resolve { err: e, ctx: c, pkg: p };
    }

    pub func resolve(self, node: ast_type_def*) -> type {
        var name = node->name->content.__ptr__();
        var file = node->base.location->file.__ptr__();
        if (node->base.is_redirected()) {
            file = node->base.redirect_location.__ptr__();
        }

        var G = self->ctx->global;

        if (!G->domain.has(file)) {
            self->err->error(node->base.location, "cannot find module");
            return type::error_type();
        }
        var DM = G->domain.get(file);
        var GN = self->ctx->generics.__ptr__();

        // cannot find type
        if (!DM->global_symbol.has(name) &&
            !DM->generic_symbol.has(name) &&
            !GN->has(name)) {
            var info = str::from("undefined type \"");
            info.append_str(name)->append_i8_vec("\"");
            self->err->error(node->base.location, info.c_str);
            info.delete();
            return type::error_type();
        }

        // find type but type is not imported as public
        // mainly occurs when import all symbols from a module
        if (DM->global_symbol.has(name) &&
            !DM->global_symbol.get(name)->is_public) {
            var info = str::from("private type \"");
            info.append_str(name)->append_i8_vec("\" cannot be used");
            self->err->error(node->base.location, info.c_str);
            info.delete();
            return type::error_type();
        }

        // function cannot be used as type
        if (DM->global_symbol.has(name) &&
            DM->global_symbol.get(name)->kind == symbol_kind::func_kind) {
            var info =  str::from("\"");
            info.append_str(name)
                ->append_i8_vec("\" is a function, ")
                ->append_i8_vec("cannot be used as a type.");
            self->err->error(node->base.location, info.c_str);
            info.delete();
            return type::error_type();
        }

        var t = type::instance();
        t.name.append_str(name);
        t.pointer_depth = node->pointer_depth;
        t.is_immutable = node->is_const;
        if (GN->has(name)) {
            t.is_generic_placeholder = true;
        }

        if (DM->global_symbol.has(name) &&
            DM->global_symbol.get(name)->kind != symbol_kind::basic_kind) {
            t.loc_file.append_str(DM->global_symbol.get(name)->loc_file.__ptr__());
        } else if (DM->generic_symbol.has(name)) {
            t.loc_file.append_str(DM->generic_symbol.get(name)->loc_file.__ptr__());
        }

        if (node->generic_types != nil) {
            var gtv = node->generic_types->types.__ptr__();
            for (var i: u64 = 0; i < gtv->size; i += 1) {
                var gt = gtv->get(i).unwrap();
                if (!gt->is(ast_kind::ast_type_def)) {
                    self->err->error(gt->location,
                        "invalid ast node, expect type def"
                    );
                    continue;
                }
                var n_td = gt => ast_type_def*;
                var gt_res = self->resolve(n_td);
                t.generics.push(gt_res.__ptr__());
                gt_res.delete();
            }
        }
        return t;
    }
}