use err::report::{ report };
use err::panic::{ panic };

use std::io::{ io };
use std::libc::{ free };
use std::str::{ str };

use package::{ package };

use ast::ast::*;

use sema::context::{ sema_context };
use sema::type_resolve::{ type_resolve };

use util::cli::{ cli_option };

pub struct sema {
    err: report*,
    root: root*,
    ctx: sema_context*,
    co: cli_option*,
    tr: type_resolve,
    in_loop_level: i64,
    impl_struct_name: str
}

impl sema {
    pub func new(err: report*,
                 pkg: package*,
                 ctx: sema_context*,
                 co: cli_option*) -> sema* {
        var res = sema::__alloc__();
        if (res == nil) {
            panic("sema::new: failed to allocate memory");
        }
        res->err = err;
        res->ctx = ctx;
        res->co = co;
        res->tr = type_resolve::instance(err, ctx, pkg);
        res->in_loop_level = 0;
        res->impl_struct_name = str::from("");
        return res;
    }

    pub func delete(self) {}
}

impl sema {
    pub func analyse(self, root: root*) {
        self->ctx->this_file.clear();
        self->ctx->this_file.append_str(root->base.location->file.__ptr__());
        self->root = root;

        self->resolve_function_block(root);
    }

    func resolve_function_block(self, ast_root: root*) {
        for (var i = ast_root->decls.iter(); !i.is_end(); i = i.next()) {
            var node = i.get().unwrap();
            if (node->is(ast_kind::ast_impl)) {
                self->resolve_impl(node => ast_impl*);
            }
            if (node->is(ast_kind::ast_func_decl)) {
                self->resolve_global_func(node => ast_func_decl*);
            }
        }
    }

    func resolve_impl(self, node: ast_impl*) {}

    func resolve_global_func(self, node: ast_func_decl*) {}
}