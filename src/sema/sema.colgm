use err::report::{ report };
use err::span::{ span };

use std::io::{ io };
use std::math::{ isinf, isnan };
use std::str::{ str };
use std::vec::{ vec };
use std::set::{ hashset };
use std::basic::{ basic };
use std::panic::{ unreachable };

use util::package::{ package };

use ast::ast::*;
use ast::dumper::{ ast_dumper };

use sema::structure::{ colgm_struct };
use sema::tagged_union::{ colgm_tagged_union };
use sema::function::{ colgm_func };
use sema::context::{ sema_context };
use sema::type::{ type };
use sema::symbol_info::{ symbol_kind };
use sema::module::{ colgm_module };
use sema::type_resolve::{ type_resolve };

use util::cli::{ cli_option };
use util::to_num::{ to_f64, to_u64 };

pub struct sema {
    err: report*,
    root: root*,
    ctx: sema_context*,
    co: cli_option*,
    pkg: package*,
    tr: type_resolve,
    in_loop_level: i64,
    impl_struct_name: str
}

impl sema {
    pub func instance(err: report*,
                      pkg: package*,
                      ctx: sema_context*,
                      co: cli_option*) -> sema {
        return sema {
            err: err,
            root: nil,
            ctx: ctx,
            co: co,
            pkg: pkg,
            tr: type_resolve::instance(err, ctx, pkg),
            in_loop_level: 0,
            impl_struct_name: str::from("")
        };
    }

    pub func delete(self) {
        self->impl_struct_name.delete();
    }
}

impl sema {
    func is_enum_type(self, ty: type*) -> bool {
        if (ty->loc_file.empty()) {
            return false;
        }
        var dm = self->ctx->get_domain(ty->loc_file.__ptr__());
        if (dm->enums.has(ty->name.__ptr__())) {
            return true;
        }
        return false;
    }

    func is_struct_type(self, ty: type*) -> bool {
        if (ty->loc_file.empty()) {
            return false;
        }
        var dm = self->ctx->get_domain(ty->loc_file.__ptr__());
        var n = ty->generic_name(self->pkg);
        defer n.delete();

        if (dm->structs.has(n.__ptr__())) {
            return true;
        }
        return false;
    }

    func is_tagged_union_type(self, ty: type*) -> bool {
        if (ty->loc_file.empty()) {
            return false;
        }
        var dm = self->ctx->get_domain(ty->loc_file.__ptr__());
        var n = ty->generic_name(self->pkg);
        defer n.delete();

        if (dm->tagged_unions.has(n.__ptr__())) {
            return true;
        }
        return false;
    }

    func is_function_type(self, ty: type*) -> bool {
        if (ty->loc_file.empty()) {
            return false;
        }
        var dm = self->ctx->get_domain(ty->loc_file.__ptr__());
        var n = ty->generic_name(self->pkg);
        defer n.delete();

        if (dm->functions.has(n.__ptr__())) {
            return true;
        }
        return false;
    }
}

impl sema {
    func resolve_nil_literal(self, n: ast_nil_literal*) -> type {
        var ty = type::i8_type(1);
        n->base.resolved_type.reset_with(ty.__ptr__());
        return ty;
    }

    func resolve_number_literal(self, n: ast_number_literal*) -> type {
        var result = to_f64(n->literal.c_str);
        var to_u64_try = to_u64(n->literal);
        if (isinf(result) || isnan(result)) {
            var info = str::from("invalid number \"");
            info.append_str(n->literal.__ptr__());
            info.append_char('\"');
            defer info.delete();

            self->err->error(n->base.location.__ptr__(), info.c_str);
            return type::error_type();
        }

        // result is not inf or nan, and contains '.', must be float
        // some i64 literal may cause to_u64_try.is_ok() == true
        // but we will check it later
        if (n->literal.contains('.') ||
            (!to_u64_try.is_ok() && n->literal.contains('e')) ||
            (!to_u64_try.is_ok() && n->literal.contains('E'))) {
            var ty = type::f64_type();
            n->base.resolved_type.reset_with(ty.__ptr__());
            return ty;
        }

        // must be u64
        if (((n->literal.size > 2 && n->literal.c_str[1] == 'o') ||
            (n->literal.size > 2 && n->literal.c_str[1] == 'x')) &&
            to_u64_try.is_ok()) {
            n->literal.clear();
            n->literal.append_u64(to_u64_try.unwrap());
            var ty = type::u64_type();
            n->base.resolved_type.reset_with(ty.__ptr__());
            return ty;
        }

        var default_ty = type::i64_type();
        n->base.resolved_type.reset_with(default_ty.__ptr__());
        return default_ty;
    }

    func resolve_string_literal(self, n: ast_string_literal*) -> type {
        var ty = type::const_str_literal_type();
        self->ctx->constant_string.insert(n->literal.__ptr__());
        n->base.resolved_type.reset_with(ty.__ptr__());
        return ty;
    }

    func resolve_char_literal(self, n: ast_char_literal*) -> type {
        var ty = type::i8_type(0);
        n->base.resolved_type.reset_with(ty.__ptr__());
        return ty;
    }

    func resolve_bool_literal(self, n: ast_bool_literal*) -> type {
        var ty = type::bool_type();
        n->base.resolved_type.reset_with(ty.__ptr__());
        return ty;
    }

    func resolve_array_list(self, n: ast_array_list*) -> type {
        var list_type = vec<type>::instance();
        defer list_type.delete();

        foreach (var i; n->value) {
            var t = self->resolve_expression(i.get());
            defer t.delete();

            list_type.push(t.__ptr__());
        }
        foreach (var i; list_type) {
            if (i.get()->is_error()) {
                return type::error_type();
            }
        }

        if (list_type.empty()) {
            return type::empty_array_type();
        }

        var marked_base_type = list_type.get(0);
        for (var i: u64 = 1; i < list_type.size; i += 1) {
            var this_node = n->value.get(i);
            if (!list_type.get(i)->eq(marked_base_type) &&
                !self->check_can_be_converted(this_node, marked_base_type)) {
                var info = str::from("expect \"");
                defer info.delete();

                var e_name = marked_base_type->full_path_name_with_pointer(self->pkg);
                defer e_name.delete();

                info.append_str(e_name.__ptr__());
                info.append("\" but get \"");

                var i_name = list_type.get(i)->full_path_name_with_pointer(self->pkg);
                defer i_name.delete();

                info.append_str(i_name.__ptr__());
                info.append("\"");

                self->err->error(this_node->location.__ptr__(), info.c_str);
            }
        }

        var type_infer = marked_base_type->pointer_copy();
        type_infer.is_array = true;
        type_infer.array_length = list_type.size;

        n->base.resolved_type.reset_with(type_infer.__ptr__());
        return type_infer;
    }

    func resolve_unary_neg(self, n: ast_unary_operator*) -> type {
        var infer = self->resolve_expression(n->value);
        defer infer.delete();

        if (infer.is_error()) {
            return type::error_type();
        }
        if (!infer.is_integer() && !infer.is_float()) {
            self->err->out("expect integer or float but get \"")
                     ->out_type(infer.__ptr__(), self->pkg)
                     ->out("\"")
                     ->emit_err(n->base.location.__ptr__());
            return type::error_type();
        }

        var res = infer.clone();
        return res;
    }

    func resolve_unary_bnot(self, n: ast_unary_operator*) -> type {
        var infer = self->resolve_expression(n->value);
        defer infer.delete();

        if (infer.is_error()) {
            return type::error_type();
        }
        if (!infer.can_bitwise_calculate()) {
            self->err->out("bitwise operator cannot be used on \"")
                     ->out_type(infer.__ptr__(), self->pkg)
                     ->out("\"")
                     ->emit_err(n->base.location.__ptr__());
            return type::error_type();
        }

        var res = infer.clone();
        return res;
    }

    func resolve_unary_lnot(self, n: ast_unary_operator*) -> type {
        var infer = self->resolve_expression(n->value);
        defer infer.delete();
        // do not report if get error type,
        // because the related error is reported before
        if (infer.is_error()) {
            return type::bool_type();
        }
        if (!infer.is_bool() || infer.is_pointer()) {
            var info = str::from("logical operator cannot be used on \"");
            defer info.delete();

            var i_name = infer.full_path_name_with_pointer(self->pkg);
            defer i_name.delete();

            info.append_str(i_name.__ptr__());
            info.append("\"");

            self->err->error(n->base.location.__ptr__(), info.c_str);
            return type::bool_type();
        }

        return type::bool_type();
    }

    func resolve_unary_operator(self, n: ast_unary_operator*) -> type {
        match (n->kind) {
            unary_kind::neg => {
                var ty = self->resolve_unary_neg(n);
                n->base.resolved_type.reset_with(ty.__ptr__());
                return ty;
            }
            unary_kind::bnot => {
                var ty = self->resolve_unary_bnot(n);
                n->base.resolved_type.reset_with(ty.__ptr__());
                return ty;
            }
            unary_kind::lnot => {
                var ty = self->resolve_unary_lnot(n);
                n->base.resolved_type.reset_with(ty.__ptr__());
                return ty;
            }
        }

        unreachable();
        return type::error_type();
    }

    func resolve_comparison_operator(self, n: ast_binary_operator*) -> type {
        var left = self->resolve_expression(n->left);
        defer left.delete();

        var right = self->resolve_expression(n->right);
        defer right.delete();

        if (left.is_error() || right.is_error()) {
            var infer = type::bool_type();
            n->base.resolved_type.reset_with(infer.__ptr__());
            return infer;
        }
        if (!left.eq(right.__ptr__())) {
            if (!self->check_can_be_converted(n->right, left.__ptr__()) &&
                !self->check_can_be_converted(n->left, right.__ptr__())) {
                var info = str::from("cannot compare \"");
                var l_name = left.full_path_name_with_pointer(self->pkg);
                var r_name = right.full_path_name_with_pointer(self->pkg);
                defer {
                    info.delete();
                    l_name.delete();
                    r_name.delete();
                }

                info.append_str(l_name.__ptr__());
                info.append("\" and \"");
                info.append_str(r_name.__ptr__());
                info.append("\"");
                self->err->error(n->base.location.__ptr__(), info.c_str);

                var infer = type::bool_type();
                n->base.resolved_type.reset_with(infer.__ptr__());
                return infer;
            }
        }

        // check enum comparison
        if (self->is_enum_type(left.__ptr__())) {
            if (n->kind != binary_kind::cmpeq &&
                n->kind != binary_kind::cmpne) {
                self->err->error(n->base.location.__ptr__(), "only \"==\" and \"!=\" are allowed");
            }

            var infer = type::bool_type();
            n->base.resolved_type.reset_with(infer.__ptr__());
            return infer;
        } else if (!left.is_integer() && !left.is_float() &&
                   !left.is_pointer() && !left.is_bool()) {
            var info = str::from("cannot compare uncomparable type \"");
            var l_name = left.full_path_name_with_pointer(self->pkg);
            var r_name = right.full_path_name_with_pointer(self->pkg);
            defer {
                info.delete();
                l_name.delete();
                r_name.delete();
            }

            info.append_str(l_name.__ptr__());
            info.append("\" and \"");
            info.append_str(r_name.__ptr__());
            info.append("\"");
            self->err->error(n->base.location.__ptr__(), info.c_str);

            var infer = type::bool_type();
            n->base.resolved_type.reset_with(infer.__ptr__());
            return infer;
        }

        if (left.is_pointer() && left.pointer_depth != right.pointer_depth) {
            var info = str::from("cannot compare pointer \"");
            var l_name = left.full_path_name_with_pointer(self->pkg);
            var r_name = right.full_path_name_with_pointer(self->pkg);
            defer {
                info.delete();
                l_name.delete();
                r_name.delete();
            }

            info.append_str(l_name.__ptr__());
            info.append("\" with different pointer level type \"");
            info.append_str(r_name.__ptr__());
            info.append("\"");
            self->err->error(n->base.location.__ptr__(), info.c_str);

            var infer = type::bool_type();
            n->base.resolved_type.reset_with(infer.__ptr__());
            return infer;
        }

        var infer = type::bool_type();
        n->base.resolved_type.reset_with(infer.__ptr__());
        return infer;
    }

    func resolve_logical_operator(self, n: ast_binary_operator*) -> type {
        var left = self->resolve_expression(n->left);
        defer left.delete();

        var right = self->resolve_expression(n->right);
        defer right.delete();

        if (left.is_error() || !right.is_error()) {
            var infer = type::bool_type();
            n->base.resolved_type.reset_with(infer.__ptr__());
            return infer;
        }

        if (left.is_bool() && right.is_bool()) {
            var infer = type::bool_type();
            n->base.resolved_type.reset_with(infer.__ptr__());
            return infer;
        }

        if (!left.is_bool()) {
            var info = str::from("expect \"bool\" but get \"");
            defer info.delete();

            var name = left.full_path_name_with_pointer(self->pkg);
            defer name.delete();

            info.append_str(name.__ptr__());
            info.append("\"");
            self->err->error(n->left->location.__ptr__(), info.c_str);
        }
        if (!right.is_bool()) {
            var info = str::from("expect \"bool\" but get \"");
            defer info.delete();

            var name = right.full_path_name_with_pointer(self->pkg);
            defer name.delete();

            info.append_str(name.__ptr__());
            info.append("\"");
            self->err->error(n->right->location.__ptr__(), info.c_str);
        }

        var infer = type::bool_type();
        n->base.resolved_type.reset_with(infer.__ptr__());
        return infer;
    }

    func resolve_arithmetic_operator(self, n: ast_binary_operator*) -> type {
        var left = self->resolve_expression(n->left);
        defer left.delete();

        var right = self->resolve_expression(n->right);
        defer right.delete();

        if (left.is_error() || right.is_error()) {
            return type::error_type();
        }

        // left hand side value should be the same as right hand side value
        if (!left.eq(right.__ptr__())) {
            if (!self->check_can_be_converted(n->right, left.__ptr__()) &&
                !self->check_can_be_converted(n->left, right.__ptr__())) {
                var info = str::from("cannot calculate \"");
                var l_name = left.full_path_name_with_pointer(self->pkg);
                var r_name = right.full_path_name_with_pointer(self->pkg);
                defer {
                    info.delete();
                    l_name.delete();
                    r_name.delete();
                }

                info.append_str(l_name.__ptr__())->append("\" and \"");
                info.append_str(r_name.__ptr__());
                self->err->error(n->base.location.__ptr__(), info.c_str);
                return type::error_type();
            }
        }

        // cannot calculate these types
        if (self->is_enum_type(left.__ptr__()) ||
            self->is_struct_type(left.__ptr__()) ||
            self->is_tagged_union_type(left.__ptr__()) ||
            self->is_function_type(left.__ptr__())) {
            var info = str::from("cannot calculate \"");
            defer info.delete();

            var name = left.full_path_name_with_pointer(self->pkg);
            defer name.delete();

            info.append_str(name.__ptr__())->append("\"");
            self->err->error(n->left->location.__ptr__(), info.c_str);
            return type::error_type();
        } else if (self->is_enum_type(right.__ptr__()) ||
                   self->is_struct_type(right.__ptr__()) ||
                   self->is_tagged_union_type(right.__ptr__()) ||
                   self->is_function_type(right.__ptr__())) {
            var info = str::from("cannot calculate \"");
            defer info.delete();

            var name = right.full_path_name_with_pointer(self->pkg);
            defer name.delete();

            info.append_str(name.__ptr__())->append("\"");
            self->err->error(n->right->location.__ptr__(), info.c_str);
            return type::error_type();
        }

        n->base.resolved_type.reset_with(left.__ptr__());
        var res = left.clone();
        return res;
    }

    func resolve_bitwise_operator(self, n: ast_binary_operator*) -> type {
        var left = self->resolve_expression(n->left);
        defer left.delete();

        var right = self->resolve_expression(n->right);
        defer right.delete();

        if (left.is_error() || right.is_error()) {
            return type::error_type();
        }

        if (!left.can_bitwise_calculate()) {
            self->err->out("bitwise operator cannot be used on \"")
                     ->out_type(left.__ptr__(), self->pkg)
                     ->out("\"")
                     ->emit_err(n->left->location.__ptr__());
            return type::error_type();
        }

        if (!right.can_bitwise_calculate()) {
            self->err->out("bitwise operator cannot be used on \"")
                     ->out_type(right.__ptr__(), self->pkg)
                     ->out("\"")
                     ->emit_err(n->right->location.__ptr__());
            return type::error_type();
        }

        // left hand side value should be the same as right hand side value
        if (!left.eq(right.__ptr__())) {
            if (!self->check_can_be_converted(n->right, left.__ptr__()) &&
                !self->check_can_be_converted(n->left, right.__ptr__())) {
                var info = str::from("cannot calculate \"");
                var l_name = left.full_path_name_with_pointer(self->pkg);
                var r_name = right.full_path_name_with_pointer(self->pkg);
                defer {
                    info.delete();
                    l_name.delete();
                    r_name.delete();
                }

                info.append_str(l_name.__ptr__())->append("\" and \"");
                info.append_str(r_name.__ptr__());
                self->err->error(n->base.location.__ptr__(), info.c_str);
                return type::error_type();
            }
        }

        n->base.resolved_type.reset_with(left.__ptr__());
        var res = left.clone();
        return res;
    }

    func resolve_binary_operator(self, n: ast_binary_operator*) -> type {
        match (n->kind) {
            binary_kind::add => {
                var ty = self->resolve_arithmetic_operator(n);
                n->base.resolved_type.reset_with(ty.__ptr__());
                return ty;
            }
            binary_kind::sub => {
                var ty = self->resolve_arithmetic_operator(n);
                n->base.resolved_type.reset_with(ty.__ptr__());
                return ty;
            }
            binary_kind::mul => {
                var ty = self->resolve_arithmetic_operator(n);
                n->base.resolved_type.reset_with(ty.__ptr__());
                return ty;
            }
            binary_kind::div => {
                var ty = self->resolve_arithmetic_operator(n);
                n->base.resolved_type.reset_with(ty.__ptr__());
                return ty;
            }
            binary_kind::rem => {
                var ty = self->resolve_arithmetic_operator(n);
                n->base.resolved_type.reset_with(ty.__ptr__());
                return ty;
            }
            binary_kind::cmpeq => {
                var ty = self->resolve_comparison_operator(n);
                n->base.resolved_type.reset_with(ty.__ptr__());
                return ty;
            }
            binary_kind::cmpne => {
                var ty = self->resolve_comparison_operator(n);
                n->base.resolved_type.reset_with(ty.__ptr__());
                return ty;
            }
            binary_kind::less => {
                var ty = self->resolve_comparison_operator(n);
                n->base.resolved_type.reset_with(ty.__ptr__());
                return ty;
            }
            binary_kind::leq => {
                var ty = self->resolve_comparison_operator(n);
                n->base.resolved_type.reset_with(ty.__ptr__());
                return ty;
            }
            binary_kind::grt => {
                var ty = self->resolve_comparison_operator(n);
                n->base.resolved_type.reset_with(ty.__ptr__());
                return ty;
            }
            binary_kind::geq => {
                var ty = self->resolve_comparison_operator(n);
                n->base.resolved_type.reset_with(ty.__ptr__());
                return ty;
            }
            binary_kind::cmpand => {
                var ty = self->resolve_logical_operator(n);
                n->base.resolved_type.reset_with(ty.__ptr__());
                return ty;
            }
            binary_kind::cmpor => {
                var ty = self->resolve_logical_operator(n);
                n->base.resolved_type.reset_with(ty.__ptr__());
                return ty;
            }
            binary_kind::band => {
                var ty = self->resolve_bitwise_operator(n);
                n->base.resolved_type.reset_with(ty.__ptr__());
                return ty;
            }
            binary_kind::bor => {
                var ty = self->resolve_bitwise_operator(n);
                n->base.resolved_type.reset_with(ty.__ptr__());
                return ty;
            }
            binary_kind::bxor => {
                var ty = self->resolve_bitwise_operator(n);
                n->base.resolved_type.reset_with(ty.__ptr__());
                return ty;
            }
        }

        unreachable();
        return type::error_type();
    }

    func resolve_type_convert(self, n: ast_type_convert*) -> type {
        var res = self->resolve_expression(n->from);
        defer res.delete();

        var type_res = self->tr.resolve(n->to);
        defer type_res.delete();

        if (res.is_error() || type_res.is_error()) {
            return type::error_type();
        }

        // convert floating point number to pointer is unsafe at all
        if ((res.is_float() && !res.is_pointer() && type_res.is_pointer()) ||
            (res.is_pointer() && type_res.is_float() && !type_res.is_pointer())) {
            var info = str::from("cannot cast floating point number to pointer: \"");
            var r_name = res.full_path_name_with_pointer(self->pkg);
            var t_name = type_res.full_path_name_with_pointer(self->pkg);
            defer {
                info.delete();
                r_name.delete();
                t_name.delete();
            }

            info.append_str(r_name.__ptr__())->append("\" => \"");
            info.append_str(t_name.__ptr__());
            info.append("\"");
            self->err->error(n->to->base.location.__ptr__(), info.c_str);
            return type::error_type();
        }

        // struct type is not allowed to be casted
        if (self->is_struct_type(res.__ptr__()) && !res.is_pointer()) {
            var info = str::from("cannot cast struct \"");
            var r_name = res.full_path_name_with_pointer(self->pkg);
            var t_name = type_res.full_path_name_with_pointer(self->pkg);
            defer {
                info.delete();
                r_name.delete();
                t_name.delete();
            }

            info.append_str(r_name.__ptr__())->append("\" to \"");
            info.append_str(t_name.__ptr__());
            info.append("\"");
            self->err->error(n->to->base.location.__ptr__(), info.c_str);
            return type::error_type();
        }

        if (self->is_struct_type(type_res.__ptr__()) && !type_res.is_pointer()) {
            var info = str::from("cannot cast \"");
            var r_name = res.full_path_name_with_pointer(self->pkg);
            var t_name = type_res.full_path_name_with_pointer(self->pkg);
            defer {
                info.delete();
                r_name.delete();
                t_name.delete();
            }

            info.append_str(r_name.__ptr__())->append("\" to struct \"");
            info.append_str(t_name.__ptr__());
            info.append("\"");
            self->err->error(n->to->base.location.__ptr__(), info.c_str);
            return type::error_type();
        }

        n->base.resolved_type.reset_with(type_res.__ptr__());
        var ret = type_res.clone();
        return ret;
    }

    func resolve_identifier(self, n: ast_identifier*) -> type {
        var name = n->content.__ptr__();
        if (self->ctx->find_local(name)) {
            self->ctx->add_var_used(name);
            return self->ctx->get_local(name)->clone();
        }

        var dm: colgm_module* = nil;
        var n_ast = n => ast*;
        if (n_ast->is_redirected()) {
            dm = self->ctx->get_domain(n_ast->redirect_location.__ptr__());
        } else {
            dm = self->ctx->get_domain(n_ast->location.file.__ptr__());
        }

        if (dm->global_symbol.has(name)) {
            var sym_info = dm->global_symbol.get(name);
            if (!sym_info->is_public) {
                var info = str::from("\"");
                defer info.delete();

                info.append_str(name);
                info.append("\" is not imported");
                self->err->error(n_ast->location.__ptr__(), info.c_str);
                return type::error_type();
            }

            var result = type::instance(name->c_str, sym_info->loc_file.c_str);
            result.pointer_depth = 0;
            result.is_global_sym = true;
            result.is_global_func = sym_info->kind == symbol_kind::func_kind;
            return result;
        }

        var info = str::from("undefined symbol \"");
        defer info.delete();

        info.append_str(name);
        info.append_char('\"');
        self->err->error(n_ast->location.__ptr__(), info.c_str);
        return type::error_type();
    }

    func resolve_call_identifier(self, n: ast_call_id*) -> type {
        var infer = self->resolve_identifier(n->id);
        if (infer.is_error()) {
            return infer;
        }

        if (n->generic_types != nil && !infer.is_global_sym) {
            self->err->error(n->base.location.__ptr__(),
                "cannot instantiate generic type of non-global symbol"
            );
        }

        if (n->generic_types != nil) {
            var types = vec<type>::instance();
            defer types.delete();

            foreach (var i; n->generic_types->types) {
                var ty = self->tr.resolve(i.get() => ast_type_def*);
                defer ty.delete();

                types.push(ty.__ptr__());
            }

            var name = n->id->content.clone();
            defer name.delete();
            name.append_char('<');

            foreach (var i; types) {
                var full_name = i.get()->full_path_name_with_pointer(self->pkg);
                defer full_name.delete();

                name.append_str(full_name.__ptr__());
                name.append_char(',');
            }
            if (name.back() == ',') {
                name.pop_back();
            }
            name.append_char('>');

            if (!self->ctx->has_domain(infer.loc_file.__ptr__())) {
                var info = str::from("namespace in \"");
                defer info.delete();

                info.append_str(infer.loc_file.__ptr__());
                info.append("\" not found");
                self->err->error(n->base.location.__ptr__(), info.c_str);
                return infer;
            }

            var dm = self->ctx->get_domain(infer.loc_file.__ptr__());
            if (dm->structs.has(name.__ptr__()) ||
                dm->functions.has(name.__ptr__())) {
                infer.name.delete();
                infer.name = n->id->content.clone();
                infer.generics.delete();
                infer.generics = types.clone();
            } else {
                var info = str::from("error resolving generic symbol \"");
                defer info.delete();

                info.append_str(name.__ptr__());
                info.append("\" in namespace \"");
                info.append_str(infer.loc_file.__ptr__());
                info.append("\"");
                self->err->error(n->base.location.__ptr__(), info.c_str);
            }
        }

        n->base.resolved_type.reset_with(infer.__ptr__());
        return infer;
    }

    func check_struct_pub_method(self,
                                 n: ast*,
                                 name: str*,
                                 struct_self: colgm_struct*) {
        if (!struct_self->method.has(name)) {
            return;
        }

        var m = struct_self->method.get(name);
        if (m->is_public) {
            return;
        }

        if (self->impl_struct_name.empty() ||
            !self->impl_struct_name.eq(struct_self->name.__ptr__())) {
            var info = str::from("cannot access private method \"");
            defer info.delete();

            info.append_str(struct_self->name.__ptr__());
            info.append("::");
            info.append_str(name);
            info.append("\"");
            self->err->error(n->location.__ptr__(), info.c_str);
        }
    }

    func check_tagged_union_pub_method(self,
                                       n: ast*,
                                       name: str*,
                                       union_self: colgm_tagged_union*) {
        if (!union_self->method.has(name)) {
            return;
        }

        var m = union_self->method.get(name);
        if (m->is_public) {
            return;
        }

        if (self->impl_struct_name.empty() ||
            !self->impl_struct_name.eq(union_self->name.__ptr__())) {
            var info = str::from("cannot access private method \"");
            defer info.delete();

            info.append_str(union_self->name.__ptr__());
            info.append("::");
            info.append_str(name);
            info.append("\"");
            self->err->error(n->location.__ptr__(), info.c_str);
        }
    }

    func struct_method_infer(self, prev: type*, fn_name: str*) -> type {
        var infer = prev->clone();
        infer.pointer_depth = 0;
        infer.is_global_sym = true;
        infer.m_info.set_normal_struct_method(fn_name->c_str);
        return infer;
    }

    func struct_static_method_infer(self, prev: type*, fn_name: str*) -> type {
        var infer = prev->clone();
        infer.pointer_depth = 0;
        infer.is_global_sym = true;
        infer.m_info.set_static_struct_method(fn_name->c_str);
        return infer;
    }

    func resolve_get_field(self, prev: type*, n: ast_get_field*) -> type {
        var prev_name = prev->full_path_name_with_pointer(self->pkg);
        defer prev_name.delete();

        var prev_name_for_search = prev->generic_name(self->pkg);
        defer prev_name_for_search.delete();

        if (prev->is_global_sym) {
            self->err->out("cannot get field from global symbol \"")
                     ->out(prev_name.c_str)
                     ->out("\"")
                     ->emit_err(n->base.location.__ptr__());
            return type::error_type();
        }

        if (prev->is_pointer()) {
            self->err->out("cannot use \".\" to get field from pointer \"")
                     ->out(prev_name.c_str)
                     ->out("\".")
                     ->out_note("maybe you mean \"->\"?")
                     ->emit_err(n->operator_location.__ptr__());
            // report but continue resolving
        }

        // loc_file is empty means prev is native type
        if (prev->loc_file.empty()) {
            return self->resolve_primitive_get_field(
                prev,
                n->name.__ptr__(),
                n->base.location.__ptr__()
            );
        }

        var dm = self->ctx->get_domain(prev->loc_file.__ptr__());
        if (dm->structs.has(prev_name_for_search.__ptr__())) {
            var res = self->resolve_struct_get_field(
                dm->structs.get(prev_name_for_search.__ptr__()),
                prev,
                n
            );
            return res;
        } else if (dm->tagged_unions.has(prev_name_for_search.__ptr__())) {
            var res = self->resolve_tagged_union_get_field(
                dm->tagged_unions.get(prev_name_for_search.__ptr__()),
                prev,
                n
            );
            return res;
        }

        self->err->out("cannot get field from \"")
                 ->out(prev_name.c_str)
                 ->out("\"")
                 ->emit_err(n->base.location.__ptr__());
        return type::error_type();
    }

    func resolve_primitive_get_field(self, prev: type*, method_name: str*, loc: span*) -> type {
        var prev_name_for_search = prev->generic_name(self->pkg);
        defer prev_name_for_search.delete();

        if (!self->ctx->global->primitives.has(prev_name_for_search.__ptr__())) {
            var info = str::from("cannot get method from primitive type \"");
            defer info.delete();

            info.append_str(prev_name_for_search.__ptr__());
            info.append("\"");
            self->err->error(loc, info.c_str);
            return type::error_type();
        }

        var p = self->ctx->global->primitives.get(prev_name_for_search.__ptr__());
        if (!p->method.has(method_name)) {
            var info = str::from("cannot find method \"");
            defer info.delete();

            info.append_str(method_name);
            info.append("\" in \"");
            info.append_str(prev_name_for_search.__ptr__());
            info.append("\"");
            self->err->error(loc, info.c_str);
            return type::error_type();
        }

        var infer = prev->clone();
        infer.pointer_depth = 0;
        infer.is_global_sym = true;
        infer.m_info.set_normal_primitive_method(method_name->c_str);
        return infer;
    }

    func resolve_struct_get_field(self,
                                  struct_self: colgm_struct*,
                                  prev: type*,
                                  n: ast_get_field*) -> type {
        var prev_name = prev->full_path_name_with_pointer(self->pkg);
        defer prev_name.delete();

        var prev_name_for_search = prev->generic_name(self->pkg);
        defer prev_name_for_search.delete();

        if (struct_self->fields.has(n->name.__ptr__())) {
            var infer = struct_self->fields.get(n->name.__ptr__())->clone();
            n->base.resolved_type.reset_with(infer.__ptr__());
            return infer;
        }
        if (struct_self->method.has(n->name.__ptr__())) {
            self->check_struct_pub_method(n => ast*, n->name.__ptr__(), struct_self);
            var infer = self->struct_method_infer(prev, n->name.__ptr__());
            n->base.resolved_type.reset_with(infer.__ptr__());
            return infer;
        }

        if (struct_self->static_method.has(n->name.__ptr__())) {
            self->err->out("method \"")
                     ->out(n->name.c_str)
                     ->out("\" in \"")
                     ->out(prev_name.c_str)
                     ->out("\" is static")
                     ->emit_err(n->base.location.__ptr__());
            return type::error_type();
        }

        var fuzzy_field = struct_self->fuzzy_match_field(n->name);
        defer fuzzy_field.delete();

        self->err->report_field_not_found(
            n->base.location.__ptr__(),
            n->name.c_str,
            prev_name_for_search.c_str,
            fuzzy_field.c_str,
            struct_self->get_field_span(fuzzy_field.__ptr__())
        );
        return type::error_type();
    }

    func resolve_tagged_union_get_field(self,
                                        union_self: colgm_tagged_union*,
                                        prev: type*,
                                        n: ast_get_field*) -> type {
        var prev_name = prev->full_path_name_with_pointer(self->pkg);
        defer prev_name.delete();

        var prev_name_for_search = prev->generic_name(self->pkg);
        defer prev_name_for_search.delete();

        if (union_self->members.has(n->name.__ptr__())) {
            var infer = union_self->members.get(n->name.__ptr__())->clone();
            n->base.resolved_type.reset_with(infer.__ptr__());
            return infer;
        }
        if (union_self->method.has(n->name.__ptr__())) {
            self->check_tagged_union_pub_method(n => ast*, n->name.__ptr__(), union_self);
            var infer = self->struct_method_infer(prev, n->name.__ptr__());
            n->base.resolved_type.reset_with(infer.__ptr__());
            return infer;
        }

        if (union_self->static_method.has(n->name.__ptr__())) {
            self->err->out("method \"")
                     ->out(n->name.c_str)
                     ->out("\" in \"")
                     ->out(prev_name.c_str)
                     ->out("\" is static")
                     ->emit_err(n->base.location.__ptr__());
            return type::error_type();
        }

        var fuzzy_field = union_self->fuzzy_match_field(n->name);
        defer fuzzy_field.delete();

        self->err->report_field_not_found(
            n->base.location.__ptr__(),
            n->name.c_str,
            prev_name_for_search.c_str,
            fuzzy_field.c_str,
            union_self->get_member_span(fuzzy_field.__ptr__())
        );
        return type::error_type();
    }

    func check_can_be_referenced(self, n: ast*) -> bool {
        match (n->kind) {
            ast_kind::ast_nil_literal => return false;
            ast_kind::ast_number_literal => return false;
            ast_kind::ast_string_literal => return false;
            ast_kind::ast_bool_literal => return false;
            ast_kind::ast_char_literal => return false;
            ast_kind::ast_array_list => return false;
            _ => return true;
        }
        return true;
    }

    func check_static_call_args(self,
                                func_self: colgm_func*,
                                n: ast_call_func_args*) {
        if (func_self->unordered_params.size != n->args.size) {
            self->err->report_wrong_arg_num(
                n->base.location.__ptr__(),
                func_self->location.__ptr__(),
                func_self->unordered_params.size,
                n->args.size
            );
            return;
        }

        foreach (var i; n->args) {
            var arg = i.get();
            var infer = self->resolve_expression(arg);
            defer infer.delete();

            if (infer.is_error()) {
                continue;
            }
            var param = func_self->param_type.get(i.index());
            if (!infer.eq(param)) {
                if (!self->check_can_be_converted(arg, param)) {
                    var info = str::from("expect \"");
                    defer info.delete();

                    var param_name = param->full_path_name_with_pointer(self->pkg);
                    defer param_name.delete();

                    info.append_str(param_name.__ptr__());
                    info.append("\" but get \"");
                    var infer_name = infer.full_path_name_with_pointer(self->pkg);
                    defer infer_name.delete();

                    info.append_str(infer_name.__ptr__());
                    info.append("\"");
                    self->err->error(arg->location.__ptr__(), info.c_str);
                }
            } elsif (param->is_reference && !self->check_can_be_referenced(arg)) {
                self->err->error(
                    arg->location.__ptr__(),
                    "cannot pass literal as reference"
                );
            }
            if (param->is_reference) {
                n->args_is_ref.c_data()[i.index()] = true;
            }
        }
    }

    func check_method_call_args(self,
                                func_self: colgm_func*,
                                n: ast_call_func_args*) {
        if (func_self->unordered_params.size != n->args.size + 1) {
            self->err->report_wrong_arg_num(
                n->base.location.__ptr__(),
                func_self->location.__ptr__(),
                func_self->unordered_params.size - 1,
                n->args.size
            );
            return;
        }

        foreach (var i; n->args) {
            var arg = i.get();
            var infer = self->resolve_expression(arg);
            defer infer.delete();

            if (infer.is_error()) {
                continue;
            }
            var param = func_self->param_type.get(i.index() + 1);
            if (!infer.eq(param)) {
                if (!self->check_can_be_converted(arg, param)) {
                    var info = str::from("expect \"");
                    defer info.delete();

                    var param_name = param->full_path_name_with_pointer(self->pkg);
                    defer param_name.delete();

                    info.append_str(param_name.__ptr__());
                    info.append("\" but get \"");
                    var infer_name = infer.full_path_name_with_pointer(self->pkg);
                    defer infer_name.delete();

                    info.append_str(infer_name.__ptr__());
                    info.append("\"");
                    self->err->error(arg->location.__ptr__(), info.c_str);
                }
            } elsif (param->is_reference && !self->check_can_be_referenced(arg)) {
                self->err->error(
                    arg->location.__ptr__(),
                    "cannot pass literal as reference"
                );
            }
            if (param->is_reference) {
                // method call do not need to pass the reference of 'self'
                // so there's no need to add 1 to the index
                n->args_is_ref.c_data()[i.index()] = true;
            }
        }
    }

    func resolve_call_func_args(self, prev: type*, n: ast_call_func_args*) -> type {
        var prev_name_for_search = prev->generic_name(self->pkg);
        defer prev_name_for_search.delete();

        // global function call
        if (prev->is_global_func) {
            var dm = self->ctx->get_domain(prev->loc_file.__ptr__());
            var func_self = dm->functions.get(prev_name_for_search.__ptr__());
            self->check_static_call_args(func_self, n);

            var infer = func_self->return_type.clone();
            n->base.resolved_type.reset_with(infer.__ptr__());
            return infer;
        }

        // static method call of native type
        if (prev->m_info.is_primitive_method && prev->m_info.flag_is_static) {
            var primitive = self->ctx->global->primitives.get(prev_name_for_search.__ptr__());
            var method = primitive->static_method.get(
                prev->m_info.method_name.__ptr__()
            );
            self->check_static_call_args(method, n);

            var infer = method->return_type.clone();
            n->base.resolved_type.reset_with(infer.__ptr__());
            return infer;
        }

        // method call of native type
        if (prev->m_info.is_primitive_method && prev->m_info.flag_is_normal) {
            var primitive = self->ctx->global->primitives.get(prev_name_for_search.__ptr__());
            var method = primitive->method.get(
                prev->m_info.method_name.__ptr__()
            );
            self->check_method_call_args(method, n);

            var infer = method->return_type.clone();
            n->base.resolved_type.reset_with(infer.__ptr__());
            return infer;
        }

        // static method call of struct
        if (prev->m_info.is_struct_method && prev->m_info.flag_is_static) {
            var dm = self->ctx->get_domain(prev->loc_file.__ptr__());
            if (dm->structs.has(prev_name_for_search.__ptr__())) {
                var struct_self = dm->structs.get(prev_name_for_search.__ptr__());
                var method = struct_self->static_method.get(
                    prev->m_info.method_name.__ptr__()
                );
                self->check_static_call_args(method, n);

                var infer = method->return_type.clone();
                n->base.resolved_type.reset_with(infer.__ptr__());
                return infer;
            } else if (dm->tagged_unions.has(prev_name_for_search.__ptr__())) {
                var union_self = dm->tagged_unions.get(prev_name_for_search.__ptr__());
                var method = union_self->static_method.get(
                    prev->m_info.method_name.__ptr__()
                );
                self->check_static_call_args(method, n);

                var infer = method->return_type.clone();
                n->base.resolved_type.reset_with(infer.__ptr__());
                return infer;
            }
            self->err->out("cannot find \"")
                     ->out(prev_name_for_search.c_str)
                     ->out("\"")
                     ->emit_err(n->base.location.__ptr__());
            return type::error_type();
        }

        // normal method call of struct
        if (prev->m_info.is_struct_method && prev->m_info.flag_is_normal) {
            var dm = self->ctx->get_domain(prev->loc_file.__ptr__());
            if (dm->structs.has(prev_name_for_search.__ptr__())) {
                var struct_self = dm->structs.get(prev_name_for_search.__ptr__());
                var method = struct_self->method.get(
                    prev->m_info.method_name.__ptr__()
                );
                self->check_method_call_args(method, n);

                var infer = method->return_type.clone();
                n->base.resolved_type.reset_with(infer.__ptr__());
                return infer;
            } else if (dm->tagged_unions.has(prev_name_for_search.__ptr__())) {
                var union_self = dm->tagged_unions.get(prev_name_for_search.__ptr__());
                var method = union_self->method.get(
                    prev->m_info.method_name.__ptr__()
                );
                self->check_method_call_args(method, n);

                var infer = method->return_type.clone();
                n->base.resolved_type.reset_with(infer.__ptr__());
                return infer;
            }

            self->err->out("cannot find \"")
                     ->out(prev_name_for_search.c_str)
                     ->out("\"")
                     ->emit_err(n->base.location.__ptr__());
            return type::error_type();
        }

        self->err->error(n->base.location.__ptr__(), "cannot call non-function");
        return type::error_type();
    }

    func resolve_call_index(self, prev: type*, n: ast_call_index*) -> type {
        if (prev->is_global_sym) {
            var info = str::from("cannot get index from global symbol \"");
            defer info.delete();

            var prev_name = prev->generic_name(self->pkg);
            defer prev_name.delete();

            info.append_str(prev_name.__ptr__());
            info.append("\"");
            self->err->error(n->base.location.__ptr__(), info.c_str);
            return type::error_type();
        }

        if (!prev->is_pointer()) {
            var info = str::from("cannot get index from \"");
            defer info.delete();

            var prev_name = prev->full_path_name_with_pointer(self->pkg);
            defer prev_name.delete();

            info.append_str(prev_name.__ptr__());
            info.append("\"");
            self->err->error(n->base.location.__ptr__(), info.c_str);
            return type::error_type();
        }

        // resolve index infer, not necessary to check if it is error type
        var index_infer = self->resolve_expression(n->index);
        defer index_infer.delete();

        if (!index_infer.is_error()) {
            if (!index_infer.is_integer() || index_infer.is_pointer()) {
                var info = str::from("cannot get index with \"");
                defer info.delete();

                var ii_name = index_infer.full_path_name_with_pointer(self->pkg);
                defer ii_name.delete();

                info.append_str(ii_name.__ptr__());
                info.append("\"");
                self->err->error(n->base.location.__ptr__(), info.c_str);
            }
        }

        var infer = prev->ref_copy();
        // remove array type flag to make it mutable
        infer.is_array = false;
        n->base.resolved_type.reset_with(infer.__ptr__());
        return infer;
    }

    func resolve_call_path(self, prev: type*, n: ast_call_path*) -> type {
        if (!prev->is_global_sym) {
            self->err->error(n->base.location.__ptr__(), "cannot get path from non-global symbol");
            return type::error_type();
        }

        var prev_name_for_search = prev->generic_name(self->pkg);
        defer prev_name_for_search.delete();

        // loc_file is empty means prev is native type
        if (prev->loc_file.empty()) {
            return self->resolve_primitive_call_path(prev, n);
        }

        var dm = self->ctx->get_domain(prev->loc_file.__ptr__());
        if (dm->structs.has(prev_name_for_search.__ptr__())) {
            return self->resolve_struct_call_path(prev, n);
        } else if (dm->enums.has(prev_name_for_search.__ptr__())) {
            var en = dm->enums.get(prev_name_for_search.__ptr__());
            if (en->members.has(n->name.__ptr__())) {
                var infer = prev->clone();
                infer.is_global_sym = false;
                infer.is_enum = true;
                n->base.resolved_type.reset_with(infer.__ptr__());
                return infer;
            }

            self->err->out("cannot find enum member \"")
                     ->out(n->name.c_str)
                     ->out("\" in enum \"")
                     ->out(prev_name_for_search.c_str)
                     ->out("\"")
                     ->emit_err(n->base.location.__ptr__());
            return type::error_type();
        } else if (dm->tagged_unions.has(prev_name_for_search.__ptr__())) {
            return self->resolve_tagged_union_call_path(prev, n);
        } else {
            var info = str::from("cannot find path \"");
            defer info.delete();

            info.append_str(n->name.__ptr__());
            info.append("\" in \"");
            info.append_str(prev_name_for_search.__ptr__());
            info.append("\"");
            self->err->error(n->base.location.__ptr__(), info.c_str);
            return type::error_type();
        }

        return type::error_type();
    }

    func resolve_primitive_call_path(self, prev: type*, n: ast_call_path*) -> type {
        var prev_name_for_search = prev->generic_name(self->pkg);
        defer prev_name_for_search.delete();

        if (!self->ctx->global->primitives.has(prev_name_for_search.__ptr__())) {
            var info = str::from("cannot get static method from primitive type \"");
            defer info.delete();

            info.append_str(prev_name_for_search.__ptr__());
            info.append("\"");
            self->err->error(n->base.location.__ptr__(), info.c_str);
            return type::error_type();
        }

        var p = self->ctx->global->primitives.get(prev_name_for_search.__ptr__());
        if (!p->static_method.has(n->name.__ptr__())) {
            var info = str::from("cannot find static method \"");
            defer info.delete();

            info.append_str(n->name.__ptr__());
            info.append("\" in \"");
            info.append_str(prev_name_for_search.__ptr__());
            info.append("\"");
            self->err->error(n->base.location.__ptr__(), info.c_str);
            return type::error_type();
        }

        var infer = prev->clone();
        infer.pointer_depth = 0;
        infer.is_global_sym = true;
        infer.m_info.set_static_primitive_method(n->name.c_str);
        return infer;
    }

    func resolve_struct_call_path(self, prev: type*, n: ast_call_path*) -> type {
        var prev_name_for_search = prev->generic_name(self->pkg);
        defer prev_name_for_search.delete();

        var dm = self->ctx->get_domain(prev->loc_file.__ptr__());
        var st = dm->structs.get(prev_name_for_search.__ptr__());
        if (st->static_method.has(n->name.__ptr__())) {
            self->check_struct_pub_method(n => ast*, n->name.__ptr__(), st);
            var infer = self->struct_static_method_infer(prev, n->name.__ptr__());
            n->base.resolved_type.reset_with(infer.__ptr__());
            return infer;
        } else if (st->method.has(n->name.__ptr__())) {
            self->err->report_non_static_method(
                n->base.location.__ptr__(),
                prev_name_for_search.c_str,
                n->name.c_str,
                st->method.get(n->name.__ptr__())->location.__ptr__()
            );
            return type::error_type();
        } else {
            var info = str::from("cannot find static method \"");
            defer info.delete();

            info.append_str(n->name.__ptr__());
            info.append("\" in \"");
            info.append_str(prev_name_for_search.__ptr__());
            info.append("\"");

            var note = str::from("maybe you mean \"");
            defer note.delete();

            var fuzzy = st->fuzzy_match_field(n->name);
            defer fuzzy.delete();

            note.append_str(fuzzy.__ptr__());
            note.append("\"?");

            self->err->error_with_note(
                n->base.location.__ptr__(),
                info.c_str,
                note.c_str
            );
            return type::error_type();
        }
        // unreachable
        return type::error_type();
    }

    func resolve_tagged_union_call_path(self, prev: type*, n: ast_call_path*) -> type {
        var prev_name_for_search = prev->generic_name(self->pkg);
        defer prev_name_for_search.delete();

        var dm = self->ctx->get_domain(prev->loc_file.__ptr__());
        var tu = dm->tagged_unions.get(prev_name_for_search.__ptr__());
        if (tu->static_method.has(n->name.__ptr__())) {
            self->check_tagged_union_pub_method(n => ast*, n->name.__ptr__(), tu);
            var infer = self->struct_static_method_infer(prev, n->name.__ptr__());
            n->base.resolved_type.reset_with(infer.__ptr__());
            return infer;
        } else if (tu->method.has(n->name.__ptr__())) {
            self->err->report_non_static_method(
                n->base.location.__ptr__(),
                prev_name_for_search.c_str,
                n->name.c_str,
                tu->method.get(n->name.__ptr__())->location.__ptr__()
            );
            return type::error_type();
        } else {
            var info = str::from("cannot find static method \"");
            defer info.delete();

            info.append_str(n->name.__ptr__());
            info.append("\" in \"");
            info.append_str(prev_name_for_search.__ptr__());
            info.append("\"");

            var note = str::from("maybe you mean \"");
            defer note.delete();

            var fuzzy = tu->fuzzy_match_field(n->name);
            defer fuzzy.delete();

            note.append_str(fuzzy.__ptr__());
            note.append("\"?");

            self->err->error_with_note(
                n->base.location.__ptr__(),
                info.c_str,
                note.c_str
            );
            return type::error_type();
        }
        // unreachable
        return type::error_type();
    }

    func resolve_initializer(self, prev: type*, n: ast_initializer*) -> type {
        if (!prev->is_global_sym) {
            self->err->error(n->base.location.__ptr__(),
                "need a global symbol to initialize"
            );
            return type::error_type();
        }
        if (prev->loc_file.empty()) {
            self->err->error(n->base.location.__ptr__(),
                "basic type cannot be initialized as a struct"
            );
            return type::error_type();
        }

        var dm = self->ctx->get_domain(prev->loc_file.__ptr__());
        var prev_name_for_search = prev->generic_name(self->pkg);
        defer prev_name_for_search.delete();

        if (dm->structs.has(prev_name_for_search.__ptr__())) {
            var struct_self = dm->structs.get(prev_name_for_search.__ptr__());
            return self->resolve_struct_initializer(struct_self, prev, n);
        } else if (dm->tagged_unions.has(prev_name_for_search.__ptr__())) {
            var union_self = dm->tagged_unions.get(prev_name_for_search.__ptr__());
            return self->resolve_tagged_union_initializer(union_self, prev, n);
        }

        var info = str::from("\"");
        defer info.delete();

        info.append_str(prev_name_for_search.__ptr__());
        info.append("\" is not struct or tagged union, cannot initialize");
        self->err->error(n->base.location.__ptr__(), info.c_str);
        return type::error_type();
    }

    func resolve_struct_initializer(self, struct_self: colgm_struct*, prev: type*, n: ast_initializer*) -> type {
        var prev_name_for_search = prev->generic_name(self->pkg);
        defer prev_name_for_search.delete();

        var copy = prev->clone();
        copy.is_global_sym = false;
        n->base.resolved_type.reset_with(copy.__ptr__());

        foreach (var i; n->pairs) {
            var tmp = i.get() => ast_init_pair*;
            var field = tmp->field->content.__ptr__();
            if (!struct_self->fields.has(field)) {
                var info = str::from("cannot find field \"");
                defer info.delete();

                info.append_str(field);
                info.append("\" in \"");
                info.append_str(prev_name_for_search.__ptr__());
                info.append("\"");
                self->err->error(tmp->base.location.__ptr__(), info.c_str);
                continue;
            }

            var infer = self->resolve_expression(tmp->value);
            defer infer.delete();

            tmp->base.resolved_type.reset_with(infer.__ptr__());
            if (infer.is_error()) {
                continue;
            }

            var expect = struct_self->fields.get(field);
            if (!infer.eq(expect)) {
                if (!self->check_can_be_converted(tmp->value, expect)) {
                    var info = str::from("expect \"");
                    var e_name = expect->full_path_name_with_pointer(self->pkg);
                    var i_name = infer.full_path_name_with_pointer(self->pkg);
                    defer {
                        info.delete();
                        e_name.delete();
                        i_name.delete();
                    }

                    info.append_str(e_name.__ptr__());
                    info.append("\" but get \"");
                    info.append_str(i_name.__ptr__());
                    self->err->error(tmp->base.location.__ptr__(), info.c_str);                    
                    continue;
                }
            }
            // struct foo { bar: [0, 1, 2] } is not allowed
            if (infer.is_array) {
                self->err->error(
                    tmp->base.location.__ptr__(),
                    "cannot initialize array, but it's already filled with 0 by default"
                );
            }
        }

        return copy;
    }

    func resolve_tagged_union_initializer(self, union_self: colgm_tagged_union*, prev: type*, n: ast_initializer*) -> type {
        var prev_name_for_search = prev->generic_name(self->pkg);
        defer prev_name_for_search.delete();

        var copy = prev->clone();
        copy.is_global_sym = false;
        n->base.resolved_type.reset_with(copy.__ptr__());

        if (n->pairs.size > 1) {
            self->err->error(
                n->base.location.__ptr__(),
                "cannot initialize tagged union with more than one member"
            );
            return copy;
        } else if (n->pairs.empty()) {
            self->err->error(
                n->base.location.__ptr__(),
                "tagged union's initializer cannot be empty"
            );
            return copy;
        }

        var tmp = n->pairs.get(0) => ast_init_pair*;
        var member = tmp->field->content.__ptr__();
        if (!union_self->members.has(member)) {
            var info = str::from("cannot find member \"");
            defer info.delete();

            info.append_str(member);
            info.append("\" in \"");
            info.append_str(prev_name_for_search.__ptr__());
            info.append("\"");
            self->err->error(tmp->base.location.__ptr__(), info.c_str);
            return copy;
        }

        var infer = self->resolve_expression(tmp->value);
        defer infer.delete();

        tmp->base.resolved_type.reset_with(infer.__ptr__());
        if (infer.is_error()) {
            return copy;
        }

        var expect = union_self->members.get(member);
        if (!infer.eq(expect)) {
            if (!self->check_can_be_converted(tmp->value, expect)) {
                var info = str::from("expect \"");
                var e_name = expect->full_path_name_with_pointer(self->pkg);
                var i_name = infer.full_path_name_with_pointer(self->pkg);
                defer {
                    info.delete();
                    e_name.delete();
                    i_name.delete();
                }

                info.append_str(e_name.__ptr__());
                info.append("\" but get \"");
                info.append_str(i_name.__ptr__());
                self->err->error(tmp->base.location.__ptr__(), info.c_str);                    
                return copy;
            }
        }
        // struct foo { bar: [0, 1, 2] } is not allowed
        if (infer.is_array) {
            self->err->error(
                tmp->base.location.__ptr__(),
                "cannot initialize array, but it's already filled with 0 by default"
            );
        }

        return copy;
    }

    func resolve_ptr_get_field(self, prev: type*, n: ast_ptr_get_field*) -> type {
        var prev_name = prev->full_path_name_with_pointer(self->pkg);
        defer prev_name.delete();

        var prev_name_for_search = prev->generic_name(self->pkg);
        defer prev_name_for_search.delete();

        if (prev->is_global_sym) {
            self->err->out("cannot get field from global symbol \"")
                     ->out(prev_name.c_str)
                     ->out("\"")
                     ->emit_err(n->base.location.__ptr__());
            return type::error_type();
        }

        if (prev->pointer_depth == 0) {
            self->err->out("cannot use \"->\" to get field from \"")
                     ->out(prev_name.c_str)
                     ->out("\"")
                     ->out_note("use \".\" instead")
                     ->emit_err(n->operator_location.__ptr__());
            // report but continue resolving
        } else if (prev->pointer_depth > 1) {
            self->err->out("cannot use \"->\" to get field from pointer \"")
                     ->out(prev_name.c_str)
                     ->out("\"")
                     ->emit_err(n->operator_location.__ptr__());
            // report but continue resolving
        }

        // loc_file is empty means prev is native type
        if (prev->loc_file.empty()) {
            return self->resolve_primitive_get_field(
                prev,
                n->name.__ptr__(),
                n->base.location.__ptr__()
            );
        }

        var dm = self->ctx->get_domain(prev->loc_file.__ptr__());
        if (dm->structs.has(prev_name_for_search.__ptr__())) {
            var res = self->resolve_struct_ptr_get_field(
                dm->structs.get(prev_name_for_search.__ptr__()),
                prev,
                n
            );
            return res;
        } else if (dm->tagged_unions.has(prev_name_for_search.__ptr__())) {
            var res = self->resolve_tagged_union_ptr_get_field(
                dm->tagged_unions.get(prev_name_for_search.__ptr__()),
                prev,
                n
            );
            return res;
        }

        var info = str::from("cannot get field from undefined struct \"");
        defer info.delete();

        info.append_str(prev_name.__ptr__());
        info.append("\"");
        self->err->error(n->base.location.__ptr__(), info.c_str);
        return type::error_type();
    }

    func resolve_struct_ptr_get_field(self,
                                      struct_self: colgm_struct*,
                                      prev: type*,
                                      n: ast_ptr_get_field*) -> type {
        var prev_name = prev->full_path_name_with_pointer(self->pkg);
        defer prev_name.delete();

        var prev_name_for_search = prev->generic_name(self->pkg);
        defer prev_name_for_search.delete();
        
        if (struct_self->fields.has(n->name.__ptr__())) {
            var infer = struct_self->fields.get(n->name.__ptr__())->clone();
            n->base.resolved_type.reset_with(infer.__ptr__());
            return infer;
        }
        if (struct_self->method.has(n->name.__ptr__())) {
            self->check_struct_pub_method(n => ast*, n->name.__ptr__(), struct_self);
            var infer = self->struct_method_infer(prev, n->name.__ptr__());
            n->base.resolved_type.reset_with(infer.__ptr__());
            return infer;
        }

        if (struct_self->static_method.has(n->name.__ptr__())) {
            self->err->out("method \"")
                     ->out(n->name.c_str)
                     ->out("\" in \"")
                     ->out(prev_name.c_str)
                     ->out("\" is static")
                     ->emit_err(n->base.location.__ptr__());
            return type::error_type();
        }

        var fuzzy_field = struct_self->fuzzy_match_field(n->name);
        defer fuzzy_field.delete();

        self->err->report_field_not_found(
            n->base.location.__ptr__(),
            n->name.c_str,
            prev_name_for_search.c_str,
            fuzzy_field.c_str,
            struct_self->get_field_span(fuzzy_field.__ptr__())
        );
        return type::error_type();
    }

    func resolve_tagged_union_ptr_get_field(self,
                                            union_self: colgm_tagged_union*,
                                            prev: type*,
                                            n: ast_ptr_get_field*) -> type {
        var prev_name = prev->full_path_name_with_pointer(self->pkg);
        defer prev_name.delete();

        var prev_name_for_search = prev->generic_name(self->pkg);
        defer prev_name_for_search.delete();
        
        if (union_self->members.has(n->name.__ptr__())) {
            var infer = union_self->members.get(n->name.__ptr__())->clone();
            n->base.resolved_type.reset_with(infer.__ptr__());
            return infer;
        }
        if (union_self->method.has(n->name.__ptr__())) {
            self->check_tagged_union_pub_method(n => ast*, n->name.__ptr__(), union_self);
            var infer = self->struct_method_infer(prev, n->name.__ptr__());
            n->base.resolved_type.reset_with(infer.__ptr__());
            return infer;
        }

        if (union_self->static_method.has(n->name.__ptr__())) {
            self->err->out("method \"")
                     ->out(n->name.c_str)
                     ->out("\" in \"")
                     ->out(prev_name.c_str)
                     ->out("\" is static")
                     ->emit_err(n->base.location.__ptr__());
            return type::error_type();
        }

        var fuzzy_field = union_self->fuzzy_match_field(n->name);
        defer fuzzy_field.delete();

        self->err->report_field_not_found(
            n->base.location.__ptr__(),
            n->name.c_str,
            prev_name_for_search.c_str,
            fuzzy_field.c_str,
            union_self->get_member_span(fuzzy_field.__ptr__())
        );
        return type::error_type();
    }

    func resolve_call(self, n: ast_call*) -> type {
        var infer = self->resolve_call_identifier(n->head);
        defer infer.delete();

        if (infer.is_error()) {
            return type::error_type();
        }

        foreach (var i; n->chain) {
            var c = i.get();
            if (c->kind != ast_kind::ast_call_func_args &&
                infer.is_function()) {
                self->err->error(c->location.__ptr__(), "function should be called before");
                return type::error_type();
            }

            var prev = infer.clone();
            defer prev.delete();

            match (c->kind) {
                ast_kind::ast_get_field => {
                    infer.delete();
                    infer = self->resolve_get_field(
                        prev.__ptr__(),
                        c => ast_get_field*
                    );
                }
                ast_kind::ast_call_func_args => {
                    infer.delete();
                    infer = self->resolve_call_func_args(
                        prev.__ptr__(),
                        c => ast_call_func_args*
                    );
                }
                ast_kind::ast_call_index => {
                    infer.delete();
                    infer = self->resolve_call_index(
                        prev.__ptr__(),
                        c => ast_call_index*
                    );
                }
                ast_kind::ast_call_path => {
                    infer.delete();
                    infer = self->resolve_call_path(
                        prev.__ptr__(),
                        c => ast_call_path*
                    );
                }
                ast_kind::ast_initializer => {
                    infer.delete();
                    infer = self->resolve_initializer(
                        prev.__ptr__(),
                        c => ast_initializer*
                    );
                }
                ast_kind::ast_ptr_get_field => {
                    infer.delete();
                    infer = self->resolve_ptr_get_field(
                        prev.__ptr__(),
                        c => ast_ptr_get_field*
                    );
                }
                _ => {
                    self->err->unimplemented(c->location.__ptr__());
                    return type::error_type();
                }
            }

            // interrupt if error occur
            if (infer.is_error()) {
                return type::error_type();
            }
        }

        // infer should not be a function
        if (infer.is_function()) {
            self->err->error(n->base.location.__ptr__(), "function should be called here");
            return type::error_type();
        }

        n->base.resolved_type.reset_with(infer.__ptr__());
        // infer should not be a global symbol
        if (infer.is_global_sym) {
            self->err->out("get global symbol \"")
                     ->out_type(infer.__ptr__(), self->pkg)
                     ->out("\", but not an instance")
                     ->emit_err(n->base.location.__ptr__());
        }

        var res = infer.clone();
        return res;
    }

    func check_valid_left_value(self, n: ast_call*) -> bool {
        foreach (var i; n->chain) {
            var tmp = i.get();
            if (tmp->kind == ast_kind::ast_initializer) {
                self->err->error(
                    tmp->location.__ptr__(),
                    "bad left value: should not contain initializer"
                );
                return false;
            }
            if (tmp->kind == ast_kind::ast_call_path) {
                self->err->error(
                    tmp->location.__ptr__(),
                    "bad left value: should not contain call path"
                );
                return false;
            }
            if (tmp->kind == ast_kind::ast_call_func_args &&
                !tmp->resolved_type.is_reference &&
                i.index() == n->chain.size - 1) {
                self->err->error(
                    tmp->location.__ptr__(),
                    "bad left value: should not end with function call"
                );
                return false;
            }
        }

        var seg: ast* = nil;
        var maybe_invalid_assignment = false;
        foreach (var i; n->chain) {
            var tmp = i.get();
            if (tmp->kind == ast_kind::ast_call_func_args &&
                !tmp->resolved_type.is_pointer() &&
                !tmp->resolved_type.is_reference) {
                seg = tmp;
                maybe_invalid_assignment = true;
            } else if (tmp->kind == ast_kind::ast_ptr_get_field) {
                maybe_invalid_assignment = false;
            }
        }

        if (maybe_invalid_assignment && seg != nil) {
            self->err->out("function returning non-pointer/non-reference type, ")
                     ->out("will do shallow copy, ")
                     ->out("may cause invalid assignment")
                     ->emit_warn(seg->location.__ptr__());
        }
        return true;
    }

    func check_mutable_left_value(self, n: ast_call*, left: type*) {
        if (left->is_const && !left->is_pointer()) {
            self->err->out("cannot assign to \"const ")
                     ->out_type(left, self->pkg)
                     ->out("\"")
                     ->emit_err(n->base.location.__ptr__());
        } else if (left->is_array) {
            self->err->out("cannot change array \"")
                     ->out_type(left, self->pkg)
                     ->out("\"")
                     ->emit_err(n->base.location.__ptr__());
        }
    }

    func resolve_assignment(self, n: ast_assignment*) -> type {
        var left = self->resolve_expression(n->left => ast*);
        defer left.delete();

        if (!self->check_valid_left_value(n->left)) {
            return type::error_type();
        }

        // left value should be mutable
        self->check_mutable_left_value(n->left, left.__ptr__());

        var right = self->resolve_expression(n->right);
        defer right.delete();

        if (left.is_error() || right.is_error()) {
            return type::error_type();
        }

        if (n->kind == assignment_kind::andeq ||
            n->kind == assignment_kind::xoreq ||
            n->kind == assignment_kind::oreq) {
            if (!left.can_bitwise_calculate()) {
                self->err->out("bitwise operator cannot be used on \"")
                         ->out_type(left.__ptr__(), self->pkg)
                         ->out("\"")
                         ->emit_err(n->left->base.location.__ptr__());
                return type::restrict_type();
            }
            if (!right.can_bitwise_calculate()) {
                self->err->out("bitwise operator cannot be used on \"")
                         ->out_type(right.__ptr__(), self->pkg)
                         ->out("\"")
                         ->emit_err(n->right->location.__ptr__());
                return type::restrict_type();
            }
        }

        if (left.is_pointer() && right.is_pointer()) {
            if (!left.eq(right.__ptr__()) &&
                !self->check_can_be_converted(n->right, left.__ptr__())) {
                self->err->out("cannot calculate \"")
                         ->out_type(left.__ptr__(), self->pkg)
                         ->out("\" and \"")
                         ->out_type(right.__ptr__(), self->pkg)
                         ->out("\"")
                         ->emit_err(n->right->location.__ptr__());
            }
        } else if (!left.eq(right.__ptr__())) {
            if (!self->check_can_be_converted(n->right, left.__ptr__())) {
                self->err->out("get \"")
                         ->out_type(right.__ptr__(), self->pkg)
                         ->out("\" but expect \"")
                         ->out_type(left.__ptr__(), self->pkg)
                         ->out("\"")
                         ->emit_err(n->right->location.__ptr__());
            }
        }

        // only = is allowed to be applied on enums
        if (self->is_enum_type(left.__ptr__()) && n->kind != assignment_kind::eq) {
            self->err->out("cannot calculate enum \"")
                     ->out_type(left.__ptr__(), self->pkg)
                     ->out("\"")
                     ->emit_err(n->left->base.location.__ptr__());
        }

        var res = type::restrict_type();
        n->base.resolved_type.reset_with(res.__ptr__());
        return res;
    }

    func resolve_expression(self, n: ast*) -> type {
        match (n->kind) {
            ast_kind::ast_unary_operator => {
                return self->resolve_unary_operator(n => ast_unary_operator*);
            }
            ast_kind::ast_binary_operator => {
                return self->resolve_binary_operator(n => ast_binary_operator*);
            }
            ast_kind::ast_type_convert => {
                return self->resolve_type_convert(n => ast_type_convert*);
            }
            ast_kind::ast_nil_literal => {
                return self->resolve_nil_literal(n => ast_nil_literal*);
            }
            ast_kind::ast_number_literal => {
                return self->resolve_number_literal(n => ast_number_literal*);
            }
            ast_kind::ast_string_literal => {
                return self->resolve_string_literal(n => ast_string_literal*);
            }
            ast_kind::ast_char_literal => {
                return self->resolve_char_literal(n => ast_char_literal*);
            }
            ast_kind::ast_bool_literal => {
                return self->resolve_bool_literal(n => ast_bool_literal*);
            }
            ast_kind::ast_array_list => {
                return self->resolve_array_list(n => ast_array_list*);
            }
            ast_kind::ast_call => {
                return self->resolve_call(n => ast_call*);
            }
            ast_kind::ast_assignment => {
                return self->resolve_assignment(n => ast_assignment*);
            }
            _ => { unreachable(); }
        }
        return type::error_type();
    }
}

impl sema {
    func check_defined_variable_is_void(self, n: ast_definition*, ty: type*) {
        if (!ty->is_void()) {
            return;
        }
        self->err->error(
            n->base.location.__ptr__(),
            "cannot define variable with void type"
        );
    }

    func number_literal_can_be_converted(self, n: ast*, expect_type: type*) -> bool {
        // if is not number literal, just return false
        if (!n->is(ast_kind::ast_number_literal)) {
            return false;
        }

        // check if number literal is pointer type
        // in most cases it should not be pointer type
        var n_type = n->resolved_type.__ptr__();
        if (n_type->is_pointer()) {
            return false;
        }

        // if expect a pointer type,
        if (expect_type->is_pointer()) {
            // allow integer to convert to pointer may cause confusion
            // because if user used C before, in this example:
            //   <i64*> s += 1
            // in fact this is equal to:
            //   <i8*> s += 8
            // to avoid this confusion, we should not allow this conversion
            return false;
        }

        // use same integer type as expected
        if (expect_type->is_integer() && n_type->is_integer()) {
            n->resolved_type.reset_with(expect_type);
            return true;
        }
        // use same float type as expected
        if (expect_type->is_float() && n_type->is_float()) {
            n->resolved_type.reset_with(expect_type);
            return true;
        }

        return false;
    }

    func unary_number_can_be_converted(self, n: ast*, expect_type: type*) -> bool {
        if (!n->is(ast_kind::ast_unary_operator)) {
            return false;
        }
        var UO = n => ast_unary_operator*;
        if (UO->kind != unary_kind::neg) {
            return false;
        }
        if (self->number_literal_can_be_converted(UO->value, expect_type)) {
            n->resolved_type.reset_with(expect_type);
            return true;
        }
        return false;
    }

    func nil_can_be_convered(self, n: ast*, expect_type: type*) -> bool {
        if (!n->is(ast_kind::ast_nil_literal)) {
            return false;
        }
        if (!expect_type->is_pointer()) {
            return false;
        }
        n->resolved_type.reset_with(expect_type);
        return true;
    }

    func check_can_be_converted(self, n: ast*, expect_type: type*) -> bool {
        if (self->number_literal_can_be_converted(n, expect_type)) {
            return true;
        }
        if (self->unary_number_can_be_converted(n, expect_type)) {
            return true;
        }
        if (self->nil_can_be_convered(n, expect_type)) {
            return true;
        }
        return false;
    }

    func check_local_variable_conflict(self, name: str*, loc: span*) -> bool {
        // check if conflicts with local variable
        if (self->ctx->find_local(name)) {
            var shadowed_loc = self->ctx->get_local_def_location(name);
            self->err->report_name_shadowing(loc, name->c_str, shadowed_loc);
            return false;
        }

        // check if conflicts with global symbol
        if (self->ctx->get_domain(loc->file.__ptr__())->global_symbol.has(name)) {
            self->err->out("variable \"")
                     ->out(name->c_str)
                     ->out("\" conflicts with global symbol")
                     ->emit_err(loc);
            return false;
        }

        return true;
    }

    func resolve_definition(self, n: ast_definition*) {
        var name = n->name.__ptr__();

        // check if conflicts with local variable
        if (!self->check_local_variable_conflict(name, n->base.location.__ptr__())) {
            return;
        }

        // check if not initialized
        if (n->value == nil) {
            self->err->error(n->base.location.__ptr__(), "variable must be initialized");
            return;
        }

        if (n->type == nil) {
            var real_type = self->resolve_expression(n->value);
            defer real_type.delete();

            n->base.resolved_type.reset_with(real_type.__ptr__());
            if (real_type.is_empty_array()) {
                self->err->error(
                    n->value->location.__ptr__(),
                    "expect at least one element to infer type"
                );
            }
            self->ctx->add_local_var(name, real_type.__ptr__(), n->base.location.__ptr__());
            self->check_defined_variable_is_void(n, real_type.__ptr__());
            return;
        }

        // with type declaration
        var expect_type = self->tr.resolve(n->type);
        defer expect_type.delete();

        var real_type = self->resolve_expression(n->value);
        defer real_type.delete();

        if (expect_type.is_error() || real_type.is_error()) {
            return;
        }
        if (expect_type.is_array || real_type.is_array) {
            if (!expect_type.eq(real_type.__ptr__()) && !real_type.is_empty_array()) {
                var info = str::from("expect \"");
                var expect_type_name = expect_type.array_type_full_name(self->pkg);
                var real_type_name = real_type.array_type_full_name(self->pkg);
                defer {
                    info.delete();
                    expect_type_name.delete();
                    real_type_name.delete();
                }

                info.append(expect_type_name.c_str);
                info.append("\", but get \"");
                info.append(real_type_name.c_str);
                self->err->error(n->base.location.__ptr__(), info.c_str);
            } else if (expect_type.is_array &&
                       expect_type.array_length < real_type.array_length) {
                var info = str::from("expect at most ");
                defer info.delete();

                info.append_u64(expect_type.array_length);
                info.append(" element(s), but get ");
                info.append_u64(real_type.array_length);
                self->err->error(n->base.location.__ptr__(), info.c_str);
            }
            // sync the array length
            if (expect_type.is_array) {
                n->value->resolved_type.reset_with(expect_type.__ptr__());
            }
        } else if (expect_type.is_pointer() && real_type.is_pointer()) {
            // if is not the same type pointer and cannot be automatically converted
            // report here
            if (!expect_type.eq(real_type.__ptr__()) &&
                !self->check_can_be_converted(n->value, expect_type.__ptr__())) {
                var info = str::from("expect \"");
                var expect_type_name = expect_type.full_path_name_with_pointer(self->pkg);
                var real_type_name = real_type.full_path_name_with_pointer(self->pkg);
                defer {
                    info.delete();
                    expect_type_name.delete();
                    real_type_name.delete();
                }

                info.append(expect_type_name.c_str);
                info.append("\", but get \"");
                info.append(real_type_name.c_str);
                self->err->warn(n->base.location.__ptr__(), info.c_str);
            }
        } else if (!expect_type.eq(real_type.__ptr__()) &&
            !self->check_can_be_converted(n->value, expect_type.__ptr__())) {
            var info = str::from("def: expect \"");
            var expect_type_name = expect_type.full_path_name_with_pointer(self->pkg);
            var real_type_name = real_type.full_path_name_with_pointer(self->pkg);
            defer {
                info.delete();
                expect_type_name.delete();
                real_type_name.delete();
            }

            info.append(expect_type_name.c_str);
            info.append("\", but get \"");
            info.append(real_type_name.c_str);
            self->err->warn(n->base.location.__ptr__(), info.c_str);
        }

        // if immutable, make sure the type is correct
        if (real_type.is_const) {
            n->base.resolved_type.reset_with(real_type.__ptr__());
            self->ctx->add_local_var(name, real_type.__ptr__(), n->base.location.__ptr__());
            self->check_defined_variable_is_void(n, real_type.__ptr__());
        } else {
            n->base.resolved_type.reset_with(expect_type.__ptr__());
            self->ctx->add_local_var(name, expect_type.__ptr__(), n->base.location.__ptr__());
            self->check_defined_variable_is_void(n, expect_type.__ptr__());
        }
    }

    func resolve_if_stmt(self, n: ast_if_stmt*, func_self: colgm_func*) {
        if (n->condition != nil) {
            var ty = self->resolve_expression(n->condition => ast*);
            defer ty.delete();

            if (!ty.is_bool() && !ty.is_error()) {
                self->err->error(n->condition->location.__ptr__(),
                                "condition must be bool");
            }
        }

        // resolve block
        if (n->body != nil) {
            self->in_loop_level += 1;
            self->resolve_code_block(n->body, func_self);
            self->in_loop_level -= 1;
        }
    }

    func resolve_cond_stmt(self, n: ast_cond_stmt*, func_self: colgm_func*) {
        foreach (var i; n->stmts) {
            self->resolve_if_stmt(i.get() => ast_if_stmt*, func_self);
        }
    }
}

impl sema {
    func check_is_match_default(self, n: ast_call*) -> bool {
        if (!n->chain.empty()) {
            return false;
        }

        var name = n->head->id->content.__ptr__();
        return name->eq_const("_");
    }

    func check_is_enum_literal(self, n: ast_call*) -> bool {
        if (n->chain.size != 1) {
            return false;
        }

        var name = n->head->id->content.__ptr__();
        if (!self->ctx->global_symbol()->has(name)) {
            return false;
        }

        if (self->ctx->global_symbol()->get(name)->kind != symbol_kind::enum_kind) {
            return false;
        }

        var call_node = n->chain.get(0);
        if (call_node->kind != ast_kind::ast_call_path) {
            return false;
        }
        return true;
    }

    func get_enum_literal_value(self, n: ast_call*, infer: type*) -> i64 {
        var name = n->head->id->content.__ptr__();
        if (!self->ctx->has_domain(infer->loc_file.__ptr__())) {
            return 0xffffffffffffffff;
        }

        var dm = self->ctx->get_domain(infer->loc_file.__ptr__());
        if (!dm->enums.has(name)) {
            return 0xffffffffffffffff;
        }

        var em = dm->enums.get(name);
        var call_node = n->chain.get(0) => ast_call_path*;
        var e_name = call_node->name.__ptr__();
        if (!em->members.has(e_name)) {
            return 0xffffffffffffffff;
        }
        return em->members.get(e_name);
    }

    func check_is_tagged_union_member(self,
                                      n: ast_call*,
                                      un: colgm_tagged_union*) -> bool {
        var name = n->head->id->content.__ptr__();
        // means this tag is not referenced from enum
        // so the call head's identifier is the tag
        if (un->ref_enum_type.is_empty()) {
            if (n->chain.size != 0) {
                return false;
            }
            return un->members.has(name);
        }

        if (!un->ref_enum_type.name.eq(name)) {
            return false;
        }
        if (n->chain.size != 1) {
            return false;
        }

        var call_node = n->chain.get(0);
        if (call_node->kind != ast_kind::ast_call_path) {
            return false;
        }

        var call_path_node = call_node => ast_call_path*;
        return un->members.has(call_path_node->name.__ptr__());
    }

    // must use when check_is_tagged_union_member is true
    func get_tagged_union_label(self,
                                n: ast_call*,
                                un: colgm_tagged_union*) -> str {
        var name = n->head->id->content.__ptr__();
        // means this tag is not referenced from enum
        // so the call head's identifier is the tag
        if (un->ref_enum_type.is_empty()) {
            return name->clone();
        }

        var call_path_node = n->chain.get(0) => ast_call_path*;
        return call_path_node->name.clone();
    }

    func resolve_match_stmt(self, n: ast_match_stmt*, func_self: colgm_func*) {
        var infer = self->resolve_expression(n->value);
        defer infer.delete();

        // check error type
        if (infer.is_error()) {
            return;
        }

        if (!self->is_enum_type(infer.__ptr__()) &&
            !self->is_tagged_union_type(infer.__ptr__())) {
            self->err->error(n->value->location.__ptr__(),
                            "match value must be enum or tagged union");
            return;
        }

        if (self->is_enum_type(infer.__ptr__()) && infer.is_pointer()) {
            self->err->out("match value should not be pointer")
                     ->emit_err(n->value->location.__ptr__());
            return;
        }

        if (n->cases.empty()) {
            self->err->error(n->value->location.__ptr__(),
                             "must have at least one case");
            return;
        }

        if (self->is_enum_type(infer.__ptr__())) {
            self->resolve_match_stmt_for_enum(n, func_self, infer.__ptr__());
        } else if (self->is_tagged_union_type(infer.__ptr__())) {
            self->resolve_match_stmt_for_tagged_union(n, func_self, infer.__ptr__());
        }
    }

    func resolve_match_stmt_for_enum(self,
                                     n: ast_match_stmt*,
                                     func_self: colgm_func*,
                                     infer: type*) {
        var default_found = false;
        var used_values = hashset<basic<i64>>::instance();
        defer used_values.delete();

        foreach (var i; n->cases) {
            var case_node = i.get() => ast_match_case*;

            if (self->check_is_match_default(case_node->pattern)) {
                var case_type = type::default_match_type();
                defer case_type.delete();

                case_node->pattern->base.resolved_type.reset_with(case_type.__ptr__());
                case_node->base.resolved_type.reset_with(case_type.__ptr__());
                default_found = true;
                continue;
            }

            var case_type = self->resolve_call(case_node->pattern);
            defer case_type.delete();

            case_node->base.resolved_type.reset_with(case_type.__ptr__());
            case_node->pattern->base.resolved_type.reset_with(case_type.__ptr__());

            if (!case_type.eq(infer)) {
                if (!case_type.is_error()) {
                    var info = str::from("case value should be \"");
                    var c_name = case_type.full_path_name_with_pointer(self->pkg);
                    var i_name = infer->full_path_name_with_pointer(self->pkg);
                    defer {
                        info.delete();
                        c_name.delete();
                        i_name.delete();
                    }

                    info.append(c_name.c_str);
                    info.append("\", but get \"");
                    info.append(i_name.c_str);
                    info.append("\"");
                    self->err->error(case_node->pattern->base.location.__ptr__(), info.c_str);
                }
                continue;
            }

            if (!self->check_is_enum_literal(case_node->pattern)) {
                self->err->error(
                    case_node->pattern->base.location.__ptr__(),
                    "match value must be enum literal"
                );
                continue;
            }
            var value = self->get_enum_literal_value(case_node->pattern, infer);
            if (value == 0xffffffffffffffff) {
                // unreachable
                continue;
            }
            if (used_values.has(basic<i64>::wrap(value))) {
                    self->err->error(
                    case_node->pattern->base.location.__ptr__(),
                    "enum literal value is already used"
                );
            }
            used_values.insert(basic<i64>::wrap(value));
        }

        // resolve block after labels
        foreach (var i; n->cases) {
            var case_node = i.get() => ast_match_case*;
            self->resolve_code_block(case_node->body, func_self);
        }

        if (default_found) {
            return;
        }

        if (!self->ctx->has_domain(infer->loc_file.__ptr__())) {
            return;
        }
        var dm = self->ctx->get_domain(infer->loc_file.__ptr__());
        if (!dm->enums.has(infer->name.__ptr__())) {
            return;
        }
        var em = dm->enums.get(infer->name.__ptr__());
        var generated_warning = str::instance();
        defer generated_warning.delete();
        var unused_counter = 0;

        foreach (var i; em->members) {
            if (used_values.has(basic<i64>::wrap(i.value()))) {
                continue;
            }
            if (generated_warning.size > 0) {
                generated_warning.append(", ");
            }
            unused_counter += 1;
            if (unused_counter >= 5) {
                generated_warning.append("...");
                break;
            }
            generated_warning.append_str(i.key());
        }

        if (generated_warning.size > 0) {
            var info = str::from("match statement with enum \"");
            var i_name = infer->full_path_name_with_pointer(self->pkg);
            defer {
                info.delete();
                i_name.delete();
            }

            info.append_str(i_name.__ptr__());
            info.append("\" has unused member");
            if (unused_counter > 1) {
                info.append("s");
            }
            info.append(": ")->append_str(generated_warning.__ptr__());
            self->err->warn(n->base.location.__ptr__(), info.c_str);
        }
    }

    func resolve_match_stmt_for_tagged_union(self,
                                             n: ast_match_stmt*,
                                             func_self: colgm_func*,
                                             infer: type*) {
        var default_found = false;
        var used_values = hashset<str>::instance();
        defer used_values.delete();

        if (infer->pointer_depth > 1) {
            self->err->out("cannot match \"")
                     ->out_type(infer, self->pkg)
                     ->out("\"")
                     ->emit_err(n->value->location.__ptr__());
        }

        var dm = self->ctx->get_domain(infer->loc_file.__ptr__());
        var un = dm->tagged_unions.get(infer->name.__ptr__());

        foreach (var i; n->cases) {
            var case_node = i.get() => ast_match_case*;
            case_node->base.resolved_type.reset_with(infer);
            case_node->pattern->base.resolved_type.reset_with(infer);

            if (self->check_is_match_default(case_node->pattern)) {
                var case_type = type::default_match_type();
                defer case_type.delete();

                case_node->pattern->base.resolved_type.reset_with(case_type.__ptr__());
                case_node->base.resolved_type.reset_with(case_type.__ptr__());
                default_found = true;
                continue;
            }

            if (!self->check_is_tagged_union_member(case_node->pattern, un)) {
                self->err->error(
                    case_node->base.location.__ptr__(),
                    "cannot find this tag in this union"
                );
                continue;
            }

            var label = self->get_tagged_union_label(case_node->pattern, un);
            defer label.delete();

            if (used_values.has(label.__ptr__())) {
                self->err->error(
                    case_node->base.location.__ptr__(),
                    "duplicate tag"
                );
            }
            used_values.insert(label.__ptr__());
        }

        // resolve block after labels
        foreach (var i; n->cases) {
            var case_node = i.get() => ast_match_case*;
            self->resolve_code_block(case_node->body, func_self);
        }

        if (default_found) {
            return;
        }

        var generated_warning = str::instance();
        defer generated_warning.delete();
        var unused_counter = 0;

        foreach (var i; un->members) {
            if (used_values.has(i.key())) {
                continue;
            }
            if (generated_warning.size > 0) {
                generated_warning.append(", ");
            }
            unused_counter += 1;
            if (unused_counter >= 5) {
                generated_warning.append("...");
                break;
            }
            generated_warning.append_str(i.key());
        }

        if (generated_warning.size > 0) {
            var info = str::from("match statement with union \"");
            var i_name = infer->full_path_name_with_pointer(self->pkg);
            defer {
                info.delete();
                i_name.delete();
            }

            info.append_str(i_name.__ptr__());
            info.append("\" has unused tag");
            if (unused_counter > 1) {
                info.append("s");
            }
            info.append(": ")->append_str(generated_warning.__ptr__());
            self->err->warn_with_note(
                n->base.location.__ptr__(),
                info.c_str,
                "complete unused branch or use \"_\" default branch instead"
            );
        }
    }
}

impl sema {
    func resolve_while_stmt(self, n: ast_while_stmt*, func_self: colgm_func*) {
        var infer = self->resolve_expression(n->condition => ast*);
        defer infer.delete();

        if (!infer.is_bool() && !infer.is_error()) {
            self->err->error(
                n->condition->location.__ptr__(),
                "condition must be bool"
            );
        }

        // resolve block
        if (n->body != nil) {
            self->in_loop_level += 1;
            self->resolve_code_block(n->body, func_self);
            self->in_loop_level -= 1;
        }
    }

    func resolve_for_stmt(self, n: ast_for_stmt*, func_self: colgm_func*) {
        self->ctx->push_scope_level();
        if (n->init != nil) {
            self->resolve_definition(n->init);
        }
        if (n->condition != nil) {
            var ty = self->resolve_expression(n->condition => ast*);
            defer ty.delete();

            if (!ty.is_bool() && !ty.is_error()) {
                self->err->error(n->condition->location.__ptr__(),
                                "condition must be bool");
            }
        }
        if (n->update != nil) {
            self->resolve_expression(n->update => ast*).delete();
        }
        if (n->body != nil) {
            self->in_loop_level += 1;
            self->resolve_code_block(n->body, func_self);
            self->in_loop_level -= 1;
        }
        self->ctx->pop_scope_level(self->err);
    }

    func check_struct_has_method(self, t: type*, m_name: i8*) -> bool {
        if (t->is_error()) {
            return false;
        }

        var dm = self->ctx->get_domain(t->loc_file.__ptr__());
        var name_for_search = t->generic_name(self->pkg);
        defer name_for_search.delete();

        if (!dm->structs.has(name_for_search.__ptr__())) {
            return false;
        }

        var s = dm->structs.get(name_for_search.__ptr__());
        var method_name = str::from(m_name);
        defer method_name.delete();

        if (!s->method.has(method_name.__ptr__())) {
            return false;
        }
        return true;
    }

    func get_struct_method_return_type(self, t: type*, m_name: i8*) -> type {
        var dm = self->ctx->get_domain(t->loc_file.__ptr__());

        var name_for_search = t->generic_name(self->pkg);
        defer name_for_search.delete();

        var s = dm->structs.get(name_for_search.__ptr__());

        var method_name = str::from(m_name);
        defer method_name.delete();

        var m = s->method.get(method_name.__ptr__());
        return m->return_type.clone();
    }

    func lowering_forindex(self, n: ast_forindex*, iter_ty: type*) {
        // generate `var i: ty = 0;`
        var lowered_init = ast_definition::new(
            n->variable->base.location.__ptr__(),
            n->variable->content.__ptr__()
        );

        lowered_init->type = ast_type_def::new(n->variable->base.location.__ptr__());
        lowered_init->type->name = ast_identifier::new(
            n->variable->base.location.__ptr__(),
            iter_ty->name.__ptr__()
        );

        lowered_init->value = ast_number_literal::new(
            n->variable->base.location.__ptr__(),
            "0"
        ) => ast*;

        n->lowered_init = lowered_init;

        // generate `i < container.iter_size()`
        //
        // generate `i`
        var lowered_condition_lhs = ast_call::new(n->container->base.location.__ptr__());
        lowered_condition_lhs->head = ast_call_id::new(
            n->container->base.location.__ptr__(),
        );
        lowered_condition_lhs->head->id = n->variable->copy();
        // generate `container.iter_size()`
        var lowered_condition_rhs = n->container->copy();
        if (n->container->base.resolved_type.is_pointer()) {
            lowered_condition_rhs->chain.push(ast_ptr_get_field::new(
                n->container->base.location.__ptr__(),
                n->container->base.location.__ptr__(),
                "iter_size"
            ) => ast*);
        } else {
            lowered_condition_rhs->chain.push(ast_get_field::new(
                n->container->base.location.__ptr__(),
                n->container->base.location.__ptr__(),
                "iter_size"
            ) => ast*);
        }
        lowered_condition_rhs->chain.push(
            ast_call_func_args::new(n->container->base.location.__ptr__()) => ast*
        );

        // generate `i < container.iter_size()`
        var lowered_condition = ast_binary_operator::new(
            n->container->base.location.__ptr__(),
            binary_kind::less
        );
        lowered_condition->left = lowered_condition_lhs => ast*;
        lowered_condition->right = lowered_condition_rhs => ast*;
        n->lowered_condition = lowered_condition => ast*;

        // generate `i += 1`
        //
        // generate `i`
        var lowered_update_lhs = lowered_condition_lhs->copy();
        // generate `1`
        var lowered_update_rhs = ast_number_literal::new(
            n->container->base.location.__ptr__(),
            "1"
        ) => ast*;

        var lowered_update = ast_assignment::new(n->container->base.location.__ptr__());
        lowered_update->kind = assignment_kind::addeq;
        lowered_update->left = lowered_update_lhs;
        lowered_update->right = lowered_update_rhs => ast*;
        n->lowered_update = lowered_update => ast*;
    }

    func resolve_forindex_stmt(self, n: ast_forindex*, func_self: colgm_func*) {
        var ty = self->resolve_expression(n->container => ast*);
        defer ty.delete();

        // only accept container T, T& or T*
        if (ty.pointer_depth > 1) {
            self->err->out("\"")
                     ->out_type(ty.__ptr__(), self->pkg)
                     ->out("\" is not accpted as container")
                     ->emit_err(n->container->base.location.__ptr__());
        }

        // T should have method size(T) -> integer
        if (!self->check_struct_has_method(ty.__ptr__(), "iter_size")) {
            self->err->error(n->container->base.location.__ptr__(),
                             "container must have iter_size method");
            return;
        }

        // forindex will directly combine size method's return type to iter_type
        var iter_ty = self->get_struct_method_return_type(ty.__ptr__(), "iter_size");
        defer iter_ty.delete();

        var u64_type = type::u64_type();
        defer u64_type.delete();

        if (!iter_ty.eq(u64_type.__ptr__())) {
            self->err->error(n->container->base.location.__ptr__(),
                             "iter_size method must return u64");
            return;
        }

        n->variable->base.resolved_type.reset_with(iter_ty.__ptr__());
        if (!iter_ty.is_integer()) {
            self->err->error(n->container->base.location.__ptr__(),
                             "iter_size method must return integer");
            return;
        }

        self->lowering_forindex(n, iter_ty.__ptr__());

        self->ctx->push_scope_level();
        self->resolve_definition(n->lowered_init);
        self->resolve_expression(n->lowered_condition).delete();
        self->resolve_expression(n->lowered_update).delete();
        if (n->body != nil) {
            self->in_loop_level += 1;
            self->resolve_code_block(n->body, func_self);
            self->in_loop_level -= 1;
        }
        self->ctx->pop_scope_level(self->err);
    }

    func lowering_foreach(self, n: ast_foreach*) {
        // generate `var i = container.iter();`
        var lowered_init = ast_definition::new(
            n->variable->base.location.__ptr__(),
            n->variable->content.__ptr__()
        );
        var lowered_init_rhs = n->container->copy();
        lowered_init->value = lowered_init_rhs => ast*;
        if (n->container->base.resolved_type.is_pointer()) {
            lowered_init_rhs->chain.push(ast_ptr_get_field::new(
                n->container->base.location.__ptr__(),
                n->container->base.location.__ptr__(),
                "iter"
            ) => ast*);
        } else {
            lowered_init_rhs->chain.push(ast_get_field::new(
                n->container->base.location.__ptr__(),
                n->container->base.location.__ptr__(),
                "iter"
            ) => ast*);
        }
        lowered_init_rhs->chain.push(
            ast_call_func_args::new(n->container->base.location.__ptr__()) => ast*
        );

        n->lowered_init = lowered_init;

        // generate `!i.is_end()`
        //
        // generate `i.is_end()`
        var lowered_condition_value = ast_call::new(
            n->container->base.location.__ptr__()
        );
        lowered_condition_value->head = ast_call_id::new(
            n->container->base.location.__ptr__(),
        );
        lowered_condition_value->head->id = n->variable->copy();
        // generate `is_end`
        lowered_condition_value->chain.push(ast_get_field::new(
            n->container->base.location.__ptr__(),
            n->container->base.location.__ptr__(),
            "is_end"
        ) => ast*);
        // generate `()`
        lowered_condition_value->chain.push(
            ast_call_func_args::new(n->container->base.location.__ptr__()) => ast*
        );
        // !i.is_end()
        var lowered_condition = ast_unary_operator::new(
            n->container->base.location.__ptr__(),
            unary_kind::lnot
        );
        lowered_condition->value = lowered_condition_value => ast*;
        n->lowered_condition = lowered_condition => ast*;

        // generate `i = i.next()`
        //
        // generate `i`
        var lowered_update_lhs = ast_call::new(
            n->container->base.location.__ptr__()
        );
        lowered_update_lhs->head = ast_call_id::new(
            n->container->base.location.__ptr__(),
        );
        lowered_update_lhs->head->id = n->variable->copy();
        // generate `i.next()`
        var lowered_update_rhs = ast_call::new(
            n->container->base.location.__ptr__()
        );
        lowered_update_rhs->head = ast_call_id::new(
            n->container->base.location.__ptr__(),
        );
        lowered_update_rhs->head->id = n->variable->copy();
        lowered_update_rhs->chain.push(ast_get_field::new(
            n->container->base.location.__ptr__(),
            n->container->base.location.__ptr__(),
            "next"
        ) => ast*);
        lowered_update_rhs->chain.push(
            ast_call_func_args::new(n->container->base.location.__ptr__()) => ast*
        );

        var lowered_update = ast_assignment::new(n->container->base.location.__ptr__());
        lowered_update->kind = assignment_kind::eq;
        lowered_update->left = lowered_update_lhs;
        lowered_update->right = lowered_update_rhs => ast*;
        n->lowered_update = lowered_update => ast*;
    }

    func resolve_foreach_stmt(self, n: ast_foreach*, func_self: colgm_func*) {
        var ty = self->resolve_expression(n->container => ast*);
        defer ty.delete();

        // only accept container T, T& or T*
        if (ty.pointer_depth > 1) {
            self->err->out("\"")
                     ->out_type(ty.__ptr__(), self->pkg)
                     ->out("\" is not accpted as container")
                     ->emit_err(n->container->base.location.__ptr__());
        }
        // T should have method iter(T) -> iter_type
        if (!self->check_struct_has_method(ty.__ptr__(), "iter")) {
            self->err->error(n->container->base.location.__ptr__(),
                             "container must have iter method");
            return;
        }

        // foreach will directly combine iter_type to defined variable
        var iter_ty = self->get_struct_method_return_type(ty.__ptr__(), "iter");
        defer iter_ty.delete();

        n->variable->base.resolved_type.reset_with(iter_ty.__ptr__());

        // check iter.is_end() method
        if (!self->check_struct_has_method(iter_ty.__ptr__(), "is_end")) {
            self->err->error(n->variable->base.location.__ptr__(),
                             "iterator must have is_end method");
            return;
        } else {
            var rt = self->get_struct_method_return_type(iter_ty.__ptr__(), "is_end");
            defer rt.delete();

            if (!rt.is_bool()) {
                self->err->error(n->variable->base.location.__ptr__(),
                                 "is_end method must return bool type");
                return;
            }
        }

        // check iter.next() method
        if (!self->check_struct_has_method(iter_ty.__ptr__(), "next")) {
            self->err->error(n->variable->base.location.__ptr__(),
                             "iterator must have next method");
            return;
        } else {
            var rt = self->get_struct_method_return_type(iter_ty.__ptr__(), "next");
            defer rt.delete();

            if (!rt.eq(iter_ty.__ptr__())) {
                self->err->error(n->variable->base.location.__ptr__(),
                                 "next method's return type should equal to the iterator");
                return;
            }
        }

        self->lowering_foreach(n);

        self->ctx->push_scope_level();
        self->resolve_definition(n->lowered_init);
        self->resolve_expression(n->lowered_condition).delete();
        self->resolve_expression(n->lowered_update).delete();
        if (n->body != nil) {
            self->in_loop_level += 1;
            self->resolve_code_block(n->body, func_self);
            self->in_loop_level -= 1;
        }
        self->ctx->pop_scope_level(self->err);
    }

    func resolve_in_stmt_expr(self, n: ast_in_stmt_expr*) {
        var ty = self->resolve_expression(n->value => ast*);
        defer ty.delete();

        n->base.resolved_type.reset_with(ty.__ptr__());
    }

    func resolve_ret_stmt(self, n: ast_ret_stmt*, func_self: colgm_func*) {
        if (n->value == nil && !func_self->return_type.is_void()) {
            self->err->error(n->base.location.__ptr__(), "expect non-void return value");
            return;
        }

        if (n->value == nil) {
            return;
        }

        var infer = self->resolve_expression(n->value);
        defer infer.delete();

        if (infer.is_error()) {
            return;
        }

        if (!func_self->return_type.eq(infer.__ptr__()) &&
            !self->check_can_be_converted(n->value, func_self->return_type.__ptr__())) {
            self->err->out("expected return type \"")
                        ->out_type(func_self->return_type.__ptr__(), self->pkg)
                        ->out("\", but get \"")
                        ->out_type(infer.__ptr__(), self->pkg)
                        ->out("\"")
                        ->emit_err(n->base.location.__ptr__());
        }

        if (func_self->return_type.is_reference) {
            n->return_ref_type = true;
        }
    }

    func resolve_statement(self, n: ast*, func_self: colgm_func*) {
        match (n->kind) {
            ast_kind::ast_definition =>
                self->resolve_definition(n => ast_definition*);
            ast_kind::ast_cond_stmt =>
                self->resolve_cond_stmt(n => ast_cond_stmt*, func_self);
            ast_kind::ast_match_stmt =>
                self->resolve_match_stmt(n => ast_match_stmt*, func_self);
            ast_kind::ast_while_stmt =>
                self->resolve_while_stmt(n => ast_while_stmt*, func_self);
            ast_kind::ast_for_stmt =>
                self->resolve_for_stmt(n => ast_for_stmt*, func_self);
            ast_kind::ast_forindex => {
                self->resolve_forindex_stmt(n => ast_forindex*, func_self);
            }
            ast_kind::ast_foreach => {
                self->resolve_foreach_stmt(n => ast_foreach*, func_self);
            }
            ast_kind::ast_in_stmt_expr =>
                self->resolve_in_stmt_expr(n => ast_in_stmt_expr*);
            ast_kind::ast_defer_stmt =>
                self->err->error(n->location.__ptr__(),
                    "defer statement should not exist here, please report a bug"
                );
            ast_kind::ast_ret_stmt =>
                self->resolve_ret_stmt(n => ast_ret_stmt*, func_self);
            ast_kind::ast_break_stmt => {
                if (self->in_loop_level == 0) {
                    self->err->error(n->location.__ptr__(),
                                     "break statement is not in loop");
                }
            }
            ast_kind::ast_continue_stmt => {
                if (self->in_loop_level == 0) {
                    self->err->error(n->location.__ptr__(),
                                     "continue statement is not in loop");
                }
            }
            // if statement only has one ';', the ast will be ast_null
            ast_kind::ast_null => {}
            _ => { unreachable(); }
        }
    }

    func resolve_code_block(self, node: ast_code_block*, func_self: colgm_func*) {
        self->ctx->push_scope_level();
        foreach (var i; node->stmts) {
            var n = i.get();
            self->resolve_statement(n, func_self);
            if (n->is(ast_kind::ast_ret_stmt) ||
                n->is(ast_kind::ast_break_stmt) ||
                n->is(ast_kind::ast_continue_stmt)) {
                self->report_unreachable_statements(node);
                break;
            }
        }
        self->ctx->pop_scope_level(self->err);
    }
}

impl sema {
    pub func analyse(self, root: root*) {
        self->ctx->this_file.clear();
        self->ctx->this_file.append_str(root->base.location.file.__ptr__());
        self->root = root;

        self->resolve_function_block(root);
    }

    func report_unreachable_statements(self, n: ast_code_block*) {
        var flag_block_ended = false;
        var unreachable_statements = vec<ast*>::instance();
        defer unreachable_statements.delete();

        foreach (var i; n->stmts) {
            var tmp = i.get();
            if (flag_block_ended) {
                unreachable_statements.push(tmp);
            }
            if (tmp->is(ast_kind::ast_ret_stmt) ||
                tmp->is(ast_kind::ast_break_stmt) ||
                tmp->is(ast_kind::ast_continue_stmt)) {
                flag_block_ended = true;
            }
        }

        if (unreachable_statements.empty()) {
            return;
        }

        var unreachable_location = unreachable_statements
                                   .get(0)->location.clone();
        defer unreachable_location.delete();

        foreach (var i; unreachable_statements) {
            var tmp = i.get();
            unreachable_location.end_column = tmp->location.end_column;
            unreachable_location.end_line = tmp->location.end_line;
        }

        if (unreachable_statements.size > 1) {
            self->err->out("unreachable statements, ignored")
                     ->emit_warn(unreachable_location.__ptr__());
        } else {
            self->err->out("unreachable statement, ignored")
                     ->emit_warn(unreachable_location.__ptr__());
        }
    }

    func report_top_level_block_has_no_return(self,
                                              n: ast_code_block*,
                                              func_self: colgm_func*) {
        var flag_has_return = false;
        foreach (var i; n->stmts) {
            var tmp = i.get();
            if (tmp->is(ast_kind::ast_ret_stmt)) {
                flag_has_return = true;
                break;
            }
        }

        if (flag_has_return) {
            return;
        }

        if (func_self->return_type.is_void()) {
            var rs = ast_ret_stmt::new(n->base.location.__ptr__());
            n->stmts.push(rs => ast*);
            return;
        }

        self->err->error(n->base.location.__ptr__(), "function has no return statement");
    }

    func resolve_function_block(self, r: root*) {
        foreach (var i; r->decls) {
            var n = i.get();
            if (n->is(ast_kind::ast_impl)) {
                self->resolve_impl(n => ast_impl*);
            } else if (n->is(ast_kind::ast_func_decl)) {
                self->resolve_global_func(n => ast_func_decl*);
            }
        }
    }

    func resolve_impl(self, node: ast_impl*) {
        // do not resolve generic impl
        if (node->generic_types != nil) {
            return;
        }

        var dm: colgm_module* = nil;
        if (node->base.is_redirected()) {
            dm = self->ctx->get_domain(node->base.redirect_location.__ptr__());
        } else {
            dm = self->ctx->get_domain(node->base.location.file.__ptr__());
        }

        if (dm->structs.has(node->name.__ptr__())) {
            var struct_self = dm->structs.get(node->name.__ptr__());
            self->impl_struct_name.clear();
            self->impl_struct_name.append_str(node->name.__ptr__());
            foreach (var i; node->methods) {
                self->resolve_struct_method(i.get() => ast_func_decl*, struct_self);
            }
            self->impl_struct_name.clear();
            return;
        } else if (dm->tagged_unions.has(node->name.__ptr__())) {
            var union_self = dm->tagged_unions.get(node->name.__ptr__());
            self->impl_struct_name.clear();
            self->impl_struct_name.append_str(node->name.__ptr__());
            foreach (var i; node->methods) {
                self->resolve_union_method(i.get() => ast_func_decl*, union_self);
            }
            self->impl_struct_name.clear();
            return;
        }

        self->err->out("cannot implement \"")
                 ->out(node->name.c_str)
                 ->out("\", because it is not defined in the same file")
                 ->emit_err(node->base.location.__ptr__());
    }

    func resolve_global_func(self, node: ast_func_decl*) {
        // do not resolve generic function
        if (node->generic_types != nil) {
            return;
        }

        var dm = self->ctx->get_domain(node->base.location.file.__ptr__());
        if (!dm->functions.has(node->name.__ptr__())) {
            self->err->out("cannot find function \"")
                     ->out(node->name.c_str)
                     ->out("\"")
                     ->emit_err(node->base.location.__ptr__());
            return;
        }

        var func_self = dm->functions.get(node->name.__ptr__());
        if (node->body == nil) {
            if (!func_self->is_extern) {
                self->err->out("non-extern function \"")
                         ->out(node->name.c_str)
                         ->out("\" is not implemented")
                         ->emit_err(node->base.location.__ptr__());
            }
            return;
        }

        self->ctx->push_scope_level();
        foreach (var p; func_self->unordered_params) {
            var param_name = p.key();
            var param_type = p.value();
            var param_loc = func_self->param_location.get(param_name);
            self->ctx->add_local_var(param_name, param_type, param_loc);
        }
        foreach (var i; node->body->stmts) {
            var n = i.get();
            self->resolve_statement(n, func_self);
            if (n->is(ast_kind::ast_ret_stmt) ||
                n->is(ast_kind::ast_break_stmt) ||
                n->is(ast_kind::ast_continue_stmt)) {
                self->report_unreachable_statements(node->body);
                break;
            }
        }
        self->report_top_level_block_has_no_return(node->body, func_self);
        self->ctx->pop_scope_level(self->err);
    }

    func resolve_struct_method(self, node: ast_func_decl*, struct_self: colgm_struct*) {
        if (node->body == nil) {
            self->err->error(node->base.location.__ptr__(),
                             "method should be implemented");
            return;
        }
        
        var method_self: colgm_func* = nil;
        if (struct_self->method.has(node->name.__ptr__())) {
            method_self = struct_self->method.get(node->name.__ptr__());
        } else {
            method_self = struct_self->static_method.get(node->name.__ptr__());
        }

        self->ctx->push_scope_level();
        foreach (var p; method_self->unordered_params) {
            var param_name = p.key();
            var param_type = p.value();
            var param_loc = method_self->param_location.get(param_name);
            self->ctx->add_local_var(param_name, param_type, param_loc);
        }
        foreach (var i; node->body->stmts) {
            var n = i.get();
            self->resolve_statement(n, method_self);
            if (n->is(ast_kind::ast_ret_stmt) ||
                n->is(ast_kind::ast_break_stmt) ||
                n->is(ast_kind::ast_continue_stmt)) {
                self->report_unreachable_statements(node->body);
                break;
            }
        }
        self->report_top_level_block_has_no_return(node->body, method_self);
        self->ctx->pop_scope_level(self->err);
    }

    func resolve_union_method(self, node: ast_func_decl*, union_self: colgm_tagged_union*) {
        if (node->body == nil) {
            self->err->error(node->base.location.__ptr__(),
                             "method should be implemented");
            return;
        }
        
        var method_self: colgm_func* = nil;
        if (union_self->method.has(node->name.__ptr__())) {
            method_self = union_self->method.get(node->name.__ptr__());
        } else {
            method_self = union_self->static_method.get(node->name.__ptr__());
        }

        self->ctx->push_scope_level();
        foreach (var p; method_self->unordered_params) {
            var param_name = p.key();
            var param_type = p.value();
            var param_loc = method_self->param_location.get(param_name);
            self->ctx->add_local_var(param_name, param_type, param_loc);
        }
        foreach (var i; node->body->stmts) {
            var n = i.get();
            self->resolve_statement(n, method_self);
            if (n->is(ast_kind::ast_ret_stmt) ||
                n->is(ast_kind::ast_break_stmt) ||
                n->is(ast_kind::ast_continue_stmt)) {
                self->report_unreachable_statements(node->body);
                break;
            }
        }
        self->report_top_level_block_has_no_return(node->body, method_self);
        self->ctx->pop_scope_level(self->err);
    }
}

impl sema {
    pub func view_resolved_ast(self, out: io) {
        var dumper = ast_dumper::instance(self->pkg);
        defer dumper.delete();

        dumper.dump(self->root => ast*, out);
    }
}