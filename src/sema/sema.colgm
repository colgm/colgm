use err::report::{ report };
use err::panic::{ panic, unreachable };

use std::io::{ io };
use std::libc::{ free, itoa };
use std::math::{ isinf, isnan };
use std::str::{ str };
use std::ptr::{ ptr };
use std::vec::{ vec, primitive_vec };
use std::set::{ hashset };
use std::ptr::{ basic };

use package::{ package };

use ast::ast::*;
use ast::dumper::{ ast_dumper };

use sema::structure::{ colgm_struct };
use sema::function::{ colgm_func };
use sema::context::{ sema_context };
use sema::type::{ type };
use sema::symbol_info::{ symbol_kind };
use sema::module::{ colgm_module };
use sema::type_resolve::{ type_resolve };

use util::cli::{ cli_option };
use util::to_num::{ str_to_num, hex_to_i64, oct_to_i64 };

pub struct sema {
    err: report*,
    root: root*,
    ctx: sema_context*,
    co: cli_option*,
    pkg: package*,
    tr: type_resolve,
    in_loop_level: i64,
    impl_struct_name: str
}

impl sema {
    pub func instance(err: report*,
                      pkg: package*,
                      ctx: sema_context*,
                      co: cli_option*) -> sema {
        return sema {
            err: err,
            root: nil,
            ctx: ctx,
            co: co,
            pkg: pkg,
            tr: type_resolve::instance(err, ctx, pkg),
            in_loop_level: 0,
            impl_struct_name: str::from("")
        };
    }

    pub func delete(self) {
        // nothing to do now
    }
}

impl sema {
    func is_enum_type(self, ty: type*) -> bool {
        if (ty->loc_file.empty()) {
            return false;
        }
        var dm = self->ctx->global->domain.get(ty->loc_file.__ptr__());
        if (dm->enums.has(ty->name.__ptr__())) {
            return true;
        }
        return false;
    }

    func is_struct_type(self, ty: type*) -> bool {
        if (ty->loc_file.empty()) {
            return false;
        }
        var dm = self->ctx->global->domain.get(ty->loc_file.__ptr__());
        if (dm->structs.has(ty->name.__ptr__())) {
            return true;
        }
        return false;
    }
}

impl sema {
    func resolve_nil_literal(self, n: ast_nil_literal*) -> type {
        var ty = type::i8_type(1);
        n->base.resolved_type.reset_with(ty.__ptr__());
        return ty;
    }

    func resolve_number_literal(self, n: ast_number_literal*) -> type {
        var result = str_to_num(n->literal.c_str);
        if (isinf(result) || isnan(result)) {
            var info = str::from("invalid number \"");
            info.append_str(n->literal.__ptr__());
            info.append_char('\"');
            self->err->error(n->base.location, info.c_str);
            info.delete();
            return type::error_type();
        }
        if (n->literal.contains('.') || n->literal.contains('e')) {
            var ty = type::f64_type();
            n->base.resolved_type.reset_with(ty.__ptr__());
            return ty;
        }
        if (n->literal.size > 2 && n->literal.c_str[1] == 'o') {
            var buff = [i8; 128];
            itoa(oct_to_i64(n->literal.c_str), buff, 8);
            n->literal.clear();
            n->literal.append_i8_vec(buff);
            var ty = type::u64_type();
            n->base.resolved_type.reset_with(ty.__ptr__());
            return ty;
        }
        if (n->literal.size > 2 && n->literal.c_str[0] == 'x') {
            var buff = [i8; 128];
            itoa(hex_to_i64(n->literal.c_str), buff, 8);
            n->literal.clear();
            n->literal.append_i8_vec(buff);
            var ty = type::u64_type();
            n->base.resolved_type.reset_with(ty.__ptr__());
            return ty;
        }
        var default_ty = type::i64_type();
        n->base.resolved_type.reset_with(default_ty.__ptr__());
        return default_ty;
    }

    func resolve_string_literal(self, n: ast_string_literal*) -> type {
        var ty = type::i8_type(1);
        self->ctx->constant_string.insert(n->literal.__ptr__());
        n->base.resolved_type.reset_with(ty.__ptr__());
        return ty;
    }

    func resolve_char_literal(self, n: ast_char_literal*) -> type {
        var ty = type::i8_type(0);
        n->base.resolved_type.reset_with(ty.__ptr__());
        return ty;
    }

    func resolve_bool_literal(self, n: ast_bool_literal*) -> type {
        var ty = type::bool_type();
        n->base.resolved_type.reset_with(ty.__ptr__());
        return ty;
    }

    func resolve_array_literal(self, n: ast_array_literal*) -> type {
        var size_infer = self->resolve_number_literal(n->size);
        if (!size_infer.is_integer()) {
            self->err->error(n->base.location, "array size must be integer");
            size_infer.delete();
            return type::error_type();
        }
        size_infer.delete();

        var type_infer = self->tr.resolve(n->type);
        type_infer.pointer_depth += 1;
        type_infer.is_immutable = true;
        n->base.resolved_type.reset_with(type_infer.__ptr__());
        return type_infer;
    }

    func resolve_unary_neg(self, n: ast_unary_operator*) -> type {
        var infer = self->resolve_expression(n->value);
        if (infer.is_error()) {
            return infer;
        }
        if (!infer.is_integer() && !infer.is_float()) {
            var info = str::from("expect integer or float but get \"");
            var i_name = infer.full_path_name(self->pkg, true);
            info.append_str(i_name.__ptr__());
            info.append_i8_vec("\"");
            self->err->error(n->base.location, info.c_str);
            info.delete();
            i_name.delete();
            infer.delete();
            return type::error_type();
        }
        return infer;
    }

    func resolve_unary_bnot(self, n: ast_unary_operator*) -> type {
        var infer = self->resolve_expression(n->value);
        if (infer.is_error()) {
            return infer;
        }
        if (!infer.is_integer() || infer.is_pointer()) {
            var info = str::from("bitwise operator cannot be used on \"");
            var i_name = infer.full_path_name(self->pkg, true);
            info.append_str(i_name.__ptr__());
            info.append_i8_vec("\"");
            self->err->error(n->base.location, info.c_str);
            info.delete();
            i_name.delete();
            infer.delete();
            return type::error_type();
        }
        return infer;
    }

    func resolve_unary_lnot(self, n: ast_unary_operator*) -> type {
        var infer = self->resolve_expression(n->value);
        // do not report if get error type,
        // because the related error is reported before
        if (infer.is_error()) {
            infer.delete();
            return type::bool_type();
        }
        if (!infer.is_bool() || infer.is_pointer()) {
            var info = str::from("logical operator cannot be used on \"");
            var i_name = infer.full_path_name(self->pkg, true);
            info.append_str(i_name.__ptr__());
            info.append_i8_vec("\"");
            self->err->error(n->base.location, info.c_str);
            info.delete();
            i_name.delete();
            infer.delete();
            return type::bool_type();
        }
        return type::bool_type();
    }

    func resolve_unary_operator(self, n: ast_unary_operator*) -> type {
        match (n->kind) {
            unary_kind::neg => {
                var ty = self->resolve_unary_neg(n);
                n->base.resolved_type.reset_with(ty.__ptr__());
                return ty;
            }
            unary_kind::bnot => {
                var ty = self->resolve_unary_bnot(n);
                n->base.resolved_type.reset_with(ty.__ptr__());
                return ty;
            }
            unary_kind::lnot => {
                var ty = self->resolve_unary_lnot(n);
                n->base.resolved_type.reset_with(ty.__ptr__());
                return ty;
            }
        }

        unreachable();
        return type::error_type();
    }

    func resolve_comparison_operator(self, n: ast_binary_operator*) -> type {
        var left = self->resolve_expression(n->left);
        var right = self->resolve_expression(n->right);
        if (left.is_error() || right.is_error()) {
            left.delete();
            right.delete();
            var infer = type::bool_type();
            n->base.resolved_type.reset_with(infer.__ptr__());
            return infer;
        }
        if (!left.eq(right.__ptr__())) {
            if (!self->check_can_be_converted(n->right, left.__ptr__()) &&
                !self->check_can_be_converted(n->left, right.__ptr__())) {
                var info = str::from("cannot compare \"");
                var l_name = left.full_path_name(self->pkg, true);
                var r_name = right.full_path_name(self->pkg, true);
                info.append_str(l_name.__ptr__());
                info.append_i8_vec("\" and \"");
                info.append_str(r_name.__ptr__());
                info.append_i8_vec("\"");
                self->err->error(n->base.location, info.c_str);
                info.delete();
                l_name.delete();
                r_name.delete();
                left.delete();
                right.delete();
                var infer = type::bool_type();
                n->base.resolved_type.reset_with(infer.__ptr__());
                return infer;
            }
        }

        // check enum comparison
        if (self->is_enum_type(left.__ptr__())) {
            if (n->kind != binary_kind::cmpeq &&
                n->kind != binary_kind::cmpne) {
                self->err->error(n->base.location, "only \"==\" and \"!=\" are allowed");
            }
            left.delete();
            right.delete();
            var infer = type::bool_type();
            n->base.resolved_type.reset_with(infer.__ptr__());
            return infer;
        } else if (!left.is_integer() && !left.is_float() &&
                   !left.is_pointer() && !left.is_bool()) {
            var info = str::from("cannot compare uncomparable type \"");
            var l_name = left.full_path_name(self->pkg, true);
            var r_name = right.full_path_name(self->pkg, true);
            info.append_str(l_name.__ptr__());
            info.append_i8_vec("\" and \"");
            info.append_str(r_name.__ptr__());
            info.append_i8_vec("\"");
            self->err->error(n->base.location, info.c_str);
            info.delete();
            l_name.delete();
            r_name.delete();
            left.delete();
            right.delete();
            var infer = type::bool_type();
            n->base.resolved_type.reset_with(infer.__ptr__());
            return infer;
        }

        if (left.is_pointer() && left.pointer_depth != right.pointer_depth) {
            var info = str::from("cannot compare pointer \"");
            var l_name = left.full_path_name(self->pkg, true);
            var r_name = right.full_path_name(self->pkg, true);
            info.append_str(l_name.__ptr__());
            info.append_i8_vec("\" with different pointer level type \"");
            info.append_str(r_name.__ptr__());
            info.append_i8_vec("\"");
            self->err->error(n->base.location, info.c_str);
            info.delete();
            l_name.delete();
            r_name.delete();
            left.delete();
            right.delete();
            var infer = type::bool_type();
            n->base.resolved_type.reset_with(infer.__ptr__());
            return infer;
        }

        left.delete();
        right.delete();
        var infer = type::bool_type();
        n->base.resolved_type.reset_with(infer.__ptr__());
        return infer;
    }

    func resolve_logical_operator(self, n: ast_binary_operator*) -> type {
        var left = self->resolve_expression(n->left);
        var right = self->resolve_expression(n->right);
        if (left.is_error() || !right.is_error()) {
            left.delete();
            right.delete();
            var infer = type::bool_type();
            n->base.resolved_type.reset_with(infer.__ptr__());
            return infer;
        }

        if (left.is_bool() && right.is_bool()) {
            left.delete();
            right.delete();
            var infer = type::bool_type();
            n->base.resolved_type.reset_with(infer.__ptr__());
            return infer;
        }

        if (!left.is_bool()) {
            var info = str::from("expect \"bool\" but get \"");
            var name = left.full_path_name(self->pkg, true);
            info.append_str(name.__ptr__());
            info.append_i8_vec("\"");
            self->err->error(n->left->location, info.c_str);
            info.delete();
            name.delete();
        }
        if (!right.is_bool()) {
            var info = str::from("expect \"bool\" but get \"");
            var name = right.full_path_name(self->pkg, true);
            info.append_str(name.__ptr__());
            info.append_i8_vec("\"");
            self->err->error(n->right->location, info.c_str);
            info.delete();
            name.delete();
        }

        left.delete();
        right.delete();
        var infer = type::bool_type();
        n->base.resolved_type.reset_with(infer.__ptr__());
        return infer;
    }

    func resolve_arithmetic_operator(self, n: ast_binary_operator*) -> type {
        var left = self->resolve_expression(n->left);
        var right = self->resolve_expression(n->right);

        if (left.is_error() || right.is_error()) {
            left.delete();
            right.delete();
            return type::error_type();
        }

        // left hand side value should be the same as right hand side value
        if (!left.eq(right.__ptr__())) {
            if (!self->check_can_be_converted(n->right, left.__ptr__()) &&
                !self->check_can_be_converted(n->left, right.__ptr__())) {
                var info = str::from("cannot calculate \"");
                var l_name = left.full_path_name(self->pkg, true);
                var r_name = right.full_path_name(self->pkg, true);
                info.append_str(l_name.__ptr__())->append_i8_vec("\" and \"");
                info.append_str(r_name.__ptr__());
                self->err->error(n->base.location, info.c_str);
                info.delete();
                l_name.delete();
                r_name.delete();
                left.delete();
                right.delete();
                return type::error_type();
            }
        }

        // cannot calculate enum
        if (self->is_enum_type(left.__ptr__())) {
            var info = str::from("cannot calculate enum \"");
            var name = left.full_path_name(self->pkg, true);
            info.append_str(name.__ptr__())->append_i8_vec("\"");
            self->err->error(n->left->location, info.c_str);
            info.delete();
            name.delete();
            left.delete();
            right.delete();
            return type::error_type();
        } else if (self->is_enum_type(right.__ptr__())) {
            var info = str::from("cannot calculate enum \"");
            var name = right.full_path_name(self->pkg, true);
            info.append_str(name.__ptr__())->append_i8_vec("\"");
            self->err->error(n->right->location, info.c_str);
            info.delete();
            name.delete();
            left.delete();
            right.delete();
            return type::error_type();
        }

        right.delete();
        n->base.resolved_type.reset_with(left.__ptr__());
        return left;
    }

    func resolve_bitwise_operator(self, n: ast_binary_operator*) -> type {
        var left = self->resolve_expression(n->left);
        var right = self->resolve_expression(n->right);

        if (left.is_error() || right.is_error()) {
            left.delete();
            right.delete();
            return type::error_type();
        }

        if (!left.is_integer()) {
            var info = str::from("bitwise operator cannot be used on \"");
            var name = left.full_path_name(self->pkg, true);
            info.append_str(name.__ptr__())->append_i8_vec("\"");
            self->err->error(n->left->location, info.c_str);
            info.delete();
            name.delete();
            left.delete();
            right.delete();
            return type::error_type();
        }

        if (!right.is_integer()) {
            var info = str::from("bitwise operator cannot be used on \"");
            var name = right.full_path_name(self->pkg, true);
            info.append_str(name.__ptr__())->append_i8_vec("\"");
            self->err->error(n->right->location, info.c_str);
            info.delete();
            name.delete();
            left.delete();
            right.delete();
            return type::error_type();
        }

        // left hand side value should be the same as right hand side value
        if (!left.eq(right.__ptr__())) {
            if (!self->check_can_be_converted(n->right, left.__ptr__()) &&
                !self->check_can_be_converted(n->left, right.__ptr__())) {
                var info = str::from("cannot calculate \"");
                var l_name = left.full_path_name(self->pkg, true);
                var r_name = right.full_path_name(self->pkg, true);
                info.append_str(l_name.__ptr__())->append_i8_vec("\" and \"");
                info.append_str(r_name.__ptr__());
                self->err->error(n->base.location, info.c_str);
                info.delete();
                l_name.delete();
                r_name.delete();
                left.delete();
                right.delete();
                return type::error_type();
            }
        }

        right.delete();
        n->base.resolved_type.reset_with(left.__ptr__());
        return left;
    }

    func resolve_binary_operator(self, n: ast_binary_operator*) -> type {
        match (n->kind) {
            binary_kind::add => {
                var ty = self->resolve_arithmetic_operator(n);
                n->base.resolved_type.reset_with(ty.__ptr__());
                return ty;
            }
            binary_kind::sub => {
                var ty = self->resolve_arithmetic_operator(n);
                n->base.resolved_type.reset_with(ty.__ptr__());
                return ty;
            }
            binary_kind::mul => {
                var ty = self->resolve_arithmetic_operator(n);
                n->base.resolved_type.reset_with(ty.__ptr__());
                return ty;
            }
            binary_kind::div => {
                var ty = self->resolve_arithmetic_operator(n);
                n->base.resolved_type.reset_with(ty.__ptr__());
                return ty;
            }
            binary_kind::rem => {
                var ty = self->resolve_arithmetic_operator(n);
                n->base.resolved_type.reset_with(ty.__ptr__());
                return ty;
            }
            binary_kind::cmpeq => {
                var ty = self->resolve_comparison_operator(n);
                n->base.resolved_type.reset_with(ty.__ptr__());
                return ty;
            }
            binary_kind::cmpne => {
                var ty = self->resolve_comparison_operator(n);
                n->base.resolved_type.reset_with(ty.__ptr__());
                return ty;
            }
            binary_kind::less => {
                var ty = self->resolve_comparison_operator(n);
                n->base.resolved_type.reset_with(ty.__ptr__());
                return ty;
            }
            binary_kind::leq => {
                var ty = self->resolve_comparison_operator(n);
                n->base.resolved_type.reset_with(ty.__ptr__());
                return ty;
            }
            binary_kind::grt => {
                var ty = self->resolve_comparison_operator(n);
                n->base.resolved_type.reset_with(ty.__ptr__());
                return ty;
            }
            binary_kind::geq => {
                var ty = self->resolve_comparison_operator(n);
                n->base.resolved_type.reset_with(ty.__ptr__());
                return ty;
            }
            binary_kind::cmpand => {
                var ty = self->resolve_logical_operator(n);
                n->base.resolved_type.reset_with(ty.__ptr__());
                return ty;
            }
            binary_kind::cmpor => {
                var ty = self->resolve_logical_operator(n);
                n->base.resolved_type.reset_with(ty.__ptr__());
                return ty;
            }
            binary_kind::band => {
                var ty = self->resolve_bitwise_operator(n);
                n->base.resolved_type.reset_with(ty.__ptr__());
                return ty;
            }
            binary_kind::bor => {
                var ty = self->resolve_bitwise_operator(n);
                n->base.resolved_type.reset_with(ty.__ptr__());
                return ty;
            }
            binary_kind::bxor => {
                var ty = self->resolve_bitwise_operator(n);
                n->base.resolved_type.reset_with(ty.__ptr__());
                return ty;
            }
        }

        unreachable();
        return type::error_type();
    }

    func resolve_type_convert(self, n: ast_type_convert*) -> type {
        var res = self->resolve_expression(n->from);
        var type_res = self->tr.resolve(n->to);
        if (res.is_error() || type_res.is_error()) {
            res.delete();
            type_res.delete();
            return type::error_type();
        }

        // convert floating point number to pointer is unsafe at all
        if ((res.is_float() && !res.is_pointer() && type_res.is_pointer()) ||
            (res.is_pointer() && type_res.is_float() && !type_res.is_pointer())) {
            var info = str::from("cannot cast floating point number to pointer: \"");
            var r_name = res.full_path_name(self->pkg, true);
            var t_name = type_res.full_path_name(self->pkg, true);
            info.append_str(r_name.__ptr__())->append_i8_vec("\" => \")");
            info.append_str(t_name.__ptr__());
            self->err->error(n->to->base.location, info.c_str);
            info.delete();
            r_name.delete();
            t_name.delete();
            res.delete();
            type_res.delete();
            return type::error_type();
        }

        // struct type is not allowed to be casted
        if (self->is_struct_type(res.__ptr__()) && !res.is_pointer()) {
            var info = str::from("cannot cast struct \"");
            var r_name = res.full_path_name(self->pkg, true);
            var t_name = type_res.full_path_name(self->pkg, true);
            info.append_str(r_name.__ptr__())->append_i8_vec("\" to \")");
            info.append_str(t_name.__ptr__());
            self->err->error(n->to->base.location, info.c_str);
            info.delete();
            r_name.delete();
            t_name.delete();
            res.delete();
            type_res.delete();
            return type::error_type();
        }

        if (self->is_struct_type(type_res.__ptr__()) && !type_res.is_pointer()) {
            var info = str::from("cannot cast \"");
            var r_name = res.full_path_name(self->pkg, true);
            var t_name = type_res.full_path_name(self->pkg, true);
            info.append_str(r_name.__ptr__())->append_i8_vec("\" to struct \")");
            info.append_str(t_name.__ptr__());
            self->err->error(n->to->base.location, info.c_str);
            info.delete();
            r_name.delete();
            t_name.delete();
            res.delete();
            type_res.delete();
            return type::error_type();
        }

        res.delete();
        n->base.resolved_type.reset_with(type_res.__ptr__());
        return type_res;
    }

    func resolve_identifier(self, n: ast_identifier*) -> type {
        var name = n->content.__ptr__();
        if (self->ctx->find_local(name)) {
            return self->ctx->get_local(name)->copy_instance();
        }

        var dm: colgm_module* = nil;
        var n_ast = n => ast*;
        if (n_ast->is_redirected()) {
            dm = self->ctx->get_domain(n_ast->redirect_location.__ptr__());
        } else {
            dm = self->ctx->get_domain(n_ast->location->file.__ptr__());
        }

        if (dm->global_symbol.has(name)) {
            var sym_info = dm->global_symbol.get(name);
            if (!sym_info->is_public) {
                var info = str::from("\"");
                info.append_str(name);
                info.append_i8_vec("\" is not imported");
                self->err->error(n_ast->location, info.c_str);
                info.delete();
                return type::error_type();
            }

            var result = type::instance();
            result.name.append_str(name);
            result.loc_file.append_str(sym_info->loc_file.__ptr__());
            result.pointer_depth = 0;
            result.is_global_sym = true;
            result.is_global_func = sym_info->kind == symbol_kind::func_kind;
            return result;
        }

        var info = str::from("undefined symbol \"");
        info.append_str(name);
        info.append_char('\"');
        self->err->error(n_ast->location, info.c_str);
        info.delete();
        return type::error_type();
    }

    func resolve_call_identifier(self, n: ast_call_id*) -> type {
        var infer = self->resolve_identifier(n->id);
        if (infer.is_error()) {
            return infer;
        }

        if (n->generic_types != nil && !infer.is_global_sym) {
            self->err->error(n->base.location,
                "cannot instantiate generic type of non-global symbol"
            );
        }

        if (n->generic_types != nil) {
            var types = vec<type>::instance();
            for (var i = n->generic_types->types.iter(); !i.is_end(); i = i.next()) {
                var ty = self->tr.resolve(i.get().unwrap() => ast_type_def*);
                types.push(ty.__ptr__());
                ty.delete();
            }
            var name = n->id->content.copy_instance();
            name.append_char('<');
            for (var i = types.iter(); !i.is_end(); i = i.next()) {
                var full_name = i.get()->full_path_name(self->pkg, true);
                name.append_str(full_name.__ptr__());
                full_name.delete();
                name.append_char(',');
            }
            if (name.back() == ',') {
                name.pop_back();
            }
            name.append_char('>');

            if (!self->ctx->global->domain.has(infer.loc_file.__ptr__())) {
                var info = str::from("namespace in \"");
                info.append_str(infer.loc_file.__ptr__());
                info.append_i8_vec("\" not found");
                self->err->error(n->base.location, info.c_str);
                info.delete();
                name.delete();
                types.delete();
                return infer;
            }

            var dm = self->ctx->global->domain.get(infer.loc_file.__ptr__());
            if (dm->structs.has(name.__ptr__()) ||
                dm->functions.has(name.__ptr__())) {
                infer.name.delete();
                infer.name = n->id->content.copy_instance();
                infer.generics.delete();
                infer.generics = types.copy_instance();
            } else {
                var info = str::from("error resolving generic symbol \"");
                info.append_str(name.__ptr__());
                info.append_char('\"');
                self->err->error(n->base.location, info.c_str);
                info.delete();
            }

            name.delete();
            types.delete();
        }

        n->base.resolved_type.reset_with(infer.__ptr__());
        return infer;
    }

    func check_pub_method(self,
                          n: ast*,
                          name: str*,
                          struct_self: colgm_struct*) {
        if (!struct_self->method.has(name)) {
            return;
        }

        var m = struct_self->method.get(name);
        if (m->is_public) {
            return;
        }

        if (self->impl_struct_name.empty() ||
            !self->impl_struct_name.eq(struct_self->name.__ptr__())) {
            var info = str::from("cannot access private method \"");
            info.append_str(struct_self->name.__ptr__());
            info.append_i8_vec("::");
            info.append_str(name);
            info.append_i8_vec("\"");
            self->err->error(n->location, info.c_str);
            info.delete();
        }
    }

    func struct_method_infer(self, prev: type*, fn_name: str*) -> type {
        var infer = prev->copy_instance();
        infer.pointer_depth = 0;
        infer.is_global_sym = true;
        infer.stm_info.flag_is_static = false;
        infer.stm_info.flag_is_normal = true;
        infer.stm_info.method_name.append_str(fn_name);
        return infer;
    }

    func struct_static_method_infer(self, prev: type*, fn_name: str*) -> type {
        var infer = prev->copy_instance();
        infer.pointer_depth = 0;
        infer.is_global_sym = true;
        infer.stm_info.flag_is_static = true;
        infer.stm_info.flag_is_normal = false;
        infer.stm_info.method_name.append_str(fn_name);
        return infer;
    }

    func resolve_get_field(self, prev: type*, n: ast_get_field*) -> type {
        var prev_name = prev->full_path_name(self->pkg, true);
        var prev_name_for_search = prev->generic_name(self->pkg);

        if (prev->is_global_sym) {
            var info = str::from("cannot get field from global symbol \"");
            info.append_str(prev_name.__ptr__());
            info.append_i8_vec("\"");
            self->err->error(n->base.location, info.c_str);
            info.delete();
            prev_name.delete();
            prev_name_for_search.delete();
            return type::error_type();
        }

        if (prev->is_pointer()) {
            var info = str::from("cannot use \".\" to get field from pointer \"");
            info.append_str(prev_name.__ptr__());
            info.append_i8_vec("\". use \"->\" instead");
            self->err->error(n->base.location, info.c_str);
            info.delete();
            prev_name.delete();
            prev_name_for_search.delete();
            return type::error_type();
        }

        // loc_file is empty means prev is native type
        if (prev->loc_file.empty()) {
            var info = str::from("cannot get method \"");
            info.append_str(n->name.__ptr__());
            info.append_i8_vec("\" from native type \"");
            info.append_str(prev_name.__ptr__());
            info.append_i8_vec("\"");
            self->err->error(n->base.location, info.c_str);
            info.delete();
            prev_name.delete();
            prev_name_for_search.delete();
            return type::error_type();
        }

        var dm = self->ctx->global->domain.get(prev->loc_file.__ptr__());
        if (!dm->structs.has(prev_name_for_search.__ptr__())) {
            var info = str::from("cannot get field from \"");
            info.append_str(prev_name.__ptr__());
            info.append_i8_vec("\"");
            self->err->error(n->base.location, info.c_str);
            info.delete();
            prev_name.delete();
            prev_name_for_search.delete();
            return type::error_type();
        }

        var struct_self = dm->structs.get(prev_name_for_search.__ptr__());
        if (struct_self->fields.has(n->name.__ptr__())) {
            var infer = struct_self->fields.get(n->name.__ptr__())->copy_instance();
            n->base.resolved_type.reset_with(infer.__ptr__());
            prev_name.delete();
            prev_name_for_search.delete();
            return infer;
        }
        if (struct_self->method.has(n->name.__ptr__())) {
            self->check_pub_method(n => ast*, n->name.__ptr__(), struct_self);
            var infer = self->struct_method_infer(prev, n->name.__ptr__());
            n->base.resolved_type.reset_with(infer.__ptr__());
            prev_name.delete();
            prev_name_for_search.delete();
            return infer;
        }

        if (struct_self->static_method.has(n->name.__ptr__())) {
            var info = str::from("method \"");
            info.append_str(n->name.__ptr__());
            info.append_i8_vec("\" in \"");
            info.append_str(prev_name.__ptr__());
            info.append_i8_vec("\" is static");
            self->err->error(n->base.location, info.c_str);
            info.delete();
            prev_name.delete();
            prev_name_for_search.delete();
            return type::error_type();
        }

        var info = str::from("cannot find field \"");
        info.append_str(n->name.__ptr__());
        info.append_i8_vec("\" in \"");
        info.append_str(prev_name_for_search.__ptr__());
        info.append_i8_vec("\"");
        self->err->error(n->base.location, info.c_str);
        info.delete();
        prev_name.delete();
        prev_name_for_search.delete();
        return type::error_type();
    }

    func check_static_call_args(self,
                                func_self: colgm_func*,
                                n: ast_call_func_args*) {
        if (func_self->unordered_params.size != n->args.size) {
            var info = str::from("expect ");
            var buff = [i8; 256];
            itoa(func_self->unordered_params.size => i64, buff, 10);
            info.append_i8_vec(buff);
            info.append_i8_vec(" argument(s), but get ");
            itoa(n->args.size => i64, buff, 10);
            info.append_i8_vec(buff);
            self->err->error(n->base.location, info.c_str);
            info.delete();
            return;
        }

        for (var i = n->args.iter(); !i.is_end(); i = i.next()) {
            var arg = i.get().unwrap();
            var infer = self->resolve_expression(arg);
            if (infer.is_error()) {
                infer.delete();
                continue;
            }
            var param = func_self->param_type.get(i.index());
            if (!infer.eq(param)) {
                if (!self->check_can_be_converted(arg, param)) {
                    var info = str::from("expect \"");
                    var param_name = param->full_path_name(self->pkg, true);
                    info.append_str(param_name.__ptr__());
                    info.append_i8_vec("\" but get \"");
                    var infer_name = infer.full_path_name(self->pkg, true);
                    info.append_str(infer_name.__ptr__());
                    info.append_i8_vec("\"");
                    self->err->error(arg->location, info.c_str);
                    info.delete();
                    param_name.delete();
                    infer_name.delete();
                }
            }
        }
    }

    func check_method_call_args(self,
                                func_self: colgm_func*,
                                n: ast_call_func_args*) {
        if (func_self->unordered_params.size != n->args.size + 1) {
            var info = str::from("expect ");
            var buff = [i8; 256];
            itoa((func_self->unordered_params.size - 1) => i64, buff, 10);
            info.append_i8_vec(buff);
            info.append_i8_vec(" argument(s), but get ");
            itoa(n->args.size => i64, buff, 10);
            info.append_i8_vec(buff);
            self->err->error(n->base.location, info.c_str);
            info.delete();
            return;
        }

        for (var i = n->args.iter(); !i.is_end(); i = i.next()) {
            var arg = i.get().unwrap();
            var infer = self->resolve_expression(arg);
            if (infer.is_error()) {
                infer.delete();
                continue;
            }
            var param = func_self->param_type.get(i.index() + 1);
            if (!infer.eq(param)) {
                if (!self->check_can_be_converted(arg, param)) {
                    var info = str::from("expect \"");
                    var param_name = param->full_path_name(self->pkg, true);
                    info.append_str(param_name.__ptr__());
                    info.append_i8_vec("\" but get \"");
                    var infer_name = infer.full_path_name(self->pkg, true);
                    info.append_str(infer_name.__ptr__());
                    info.append_i8_vec("\"");
                    self->err->error(arg->location, info.c_str);
                    info.delete();
                    param_name.delete();
                    infer_name.delete();
                }
            }
        }
    }

    func resolve_call_func_args(self, prev: type*, n: ast_call_func_args*) -> type {
        var prev_name_for_search = prev->generic_name(self->pkg);
        // global function call
        if (prev->is_global_func) {
            var dm = self->ctx->global->domain.get(prev->loc_file.__ptr__());
            var func_self = dm->functions.get(prev_name_for_search.__ptr__());
            self->check_static_call_args(func_self, n);
            prev_name_for_search.delete();
            var infer = func_self->return_type.copy_instance();
            n->base.resolved_type.reset_with(infer.__ptr__());
            return infer;
        }

        // static method call of native type
        if (prev->prm_info.flag_is_static) {
            var primitive = self->ctx->global->primitives.get(prev_name_for_search.__ptr__());
            var method = primitive->static_method.get(
                prev->prm_info.method_name.__ptr__()
            );
            self->check_static_call_args(method, n);
            prev_name_for_search.delete();
            var infer = method->return_type.copy_instance();
            n->base.resolved_type.reset_with(infer.__ptr__());
            return infer;
        }

        // static method call of struct
        if (prev->stm_info.flag_is_static) {
            var dm = self->ctx->global->domain.get(prev->loc_file.__ptr__());
            var struct_self = dm->structs.get(prev_name_for_search.__ptr__());
            var method = struct_self->static_method.get(
                prev->stm_info.method_name.__ptr__()
            );
            self->check_static_call_args(method, n);
            prev_name_for_search.delete();
            var infer = method->return_type.copy_instance();
            n->base.resolved_type.reset_with(infer.__ptr__());
            return infer;
        }

        // normal method call of struct
        if (prev->stm_info.flag_is_normal) {
            var dm = self->ctx->global->domain.get(prev->loc_file.__ptr__());
            var struct_self = dm->structs.get(prev_name_for_search.__ptr__());
            var method = struct_self->method.get(
                prev->stm_info.method_name.__ptr__()
            );
            self->check_method_call_args(method, n);
            prev_name_for_search.delete();
            var infer = method->return_type.copy_instance();
            n->base.resolved_type.reset_with(infer.__ptr__());
            return infer;
        }

        self->err->error(n->base.location, "cannot call non-function");
        prev_name_for_search.delete();
        return type::error_type();
    }

    func resolve_call_index(self, prev: type*, n: ast_call_index*) -> type {
        if (prev->is_global_sym) {
            var info = str::from("cannot get index from global symbol \"");
            var prev_name = prev->generic_name(self->pkg);
            info.append_str(prev_name.__ptr__());
            info.append_i8_vec("\"");
            self->err->error(n->base.location, info.c_str);
            info.delete();
            prev_name.delete();
            return type::error_type();
        }

        if (!prev->is_pointer()) {
            var info = str::from("cannot get index from \"");
            var prev_name = prev->full_path_name(self->pkg, true);
            info.append_str(prev_name.__ptr__());
            info.append_i8_vec("\"");
            self->err->error(n->base.location, info.c_str);
            info.delete();
            prev_name.delete();
            return type::error_type();
        }

        // resolve index infer, not necessary to check if it is error type
        var index_infer = self->resolve_expression(n->index);
        if (!index_infer.is_error()) {
            if (!index_infer.is_integer() || index_infer.is_pointer()) {
                var info = str::from("cannot get index with \"");
                var ii_name = index_infer.full_path_name(self->pkg, true);
                info.append_str(ii_name.__ptr__());
                info.append_i8_vec("\"");
                self->err->error(n->base.location, info.c_str);
                info.delete();
                ii_name.delete();
            }
        }
        index_infer.delete();

        var infer = prev->copy_instance();
        infer.pointer_depth -= 1;
        infer.is_immutable = false;
        n->base.resolved_type.reset_with(infer.__ptr__());
        return infer;
    }

    func resolve_call_path(self, prev: type*, n: ast_call_path*) -> type {
        if (!prev->is_global_sym) {
            self->err->error(n->base.location, "cannot get path from non-global symbol");
            return type::error_type();
        }

        var prev_name_for_search = prev->generic_name(self->pkg);
        // loc_file is empty means prev is native type
        if (prev->loc_file.empty()) {
            if (!self->ctx->global->primitives.has(prev_name_for_search.__ptr__())) {
                var info = str::from("cannot get static method from primitive type \"");
                info.append_str(prev_name_for_search.__ptr__());
                info.append_i8_vec("\"");
                self->err->error(n->base.location, info.c_str);
                info.delete();
                prev_name_for_search.delete();
                return type::error_type();
            }

            var p = self->ctx->global->primitives.get(prev_name_for_search.__ptr__());
            if (!p->static_method.has(n->name.__ptr__())) {
                var info = str::from("cannot find static method \"");
                info.append_str(n->name.__ptr__());
                info.append_i8_vec("\" in \"");
                info.append_str(prev_name_for_search.__ptr__());
                info.append_i8_vec("\"");
                self->err->error(n->base.location, info.c_str);
                info.delete();
                prev_name_for_search.delete();
                return type::error_type();
            }

            var infer = prev->copy_instance();
            infer.pointer_depth = 0;
            infer.is_global_sym = true;
            infer.prm_info.flag_is_static = true;
            infer.prm_info.flag_is_normal = false;
            infer.prm_info.method_name.append_str(n->name.__ptr__());

            prev_name_for_search.delete();
            return infer;
        }

        var dm = self->ctx->global->domain.get(prev->loc_file.__ptr__());
        if (dm->structs.has(prev_name_for_search.__ptr__()) &&
            prev->is_global_sym) {
            var st = dm->structs.get(prev_name_for_search.__ptr__());
            if (st->static_method.has(n->name.__ptr__())) {
                self->check_pub_method(n => ast*, n->name.__ptr__(), st);
                var infer = self->struct_static_method_infer(prev, n->name.__ptr__());
                n->base.resolved_type.reset_with(infer.__ptr__());
                prev_name_for_search.delete();
                return infer;
            } else if (st->method.has(n->name.__ptr__())) {
                var info = str::from("\"");
                info.append_str(n->name.__ptr__());
                info.append_i8_vec("\" in \"");
                info.append_str(prev_name_for_search.__ptr__());
                info.append_i8_vec("\" is not a static method");
                self->err->error(n->base.location, info.c_str);
                info.delete();
                prev_name_for_search.delete();
                return type::error_type();
            } else {
                var info = str::from("cannot find static method \"");
                info.append_str(n->name.__ptr__());
                info.append_i8_vec("\" in \"");
                info.append_str(prev_name_for_search.__ptr__());
                info.append_i8_vec("\"");
                self->err->error(n->base.location, info.c_str);
                info.delete();
                prev_name_for_search.delete();
                return type::error_type();
            }
            // unreachable
            prev_name_for_search.delete();
            return type::error_type();
        } else if (dm->enums.has(prev_name_for_search.__ptr__()) &&
            prev->is_global_sym) {
            var en = dm->enums.get(prev_name_for_search.__ptr__());
            if (en->members.has(n->name.__ptr__())) {
                var infer = prev->copy_instance();
                infer.is_global_sym = false;
                infer.is_enum = true;
                n->base.resolved_type.reset_with(infer.__ptr__());
                prev_name_for_search.delete();
                return infer;
            }

            var info = str::from("cannot find enum member \"");
            info.append_str(n->name.__ptr__());
            info.append_i8_vec("\" in \"");
            info.append_str(prev_name_for_search.__ptr__());
            info.append_i8_vec("\"");
            self->err->error(n->base.location, info.c_str);
            info.delete();
            prev_name_for_search.delete();
            return type::error_type();
        } else {
            var info = str::from("cannot find path \"");
            info.append_str(n->name.__ptr__());
            info.append_i8_vec("\" in \"");
            info.append_str(prev_name_for_search.__ptr__());
            info.append_i8_vec("\"");
            self->err->error(n->base.location, info.c_str);
            info.delete();
            prev_name_for_search.delete();
            return type::error_type();
        }

        return type::error_type();
    }

    func resolve_initializer(self, prev: type*, n: ast_initializer*) -> type {
        if (!prev->is_global_sym) {
            self->err->error(n->base.location, "need a global symbol to initialize");
            return type::error_type();
        }
        if (prev->loc_file.empty()) {
            self->err->error(n->base.location,
                "basic type cannot be initialized as a struct"
            );
            return type::error_type();
        }

        var dm = self->ctx->global->domain.get(prev->loc_file.__ptr__());
        var prev_name_for_search = prev->generic_name(self->pkg);
        if (!dm->structs.has(prev_name_for_search.__ptr__())) {
            var info = str::from("\"");
            info.append_str(prev_name_for_search.__ptr__());
            info.append_i8_vec("\" is not a struct type, cannot initialize");
            self->err->error(n->base.location, info.c_str);
            info.delete();
            prev_name_for_search.delete();
            return type::error_type();
        }

        var struct_self = dm->structs.get(prev_name_for_search.__ptr__());
        for (var i = n->pairs.iter(); !i.is_end(); i = i.next()) {
            var tmp = i.get().unwrap() => ast_init_pair*;
            var field = tmp->field->content.__ptr__();
            if (!struct_self->fields.has(field)) {
                var info = str::from("cannot find field \"");
                info.append_str(field);
                info.append_i8_vec("\" in \"");
                info.append_str(prev_name_for_search.__ptr__());
                info.append_i8_vec("\"");
                self->err->error(tmp->base.location, info.c_str);
                info.delete();
                continue;
            }

            var infer = self->resolve_expression(tmp->value);
            tmp->base.resolved_type.reset_with(infer.__ptr__());
            if (infer.is_error()) {
                infer.delete();
                continue;
            }

            var expect = struct_self->fields.get(field);
            if (!infer.eq(expect)) {
                if (!self->check_can_be_converted(tmp->value, expect)) {
                    var info = str::from("expect \"");
                    var e_name = expect->full_path_name(self->pkg, true);
                    var i_name = infer.full_path_name(self->pkg, true);
                    info.append_str(e_name.__ptr__());
                    info.append_i8_vec("\" but get \"");
                    info.append_str(i_name.__ptr__());
                    self->err->error(tmp->base.location, info.c_str);
                    info.delete();
                    e_name.delete();
                    i_name.delete();
                    continue;
                }
            }
        }

        prev_name_for_search.delete();
        var copy = prev->copy_instance();
        copy.is_global_sym = false;
        n->base.resolved_type.reset_with(copy.__ptr__());
        return copy;
    }

    func resolve_ptr_get_field(self, prev: type*, n: ast_ptr_get_field*) -> type {
        var prev_name = prev->full_path_name(self->pkg, true);
        var prev_name_for_search = prev->generic_name(self->pkg);

        if (prev->is_global_sym) {
            var info = str::from("cannot get field from global symbol \"");
            info.append_str(prev_name.__ptr__());
            info.append_i8_vec("\"");
            self->err->error(n->base.location, info.c_str);
            info.delete();
            prev_name.delete();
            prev_name_for_search.delete();
            return type::error_type();
        }

        if (prev->pointer_depth != 1) {
            var info = str::from("cannot use \"->\" to get field from pointer \"");
            info.append_str(prev_name.__ptr__());
            info.append_i8_vec("\"");
            self->err->error(n->base.location, info.c_str);
            info.delete();
            prev_name.delete();
            prev_name_for_search.delete();
            return type::error_type();
        }

        // loc_file is empty means prev is native type
        if (prev->loc_file.empty()) {
            var info = str::from("cannot get method \"");
            info.append_str(n->name.__ptr__());
            info.append_i8_vec("\" from native type \"");
            info.append_str(prev_name.__ptr__());
            info.append_i8_vec("\"");
            self->err->error(n->base.location, info.c_str);
            info.delete();
            prev_name.delete();
            prev_name_for_search.delete();
            return type::error_type();
        }

        var dm = self->ctx->global->domain.get(prev->loc_file.__ptr__());
        if (!dm->structs.has(prev_name_for_search.__ptr__())) {
            var info = str::from("cannot get field from \"");
            info.append_str(prev_name.__ptr__());
            info.append_i8_vec("\"");
            self->err->error(n->base.location, info.c_str);
            info.delete();
            prev_name.delete();
            prev_name_for_search.delete();
            return type::error_type();
        }

        var struct_self = dm->structs.get(prev_name_for_search.__ptr__());
        if (struct_self->fields.has(n->name.__ptr__())) {
            var infer = struct_self->fields.get(n->name.__ptr__())->copy_instance();
            n->base.resolved_type.reset_with(infer.__ptr__());
            prev_name.delete();
            prev_name_for_search.delete();
            return infer;
        }
        if (struct_self->method.has(n->name.__ptr__())) {
            self->check_pub_method(n => ast*, n->name.__ptr__(), struct_self);
            var infer = self->struct_method_infer(prev, n->name.__ptr__());
            n->base.resolved_type.reset_with(infer.__ptr__());
            prev_name.delete();
            prev_name_for_search.delete();
            return infer;
        }

        if (struct_self->static_method.has(n->name.__ptr__())) {
            var info = str::from("method \"");
            info.append_str(n->name.__ptr__());
            info.append_i8_vec("\" in \"");
            info.append_str(prev_name.__ptr__());
            info.append_i8_vec("\" is static");
            self->err->error(n->base.location, info.c_str);
            info.delete();
            prev_name.delete();
            prev_name_for_search.delete();
            return type::error_type();
        }

        var info = str::from("cannot find field \"");
        info.append_str(n->name.__ptr__());
        info.append_i8_vec("\" in \"");
        info.append_str(prev_name_for_search.__ptr__());
        info.append_i8_vec("\"");
        self->err->error(n->base.location, info.c_str);
        info.delete();
        prev_name.delete();
        prev_name_for_search.delete();
        return type::error_type();
    }

    func resolve_call(self, n: ast_call*) -> type {
        var infer = self->resolve_call_identifier(n->head);
        if (infer.is_error()) {
            return infer;
        }

        for (var i = n->chain.iter(); !i.is_end(); i = i.next()) {
            var c = i.get().unwrap();
            if (c->kind != ast_kind::ast_call_func_args &&
                infer.is_function()) {
                self->err->error(c->location, "function should be called before");
                infer.delete();
                return type::error_type();
            }

            var prev = infer.copy_instance();
            infer.delete();
            match (c->kind) {
                ast_kind::ast_get_field => {
                    infer = self->resolve_get_field(
                        prev.__ptr__(),
                        c => ast_get_field*
                    );
                }
                ast_kind::ast_call_func_args => {
                    infer = self->resolve_call_func_args(
                        prev.__ptr__(),
                        c => ast_call_func_args*
                    );
                }
                ast_kind::ast_call_index => {
                    infer = self->resolve_call_index(
                        prev.__ptr__(),
                        c => ast_call_index*
                    );
                }
                ast_kind::ast_call_path => {
                    infer = self->resolve_call_path(
                        prev.__ptr__(),
                        c => ast_call_path*
                    );
                }
                ast_kind::ast_initializer => {
                    infer = self->resolve_initializer(
                        prev.__ptr__(),
                        c => ast_initializer*
                    );
                }
                ast_kind::ast_ptr_get_field => {
                    infer = self->resolve_ptr_get_field(
                        prev.__ptr__(),
                        c => ast_ptr_get_field*
                    );
                }
                _ => {
                    self->err->unimplemented(c->location);
                    prev.delete();
                    return type::error_type();
                }
            }
            prev.delete();
            // interrupt if error occur
            if (infer.is_error()) {
                return infer;
            }
        }

        // infer should not be a function
        if (infer.is_function()) {
            self->err->error(n->base.location, "function should be called here");
            infer.delete();
            return type::error_type();
        }

        n->base.resolved_type.reset_with(infer.__ptr__());
        // infer should not be a global symbol
        if (infer.is_global_sym) {
            var info = str::from("get global symbol \"");
            var f_n = infer.full_path_name(self->pkg, true);
            info.append_str(f_n.__ptr__());
            info.append_i8_vec("\", but not an instance");
            self->err->error(n->base.location, info.c_str);
            f_n.delete();
            info.delete();
        }
        return infer;
    }

    func check_valid_left_value(self, n: ast_call*) -> bool {
        for (var i = n->chain.iter(); !i.is_end(); i = i.next()) {
            var tmp = i.get().unwrap();
            if (tmp->kind == ast_kind::ast_initializer) {
                self->err->error(
                    tmp->location,
                    "bad left value: should not contain initializer"
                );
                return false;
            }
            if (tmp->kind == ast_kind::ast_call_path) {
                self->err->error(
                    tmp->location,
                    "bad left value: should not contain call path"
                );
                return false;
            }
            if (tmp->kind == ast_kind::ast_call_func_args &&
                i.index() == n->chain.size - 1) {
                self->err->error(
                    tmp->location,
                    "bad left value: should not end with function call"
                );
                return false;
            }
        }

        var seg: ast* = nil;
        var maybe_invalid_assignment = false;
        for (var i = n->chain.iter(); !i.is_end(); i = i.next()) {
            var tmp = i.get().unwrap();
            if (tmp->kind == ast_kind::ast_call_func_args &&
                !tmp->resolved_type.is_pointer()) {
                seg = tmp;
                maybe_invalid_assignment = true;
            } else if (tmp->kind == ast_kind::ast_ptr_get_field) {
                maybe_invalid_assignment = false;
            }
        }

        if (maybe_invalid_assignment && seg != nil) {
            self->err->warn(
                seg->location,
                "function returning non-pointer type, will do shallow copy, may cause invalid assignment"
            );
        }
        return true;
    }

    func check_mutale_left_value(self, n: ast_call*, left: type*) {
        if (!left->is_immutable) {
            return;
        }
        var info = str::from("cannot assign to \"const ");
        var l_name = left->full_path_name(self->pkg, true);
        info.append_str(l_name.__ptr__());
        info.append_i8_vec("\"");
        self->err->error(n->base.location, info.c_str);
        info.delete();
        l_name.delete();
    }

    func resolve_assignment(self, n: ast_assignment*) -> type {
        var left = self->resolve_expression(n->left => ast*);
        if (!self->check_valid_left_value(n->left)) {
            left.delete();
            return type::error_type();
        }

        // left value should be mutable
        self->check_mutale_left_value(n->left, left.__ptr__());

        var right = self->resolve_expression(n->right);
        if (left.is_error() || right.is_error()) {
            left.delete();
            right.delete();
            return type::error_type();
        }

        if (n->kind == assignment_kind::andeq ||
            n->kind == assignment_kind::xoreq ||
            n->kind == assignment_kind::oreq) {
            var l_name = left.full_path_name(self->pkg, true);
            var r_name = right.full_path_name(self->pkg, true);
            if (!left.is_integer() || left.is_pointer()) {
                var info = str::from("bitwise operator cannot be used on \"");
                info.append_str(l_name.__ptr__());
                info.append_i8_vec("\"");
                self->err->error(n->left->base.location, info.c_str);
                info.delete();
                l_name.delete();
                r_name.delete();
                left.delete();
                right.delete();
                return type::restrict_type();
            }
            if (!right.is_integer() || right.is_pointer()) {
                var info = str::from("bitwise operator cannot be used on \"");
                info.append_str(r_name.__ptr__());
                info.append_i8_vec("\"");
                self->err->error(n->right->location, info.c_str);
                info.delete();
                l_name.delete();
                r_name.delete();
                left.delete();
                right.delete();
                return type::restrict_type();
            }
            l_name.delete();
            r_name.delete();
        }

        if (left.is_pointer() && right.is_pointer()) {
            if (!left.eq(right.__ptr__()) &&
                !self->check_can_be_converted(n->right, left.__ptr__())) {
                var info = str::from("cannot calculate \"");
                var l_name = left.full_path_name(self->pkg, true);
                var r_name = right.full_path_name(self->pkg, true);
                info.append_str(l_name.__ptr__());
                info.append_i8_vec("\" and \"");
                info.append_str(r_name.__ptr__());
                info.append_i8_vec("\"");
                self->err->error(n->right->location, info.c_str);
                info.delete();
                l_name.delete();
                r_name.delete();
            }
        } else if (!left.eq(right.__ptr__())) {
            if (!self->check_can_be_converted(n->right, left.__ptr__())) {
                var info = str::from("get \"");
                var l_name = left.full_path_name(self->pkg, true);
                var r_name = right.full_path_name(self->pkg, true);
                info.append_str(r_name.__ptr__());
                info.append_i8_vec("\" but expect \"");
                info.append_str(l_name.__ptr__());
                info.append_i8_vec("\"");
                self->err->error(n->right->location, info.c_str);
                info.delete();
                l_name.delete();
                r_name.delete();
            }
        }

        left.delete();
        right.delete();

        // only = is allowed to be applied on enums
        if (self->is_enum_type(left.__ptr__()) && n->kind != assignment_kind::eq) {
            var info = str::from("cannot calculate enum \"");
            var l_name = left.full_path_name(self->pkg, true);
            info.append_str(l_name.__ptr__());
            info.append_i8_vec("\"");
            self->err->error(n->left->base.location, info.c_str);
            info.delete();
            l_name.delete();
        }

        var infer = type::restrict_type();
        n->base.resolved_type.reset_with(infer.__ptr__());
        return infer;
    }

    func resolve_expression(self, n: ast*) -> type {
        match (n->kind) {
            ast_kind::ast_unary_operator => {
                return self->resolve_unary_operator(n => ast_unary_operator*);
            }
            ast_kind::ast_binary_operator => {
                return self->resolve_binary_operator(n => ast_binary_operator*);
            }
            ast_kind::ast_type_convert => {
                return self->resolve_type_convert(n => ast_type_convert*);
            }
            ast_kind::ast_nil_literal => {
                return self->resolve_nil_literal(n => ast_nil_literal*);
            }
            ast_kind::ast_number_literal => {
                return self->resolve_number_literal(n => ast_number_literal*);
            }
            ast_kind::ast_string_literal => {
                return self->resolve_string_literal(n => ast_string_literal*);
            }
            ast_kind::ast_char_literal => {
                return self->resolve_char_literal(n => ast_char_literal*);
            }
            ast_kind::ast_bool_literal => {
                return self->resolve_bool_literal(n => ast_bool_literal*);
            }
            ast_kind::ast_array_literal => {
                return self->resolve_array_literal(n => ast_array_literal*);
            }
            ast_kind::ast_call => {
                return self->resolve_call(n => ast_call*);
            }
            ast_kind::ast_assignment => {
                return self->resolve_assignment(n => ast_assignment*);
            }
            _ => { unreachable(); }
        }
        return type::error_type();
    }
}

impl sema {
    func check_defined_variable_is_void(self, n: ast_definition*, ty: type*) {
        var ty_path = ty->full_path_name(self->pkg, true);
        ty_path.delete();
        if (!ty->is_void()) {
            return;
        }
        self->err->error(
            n->base.location,
            "cannot define variable with void type"
        );
    }

    func number_literal_can_be_converted(self, n: ast*, expect_type: type*) -> bool {
        // if is not number literal, just return false
        if (!n->is(ast_kind::ast_number_literal)) {
            return false;
        }

        // check if number literal is pointer type
        // in most cases it should not be pointer type
        var n_type = n->resolved_type.__ptr__();
        if (n_type->is_pointer()) {
            return false;
        }

        // if expect a pointer type,
        if (expect_type->is_pointer()) {
            // allow integer to convert to pointer may cause confusion
            // because if user used C before, in this example:
            //   <i64*> s += 1
            // in fact this is equal to:
            //   <i8*> s += 8
            // to avoid this confusion, we should not allow this conversion
            return false;
        }

        // use same integer type as expected
        if (expect_type->is_integer() && n_type->is_integer()) {
            n->resolved_type.reset_with(expect_type);
            return true;
        }
        // use same float type as expected
        if (expect_type->is_float() && n_type->is_float()) {
            n->resolved_type.reset_with(expect_type);
            return true;
        }

        return false;
    }

    func unary_number_can_be_converted(self, n: ast*, expect_type: type*) -> bool {
        if (!n->is(ast_kind::ast_unary_operator)) {
            return false;
        }
        var UO = n => ast_unary_operator*;
        if (UO->kind != unary_kind::neg) {
            return false;
        }
        if (self->number_literal_can_be_converted(UO->value, expect_type)) {
            n->resolved_type.reset_with(expect_type);
            return true;
        }
        return false;
    }

    func nil_can_be_convered(self, n: ast*, expect_type: type*) -> bool {
        if (!n->is(ast_kind::ast_nil_literal)) {
            return false;
        }
        if (!expect_type->is_pointer()) {
            return false;
        }
        n->resolved_type.reset_with(expect_type);
        return true;
    }

    func check_can_be_converted(self, n: ast*, expect_type: type*) -> bool {
        if (self->number_literal_can_be_converted(n, expect_type)) {
            return true;
        }
        if (self->unary_number_can_be_converted(n, expect_type)) {
            return true;
        }
        if (self->nil_can_be_convered(n, expect_type)) {
            return true;
        }
        return false;
    }

    func resolve_definition(self, n: ast_definition*, func_self: colgm_func*) {
        var name = n->name.__ptr__();
        // check if conflicts with local variable
        if (self->ctx->find_local(name)) {
            var info = str::from("redefinition of variable \"");
            info.append_str(name);
            info.append_i8_vec("\"");
            self->err->error(n->base.location, info.c_str);
            info.delete();
            return;
        }

        // check if conflicts with global symbol
        if (self->ctx->global_symbol()->has(name)) {
            var info = str::from("variable \"");
            info.append_str(name);
            info.append_i8_vec("\" conflicts with global symbol");
            self->err->error(n->base.location, info.c_str);
            info.delete();
            return;
        }

        // check if not initialized
        if (n->value == nil) {
            self->err->error(n->base.location, "variable must be initialized");
            return;
        }

        if (n->type == nil) {
            var real_type = self->resolve_expression(n->value);
            n->base.resolved_type.reset_with(real_type.__ptr__());
            self->ctx->add_local_var(name, real_type.__ptr__());
            self->check_defined_variable_is_void(n, real_type.__ptr__());
            real_type.delete();
            return;
        }

        // with type declaration
        var expect_type = self->tr.resolve(n->type);
        var real_type = self->resolve_expression(n->value);
        if (expect_type.is_error() || real_type.is_error()) {
            expect_type.delete();
            real_type.delete();
            return;
        }
        if (expect_type.is_pointer() && real_type.is_pointer()) {
            // if is not the same type pointer and cannot be automatically converted
            // report a warning here
            if (!expect_type.eq(real_type.__ptr__()) &&
                !self->check_can_be_converted(n->value, expect_type.__ptr__())) {
                var info = str::instance();
                var expect_type_name = expect_type.full_path_name(self->pkg, true);
                var real_type_name = real_type.full_path_name(self->pkg, true);
                info.append_i8_vec("expect \"");
                info.append_i8_vec(expect_type_name.c_str);
                info.append_i8_vec("\", but get \"");
                info.append_i8_vec(real_type_name.c_str);
                self->err->warn(n->base.location, info.c_str);
                info.delete();
                expect_type_name.delete();
                real_type_name.delete();
            }
        } else if (!expect_type.eq(real_type.__ptr__()) &&
            !self->check_can_be_converted(n->value, expect_type.__ptr__())) {
            var info = str::instance();
            var expect_type_name = expect_type.full_path_name(self->pkg, true);
            var real_type_name = real_type.full_path_name(self->pkg, true);
            info.append_i8_vec("def: expect \"");
            info.append_i8_vec(expect_type_name.c_str);
            info.append_i8_vec("\", but get \"");
            info.append_i8_vec(real_type_name.c_str);
            self->err->warn(n->base.location, info.c_str);
            info.delete();
            expect_type_name.delete();
            real_type_name.delete();
        }

        // if immutable, make sure the type is correct
        if (real_type.is_immutable) {
            n->base.resolved_type.reset_with(real_type.__ptr__());
            self->ctx->add_local_var(name, real_type.__ptr__());
            self->check_defined_variable_is_void(n, real_type.__ptr__());
        } else {
            n->base.resolved_type.reset_with(expect_type.__ptr__());
            self->ctx->add_local_var(name, expect_type.__ptr__());
            self->check_defined_variable_is_void(n, expect_type.__ptr__());
        }

        expect_type.delete();
        real_type.delete();
    }

    func resolve_if_stmt(self, n: ast_if_stmt*, func_self: colgm_func*) {
        if (n->condition != nil) {
            var ty = self->resolve_expression(n->condition => ast*);
            if (!ty.is_bool() && !ty.is_error()) {
                self->err->error(n->condition->location,
                                "condition must be bool");
            }
            ty.delete();
        }

        // resolve block
        if (n->body != nil) {
            self->in_loop_level += 1;
            self->resolve_code_block(n->body, func_self);
            self->in_loop_level -= 1;
        }
    }

    func resolve_cond_stmt(self, n: ast_cond_stmt*, func_self: colgm_func*) {
        for (var i = n->stmts.iter(); !i.is_end(); i = i.next()) {
            self->resolve_if_stmt(i.get().unwrap() => ast_if_stmt*, func_self);
        }
    }

    func check_is_match_default(self, n: ast_call*) -> bool {
        if (!n->chain.empty()) {
            return false;
        }

        var name = n->head->id->content.__ptr__();
        return name->eq_const("_");
    }

    func check_is_enum_literal(self, n: ast_call*) -> bool {
        if (n->chain.size != 1) {
            return false;
        }

        var name = n->head->id->content.__ptr__();
        if (!self->ctx->global_symbol()->has(name)) {
            return false;
        }

        if (self->ctx->global_symbol()->get(name)->kind != symbol_kind::enum_kind) {
            return false;
        }

        var call_node = n->chain.get(0).unwrap();
        if (call_node->kind != ast_kind::ast_call_path) {
            return false;
        }
        return true;
    }

    func get_enum_literal_value(self, n: ast_call*, infer: type*) -> i64 {
        var name = n->head->id->content.__ptr__();
        if (!self->ctx->global->domain.has(infer->loc_file.__ptr__())) {
            return 0xffffffffffffffff;
        }

        var dm = self->ctx->global->domain.get(infer->loc_file.__ptr__());
        if (!dm->enums.has(name)) {
            return 0xffffffffffffffff;
        }

        var em = dm->enums.get(name);
        var call_node = n->chain.get(0).unwrap() => ast_call_path*;
        var e_name = call_node->name.__ptr__();
        if (!em->members.has(e_name)) {
            return 0xffffffffffffffff;
        }
        return em->members.get(e_name)->unwrap();
    }

    func resolve_match_stmt(self, n: ast_match_stmt*, func_self: colgm_func*) {
        var infer = self->resolve_expression(n->value);
        // check error type
        if (infer.is_error()) {
            infer.delete();
            return;
        }

        if (!self->is_enum_type(infer.__ptr__())) {
            self->err->error(n->value->location,
                            "match value must be enum type");
            infer.delete();
            return;
        }

        if (n->cases.empty()) {
            self->err->error(n->value->location, "must have at least one case");
            infer.delete();
            return;
        }

        var default_found = false;
        var used_values = hashset<basic<i64>>::instance();
        for (var i = n->cases.iter(); !i.is_end(); i = i.next()) {
            var case_node = i.get().unwrap() => ast_match_case*;

            if (self->check_is_match_default(case_node->pattern)) {
                var case_type = type::default_match_type();
                case_node->pattern->base.resolved_type.reset_with(case_type.__ptr__());
                case_node->base.resolved_type.reset_with(case_type.__ptr__());
                default_found = true;
                self->resolve_code_block(case_node->body, func_self);
                case_type.delete();
                continue;
            }

            var case_type = self->resolve_call(case_node->pattern);
            case_node->base.resolved_type.reset_with(case_type.__ptr__());
            case_node->pattern->base.resolved_type.reset_with(case_type.__ptr__());

            if (!case_type.eq(infer.__ptr__())) {
                if (!case_type.is_error()) {
                    var info = str::from("case value should be \"");
                    var c_name = case_type.full_path_name(self->pkg, true);
                    var i_name = infer.full_path_name(self->pkg, true);
                    info.append_i8_vec(c_name.c_str);
                    info.append_i8_vec("\", but get \"");
                    info.append_i8_vec(i_name.c_str);
                    info.append_i8_vec("\"");
                    self->err->error(case_node->pattern->base.location, info.c_str);
                    info.delete();
                    c_name.delete();
                    i_name.delete();
                }
                case_type.delete();
                continue;
            }

            if (!self->check_is_enum_literal(case_node->pattern)) {
                self->err->error(case_node->pattern->base.location,
                                "match value must be enum literal");
                case_type.delete();
                continue;
            } else {
                var value = self->get_enum_literal_value(case_node->pattern, infer.__ptr__());
                if (value != 0xffffffffffffffff) {
                    var tmp = basic<i64>::wrap(value);
                    used_values.insert(tmp.__ptr__());
                }
            }

            self->resolve_code_block(case_node->body, func_self);
            case_type.delete();
        }

        if (default_found) {
            infer.delete();
            used_values.delete();
            return;
        }

        if (!self->ctx->global->domain.has(infer.loc_file.__ptr__())) {
            infer.delete();
            used_values.delete();
            return;
        }
        var dm = self->ctx->global->domain.get(infer.loc_file.__ptr__());
        if (!dm->enums.has(infer.name.__ptr__())) {
            infer.delete();
            used_values.delete();
            return;
        }
        var em = dm->enums.get(infer.name.__ptr__());
        var generated_warning = str::instance();
        var unused_counter = 0;

        for (var i = em->members.iter(); !i.is_end(); i = i.next()) {
            if (used_values.has(i.value())) {
                continue;
            }
            if (generated_warning.size > 0) {
                generated_warning.append_i8_vec(", ");
            }
            unused_counter += 1;
            if (unused_counter >= 5) {
                generated_warning.append_i8_vec("...");
                break;
            }
            generated_warning.append_str(i.key());
        }

        if (generated_warning.size > 0) {
            var info = str::from("match statement with enum \"");
            var i_name = infer.full_path_name(self->pkg, true);
            info.append_str(i_name.__ptr__());
            info.append_i8_vec("\" has unused member");
            if (unused_counter > 1) {
                info.append_i8_vec("s");
            }
            info.append_i8_vec(": ")->append_str(generated_warning.__ptr__());
            self->err->warn(n->base.location, info.c_str);
            info.delete();
            i_name.delete();
        }

        infer.delete();
        used_values.delete();
        generated_warning.delete();
    }

    func resolve_while_stmt(self, n: ast_while_stmt*, func_self: colgm_func*) {
        var infer = self->resolve_expression(n->condition => ast*);
        if (!infer.is_bool() && !infer.is_error()) {
            self->err->error(n->condition->location,
                            "condition must be bool");
        }
        infer.delete();

        // resolve block
        if (n->body != nil) {
            self->in_loop_level += 1;
            self->resolve_code_block(n->body, func_self);
            self->in_loop_level -= 1;
        }
    }

    func resolve_for_stmt(self, n: ast_for_stmt*, func_self: colgm_func*) {
        self->ctx->push_scope_level();
        if (n->init != nil) {
            self->resolve_definition(n->init, func_self);
        }
        if (n->condition != nil) {
            var ty = self->resolve_expression(n->condition => ast*);
            if (!ty.is_bool() && !ty.is_error()) {
                self->err->error(n->condition->location,
                                "condition must be bool");
            }
            ty.delete();
        }
        if (n->update != nil) {
            var ty = self->resolve_expression(n->update => ast*);
            ty.delete();
        }
        if (n->body != nil) {
            self->in_loop_level += 1;
            self->resolve_code_block(n->body, func_self);
            self->in_loop_level -= 1;
        }
        self->ctx->pop_scope_level();
    }

    func resolve_in_stmt_expr(self, n: ast_in_stmt_expr*, func_self: colgm_func*) {
        var ty = self->resolve_expression(n->value => ast*);
        n->base.resolved_type.reset_with(ty.__ptr__());
        ty.delete();
    }

    func resolve_ret_stmt(self, n: ast_ret_stmt*, func_self: colgm_func*) {
        if (n->value == nil && !func_self->return_type.is_void()) {
            self->err->error(n->base.location, "expect non-void return value");
            return;
        }

        if (n->value == nil) {
            return;
        }

        var infer = self->resolve_expression(n->value);
        if (infer.is_error()) {
            infer.delete();
            return;
        }
        if (infer.is_pointer() && func_self->return_type.is_pointer()) {
            if (!func_self->return_type.eq(infer.__ptr__()) &&
                !self->check_can_be_converted(n->value, func_self->return_type.__ptr__())) {
                var info = str::from("expected return type \"");
                var expect_type_name = func_self->return_type.full_path_name(self->pkg, true);
                info.append_i8_vec(expect_type_name.c_str);
                info.append_i8_vec("\", but get \"");
                var real_type_name = infer.full_path_name(self->pkg, true);
                info.append_i8_vec(real_type_name.c_str);
                info.append_i8_vec("\"");
                self->err->warn(n->base.location, info.c_str);
                expect_type_name.delete();
                real_type_name.delete();
                info.delete();
            }
        } else if (!func_self->return_type.eq(infer.__ptr__())) {
            if (!self->check_can_be_converted(n->value, func_self->return_type.__ptr__())) {
                var info = str::from("expected return type \"");
                var expect_type_name = func_self->return_type.full_path_name(self->pkg, true);
                info.append_i8_vec(expect_type_name.c_str);
                info.append_i8_vec("\", but get \"");
                var real_type_name = infer.full_path_name(self->pkg, true);
                info.append_i8_vec(real_type_name.c_str);
                info.append_i8_vec("\"");
                self->err->error(n->base.location, info.c_str);
                expect_type_name.delete();
                real_type_name.delete();
                info.delete();
            }
        }
        infer.delete();
    }

    func resolve_statement(self, n: ast*, func_self: colgm_func*) {
        match (n->kind) {
            ast_kind::ast_definition =>
                self->resolve_definition(n => ast_definition*, func_self);
            ast_kind::ast_cond_stmt =>
                self->resolve_cond_stmt(n => ast_cond_stmt*, func_self);
            ast_kind::ast_match_stmt =>
                self->resolve_match_stmt(n => ast_match_stmt*, func_self);
            ast_kind::ast_while_stmt =>
                self->resolve_while_stmt(n => ast_while_stmt*, func_self);
            ast_kind::ast_for_stmt =>
                self->resolve_for_stmt(n => ast_for_stmt*, func_self);
            ast_kind::ast_in_stmt_expr =>
                self->resolve_in_stmt_expr(n => ast_in_stmt_expr*, func_self);
            ast_kind::ast_ret_stmt =>
                self->resolve_ret_stmt(n => ast_ret_stmt*, func_self);
            ast_kind::ast_break_stmt => {
                if (self->in_loop_level == 0) {
                    self->err->error(n->location,
                                     "break statement is not in loop");
                }
            }
            ast_kind::ast_continue_stmt => {
                if (self->in_loop_level == 0) {
                    self->err->error(n->location,
                                     "continue statement is not in loop");
                }
            }
            // if statement only has one ';', the ast will be ast_null
            ast_kind::ast_null => {}
            _ => { unreachable(); }
        }
    }

    func resolve_code_block(self, node: ast_code_block*, func_self: colgm_func*) {
        self->ctx->push_scope_level();
        for (var i = node->stmts.iter(); !i.is_end(); i = i.next()) {
            var n = i.get().unwrap();
            self->resolve_statement(n, func_self);
            if (n->is(ast_kind::ast_ret_stmt) ||
                n->is(ast_kind::ast_break_stmt) ||
                n->is(ast_kind::ast_continue_stmt)) {
                self->report_unreachable_statements(node);
                break;
            }
        }
        self->ctx->pop_scope_level();
    }
}

impl sema {
    pub func analyse(self, root: root*) {
        self->ctx->this_file.clear();
        self->ctx->this_file.append_str(root->base.location->file.__ptr__());
        self->root = root;

        self->resolve_function_block(root);
    }

    func report_unreachable_statements(self, n: ast_code_block*) {
        var flag_block_ended = false;
        var unreachable_statements = primitive_vec<ptr<ast>>::instance();

        for (var i = n->stmts.iter(); !i.is_end(); i = i.next()) {
            var tmp = i.get().unwrap();
            if (flag_block_ended) {
                unreachable_statements.push(ptr<ast>::wrap(tmp));
            }
            if (tmp->is(ast_kind::ast_ret_stmt) ||
                tmp->is(ast_kind::ast_break_stmt) ||
                tmp->is(ast_kind::ast_continue_stmt)) {
                flag_block_ended = true;
            }
        }

        if (unreachable_statements.empty()) {
            unreachable_statements.delete();
            return;
        }

        var unreachable_location = unreachable_statements
                                   .get(0).unwrap()->location->copy();
        for (var i = unreachable_statements.iter(); !i.is_end(); i = i.next()) {
            var tmp = i.get().unwrap();
            unreachable_location->end_column = tmp->location->end_column;
            unreachable_location->end_line = tmp->location->end_line;
        }

        if (unreachable_statements.size > 1) {
            self->err->error(unreachable_location,
                             "unreachable statements");
        } else {
            self->err->error(unreachable_location,
                             "unreachable statement");
        }

        unreachable_statements.delete();
        unreachable_location->delete();
        free(unreachable_location => i8*);
    }

    func report_top_level_block_has_no_return(self,
                                              n: ast_code_block*,
                                              func_self: colgm_func*) {
        var flag_has_return = false;
        for (var i = n->stmts.iter(); !i.is_end(); i = i.next()) {
            var tmp = i.get().unwrap();
            if (tmp->is(ast_kind::ast_ret_stmt)) {
                flag_has_return = true;
                break;
            }
        }

        if (flag_has_return) {
            return;
        }

        if (func_self->return_type.is_void()) {
            var rs = ast_ret_stmt::new(n->base.location->copy());
            n->stmts.push(ptr<ast>::wrap(rs => ast*));
            return;
        }

        self->err->error(n->base.location, "function has no return statement");
    }

    func resolve_function_block(self, r: root*) {
        for (var i = r->decls.iter(); !i.is_end(); i = i.next()) {
            var n = i.get().unwrap();
            if (n->is(ast_kind::ast_impl)) {
                self->resolve_impl(n => ast_impl*);
            }
            if (n->is(ast_kind::ast_func_decl)) {
                self->resolve_global_func(n => ast_func_decl*);
            }
        }
    }

    func resolve_impl(self, node: ast_impl*) {
        // do not resolve generic impl
        if (node->generic_types != nil) {
            return;
        }

        var loc_file = self->ctx->this_file.copy_instance();
        if (self->ctx->global_symbol()->has(node->name.__ptr__())) {
            loc_file.clear();
            loc_file.append_str(
                self->ctx->global_symbol()
                         ->get(node->name.__ptr__())
                         ->loc_file.__ptr__()
            );
        }

        var dm = self->ctx->global->domain.get(loc_file.__ptr__());
        if (!dm->structs.has(node->name.__ptr__())) {
            var info = str::from("cannot implement \"");
            info.append_str(node->name.__ptr__());
            info.append_i8_vec("\", because it is not defined in the same file");
            self->err->error(node->base.location, info.c_str);
            info.delete();
            return;
        }

        var struct_self = dm->structs.get(node->name.__ptr__());
        self->impl_struct_name.clear();
        self->impl_struct_name.append_str(node->name.__ptr__());
        for (var i = node->methods.iter(); !i.is_end(); i = i.next()) {
            var func_node = i.get().unwrap();
            self->resolve_method(func_node => ast_func_decl*, struct_self);
        }
        self->impl_struct_name.clear();
    }

    func resolve_global_func(self, node: ast_func_decl*) {
        // do not resolve generic function
        if (node->generic_types != nil) {
            return;
        }

        var dm = self->ctx->global->domain.get(self->ctx->this_file.__ptr__());
        if (!dm->functions.has(node->name.__ptr__())) {
            var info = str::from("cannot find function \"");
            info.append_str(node->name.__ptr__());
            info.append_i8_vec("\"");
            self->err->error(node->base.location, info.c_str);
            info.delete();
            return;
        }

        var func_self = dm->functions.get(node->name.__ptr__());
        if (node->body == nil) {
            if (!func_self->is_extern) {
                var info = str::from("non-extern function \"");
                info.append_str(node->name.__ptr__());
                info.append_i8_vec("\" is not implemented");
                self->err->error(node->base.location, info.c_str);
                info.delete();
            }
            return;
        }

        self->ctx->push_scope_level();
        for (var p = func_self->unordered_params.iter(); !p.is_end(); p = p.next()) {
            var param_name = p.key();
            var param_type = p.value();
            self->ctx->add_local_var(param_name, param_type);
        }
        for (var i = node->body->stmts.iter(); !i.is_end(); i = i.next()) {
            var n = i.get().unwrap();
            self->resolve_statement(n, func_self);
            if (n->is(ast_kind::ast_ret_stmt) ||
                n->is(ast_kind::ast_break_stmt) ||
                n->is(ast_kind::ast_continue_stmt)) {
                self->report_unreachable_statements(node->body);
                break;
            }
        }
        self->report_top_level_block_has_no_return(node->body, func_self);
        self->ctx->pop_scope_level();
    }

    func resolve_method(self, node: ast_func_decl*, struct_self: colgm_struct*) {
        if (node->body == nil) {
            self->err->error(node->base.location,
                             "method should be implemented");
            return;
        }
        
        var method_self: colgm_func* = nil;
        if (struct_self->method.has(node->name.__ptr__())) {
            method_self = struct_self->method.get(node->name.__ptr__());
        } else {
            method_self = struct_self->static_method.get(node->name.__ptr__());
        }

        self->ctx->push_scope_level();
        for (var p = method_self->unordered_params.iter(); !p.is_end(); p = p.next()) {
            var param_name = p.key();
            var param_type = p.value();
            self->ctx->add_local_var(param_name, param_type);
        }
        for (var i = node->body->stmts.iter(); !i.is_end(); i = i.next()) {
            var n = i.get().unwrap();
            self->resolve_statement(n, method_self);
            if (n->is(ast_kind::ast_ret_stmt) ||
                n->is(ast_kind::ast_break_stmt) ||
                n->is(ast_kind::ast_continue_stmt)) {
                self->report_unreachable_statements(node->body);
                break;
            }
        }
        self->report_top_level_block_has_no_return(node->body, method_self);
        self->ctx->pop_scope_level();
    }
}

impl sema {
    pub func view_resolved_ast(self, out: io) {
        var dumper = ast_dumper::instance();
        dumper.pkg = self->pkg;
        dumper.dump(self->root => ast*, out);
        dumper.delete();
    }
}