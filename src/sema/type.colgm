use std::str::{ str };
use std::vec::{ vec };
use std::io::{ io };
use std::panic::{ panic };

use err::span::{ span };
use util::package::{ package };

struct method_info {
    is_struct_method: bool,
    is_primitive_method: bool,
    flag_is_static: bool,
    flag_is_normal: bool,
    method_name: str
}

impl method_info {
    pub func instance() -> method_info {
       return method_info {
            is_struct_method: false,
            is_primitive_method: false,
            flag_is_static: false,
            flag_is_normal: false,
            method_name: str::from("")
        };
    }

    pub func clone(self) -> method_info {
        return method_info {
            is_struct_method: self.is_struct_method,
            is_primitive_method: self.is_primitive_method,
            flag_is_static: self.flag_is_static,
            flag_is_normal: self.flag_is_normal,
            method_name: self.method_name.clone()
        };
    }

    pub func delete(self) {
        self.method_name.delete();
    }

    pub func set_static_struct_method(self, name: const i8*) {
        self.is_struct_method = true;
        self.flag_is_static = true;
        self.method_name.append(name);
    }

    pub func set_normal_struct_method(self, name: const i8*) {
        self.is_struct_method = true;
        self.flag_is_normal = true;
        self.method_name.append(name);
    }

    pub func set_static_primitive_method(self, name: const i8*) {
        self.is_primitive_method = true;
        self.flag_is_static = true;
        self.method_name.append(name);
    }

    pub func set_normal_primitive_method(self, name: const i8*) {
        self.is_primitive_method = true;
        self.flag_is_normal = true;
        self.method_name.append(name);
    }
}

pub struct type {
    name: str,
    loc_file: str,
    pointer_depth: i64,
    is_global_sym: bool,  // global symbol
    is_global_func: bool, // global function
    is_enum: bool,        // enum type
    is_const: bool,       // const type

    array_length: u64,    // array length
    is_array: bool,       // array type

    is_reference: bool,   // reference type

    m_info: method_info,  // mark this is method info type

    generics: vec<type>
}

impl type {
    pub func delete(self) {
        self.name.delete();
        self.loc_file.delete();
        self.m_info.delete();
        self.generics.delete();
    }

    pub func reset_with(self, t: type*) {
        self.delete();
        self.name = t->name.clone();
        self.loc_file = t->loc_file.clone();
        self.pointer_depth = t->pointer_depth;
        self.is_global_sym = t->is_global_sym;
        self.is_global_func = t->is_global_func;
        self.is_enum = t->is_enum;
        self.array_length = t->array_length;
        self.is_array = t->is_array;
        self.is_reference = t->is_reference;
        self.is_const = t->is_const;
        self.m_info = t->m_info.clone();
        self.generics = t->generics.clone();
    }

    pub func clone(self) -> type {
        return type {
            name: self.name.clone(),
            loc_file: self.loc_file.clone(),
            pointer_depth: self.pointer_depth,
            is_global_sym: self.is_global_sym,
            is_global_func: self.is_global_func,
            is_enum: self.is_enum,
            array_length: self.array_length,
            is_array: self.is_array,
            is_reference: self.is_reference,
            is_const: self.is_const,
            m_info: self.m_info.clone(),
            generics: self.generics.clone()
        };
    }

    pub func ref_copy(self) -> type {
        var res = self.clone();
        if (res.pointer_depth == 0) {
            panic("get ref copy from non-pointer type");
        }
        if (res.pointer_depth > 0) {
            res.pointer_depth -= 1;
        }
        return res;
    }

    pub func pointer_copy(self) -> type {
        var res = self.clone();
        res.pointer_depth += 1;
        return res;
    }
}

impl type {
    pub func check_pointer_depth(self) {
        if (self.pointer_depth >= 0) {
            return;
        }
        io::stderr().out("invalid pointer depth: ").out_i64(self.pointer_depth);
        panic("invalid pointer depth");
    }
}

impl type {
    pub func instance(name: const i8*, loc_file: const i8*) -> type {
        return type {
            name: str::from(name),
            loc_file: str::from(loc_file),
            pointer_depth: 0,
            is_global_sym: false,
            is_global_func: false,
            is_enum: false,
            array_length: 0,
            is_array: false,
            is_reference: false,
            is_const: false,
            m_info: method_info::instance(),
            generics: vec<type>::instance()
        };
    }

    pub func eq(self, t: type*) -> bool {
        if (!self.name.eq(t->name.__ptr__())) {
            return false;
        }
        if (self.pointer_depth != t->pointer_depth) {
            return false;
        }
        if (self.generics.size != t->generics.size) {
            return false;
        }
        foreach (var i; self.generics) {
            var t_g = t->generics.get(i.index());
            if (!i.get().eq(t_g.__ptr__())) {
                return false;
            }
        }
        return true;
    }

    pub func is_pointer(self) -> bool {
        return self.pointer_depth > 0;
    }

    pub func is_empty(self) -> bool {
        return self.name.empty() && self.loc_file.empty();
    }

    pub func is_error(self) -> bool {
        return self.name.eq_const("<error>");
    }

    pub func is_empty_array(self) -> bool {
        return self.name.eq_const("<empty-array>");
    }

    pub func is_void(self) -> bool {
        return self.name.eq_const("void") &&
               self.pointer_depth == 0;
    }

    pub func is_bool(self) -> bool {
        return self.name.eq_const("bool") &&
               self.pointer_depth == 0;
    }

    pub func is_bool_base(self) -> bool {
        return self.name.eq_const("bool");
    }

    pub func is_integer(self) -> bool {
        return self.pointer_depth == 0 && self.is_integer_base();
    }

    pub func is_integer_base(self) -> bool {
        return self.name.eq_const("i8") ||
               self.name.eq_const("i16") ||
               self.name.eq_const("i32") ||
               self.name.eq_const("i64") ||
               self.name.eq_const("u8") ||
               self.name.eq_const("u16") ||
               self.name.eq_const("u32") ||
               self.name.eq_const("u64") ||
               self.is_enum;
    }

    pub func is_unsigned(self) -> bool {
        return self.pointer_depth == 0 && (
            self.name.eq_const("u8") ||
            self.name.eq_const("u16") ||
            self.name.eq_const("u32") ||
            self.name.eq_const("u64")
        );
    }

    pub func is_float(self) -> bool {
        return self.pointer_depth == 0 && (
            self.name.eq_const("f32") ||
            self.name.eq_const("f64")
        );
    }

    pub func can_bitwise_calculate(self) -> bool {
        return self.pointer_depth == 0 &&
               (self.is_integer() || self.is_bool());
    }

    pub func is_float_base(self) -> bool {
        return self.name.eq_const("f32") ||
               self.name.eq_const("f64");
    }

    pub func is_function(self) -> bool {
        return self.m_info.flag_is_normal ||
               self.m_info.flag_is_static ||
               self.is_global_func;
    }

    pub func is_default_match(self) -> bool {
        return self.name.eq_const("<match-default>");
    }

    pub func error_type() -> type {
        return type::instance("<error>", "");
    }

    // return type of assignment must be <restrict>
    pub func restrict_type() -> type {
        return type::instance("<restrict>", "");
    }

    // default match type
    pub func default_match_type() -> type {
        return type::instance("<match-default>", "");
    }

    // empty array type
    pub func empty_array_type() -> type {
        var res = type::instance("<empty-array>", "");
        res.is_array = true;
        res.array_length = 0;
        return res;
    }

    pub func const_str_literal_type() -> type {
        var res = type::instance("i8", "");
        res.pointer_depth = 1;
        res.is_const = true;
        return res;
    }

    pub func void_type() -> type {
        return type::instance("void", "");
    }

    pub func bool_type() -> type {
        return type::instance("bool", "");
    }

    pub func i8_type(pointer_depth: i64) -> type {
        var res = type::instance("i8", "");
        res.pointer_depth = pointer_depth;
        return res;
    }

    pub func i16_type() -> type {
        return type::instance("i16", "");
    }

    pub func i32_type() -> type {
        return type::instance("i32", "");
    }

    pub func i64_type() -> type {
        return type::instance("i64", "");
    }

    pub func u8_type(pointer_depth: i64) -> type {
        var res = type::instance("u8", "");
        res.pointer_depth = pointer_depth;
        return res;
    }

    pub func u16_type() -> type {
        return type::instance("u16", "");
    }

    pub func u32_type() -> type {
        return type::instance("u32", "");
    }

    pub func u64_type() -> type {
        return type::instance("u64", "");
    }

    pub func f32_type() -> type {
        return type::instance("f32", "");
    }

    pub func f64_type() -> type {
        return type::instance("f64", "");
    }
}

impl type {
    pub func dump(self, out: io&, pkg: package*) {
        out.light_orange();
        // print module path
        if (pkg != nil && pkg->has_file(self.loc_file)) {
            var module = pkg->get_module_name(self.loc_file);
            out.out(module.c_str).out("::");
        }
        // print type name
        out.out(self.name.c_str).reset();
        // print generic arguments
        if (self.generics.size > 0) {
            out.light_cyan().out("<").reset();
            foreach (var i; self.generics) {
                i.get().dump(out, pkg);
                if (i.index() != self.generics.size - 1) {
                    out.out(",");
                }
            }
            out.light_cyan().out(">").reset();
        }
        // print pointer depth
        out.light_orange();
        for (var i = 0; i < self.pointer_depth; i += 1) {
            out.out("*");
        }
        if (self.is_reference) {
            out.out("&");
        }
        out.reset();
    }

    // type name with generic info, without pointer info, without module info
    // for example:
    //   in file src/example.colgm:
    //     struct foo<T> with T = i32
    // will return "foo<i32>"
    pub func generic_name(self, pkg: package*) -> str {
        if (self.generics.empty()) {
            return self.name.clone();
        }

        var res = str::from(self.name.c_str);
        res.append_char('<');
        foreach (var i; self.generics) {
            // should use full path name with pointer info
            // for generic arguments
            // also, full path name will generate generic arguments recursively
            var generic_arg_name = i.get().full_path_name_with_pointer(pkg);
            defer generic_arg_name.delete();

            res.append(generic_arg_name.c_str);
            if (i.index() != self.generics.size - 1) {
                res.append_char(',');
            }
        }
        res.append_char('>');
        return res;
    }

    pub func generic_depth(self) -> i64 {
        if (self.generics.empty()) {
            return 0;
        }
        var result = 1;
        var max_depth = 0;
        foreach (var i; self.generics) {
            var depth = i.get().generic_depth();
            if (depth > max_depth) {
                max_depth = depth;
            }
        }
        return result + max_depth;
    }

    // full path name without pointer info
    // for example:
    //   in file src/example.colgm:
    //     foo<T>** with T = i32
    // will return "example::foo<i32>"
    pub func full_path_name(self, pkg: package*) -> str {
        var res = str::instance();
        if (pkg != nil && pkg->has_file(self.loc_file)) {
            res.append_str(pkg->get_module_name(self.loc_file));
            res.append("::");
        }

        var generic_name = self.generic_name(pkg);
        defer generic_name.delete();
        res.append_str(generic_name);
        return res;
    }

    // full path name with pointer info
    // for example:
    //   in file src/example.colgm:
    //     foo<T>** with T = i32
    // will return "example::foo<i32>**"
    pub func full_path_name_with_pointer(self, pkg: package*) -> str {
        var res = self.full_path_name(pkg);

        for (var i = 0; i < self.pointer_depth; i += 1) {
            res.append_char('*');
        }
        if (self.is_reference) {
            res.append_char('&');
        }
        return res;
    }

    pub func llvm_type_name(self, pkg: package*) -> str {
        var res = self.full_path_name(pkg);

        for (var i = 0; i < self.pointer_depth; i += 1) {
            res.append_char('*');
        }
        if (self.is_reference) {
            res.append_char('*');
        }
        return res;
    }

    pub func array_type_full_name(self, pkg: package*) -> str {
        if (!self.is_array) {
            return self.full_path_name_with_pointer(pkg);
        }

        var res = str::from("[");
        res.append_u64(self.array_length);
        res.append(" x ");
        if (pkg != nil && pkg->has_file(self.loc_file)) {
            res.append_str(pkg->get_module_name(self.loc_file));
            res.append("::");
        }
        res.append_str(self.name);
        if (self.generics.size > 0) {
            res.append_char('<');
            foreach (var i; self.generics) {
                var t_fpn = i.get().full_path_name_with_pointer(pkg);
                defer t_fpn.delete();

                res.append(t_fpn.c_str);
                if (i.index() != self.generics.size - 1) {
                    res.append_char(',');
                }
            }
            res.append_char('>');
        }
        for (var i = 0; i < self.pointer_depth - 1; i += 1) {
            res.append_char('*');
        }
        res.append("]");
        return res;
    }
}
