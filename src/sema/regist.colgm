use err::report::{ report };
use err::span::{ span };

use std::panic::{ panic, assert };
use std::io::{ io };
use std::str::{ str };
use std::libc::{ free };
use std::fs::{ fs };
use std::pair::{ pair };
use std::set::{ hashset };
use std::map::{ hashmap };
use std::vec::{ vec };
use std::queue::{ queue };
use std::math::{ isinf, isnan, floor };

use util::package::{ package, p_status };
use util::cli::{ cli_option };
use util::timestamp::{ maketimestamp };
use util::to_num::{ to_f64 };

use ast::ast::*;
use parse::lexer::{ lexer };
use parse::parser::{ parser };

use sema::symbol_info::{ symbol_kind, symbol_info };
use sema::enumerate::{ colgm_enum };
use sema::structure::{ colgm_struct };
use sema::tagged_union::{ colgm_tagged_union };
use sema::function::{ colgm_func };
use sema::module::{ colgm_module };
use sema::context::{ sema_context };
use sema::primitive::{ colgm_primitive };
use sema::type::{ type };
use sema::generic_visitor::{ generic_visitor };
use sema::type_resolve::{ type_resolve };
use sema::sema::{ sema };

use mir::context::{ mir_context };
use mir::ast2mir::{ ast2mir };

pub struct regist_pass {
    err: report*,
    pkg: package*,
    root: root*,
    ctx: sema_context*,
    co: cli_option*,
    tr: type_resolve,
    gnv: generic_visitor,

    mctx: mir_context*
}

impl regist_pass {
	pub func instance(err: report*,
                      pkg: package*,
                      ctx: sema_context*,
                      co: cli_option*,
                      mctx: mir_context*) -> regist_pass {
		return regist_pass {
            err: err,
            pkg: pkg,
            root: nil,
            ctx: ctx,
            co: co,
            tr: type_resolve::instance(err, ctx, pkg),
            gnv: generic_visitor::instance(err, ctx, pkg, co),
            mctx: mctx
        };
	}

    pub func delete(self) {
        self.gnv.delete();
    }
}

impl regist_pass {
    func import_all(self, dm: colgm_module*) {
        foreach (var i; dm->enums) {
            if (!i.value().is_public) {
                continue;
            }
            var info = symbol_info::instance(
                symbol_kind::enum_kind,
                dm->file_name.c_str,
                i.value().is_public
            );
            defer info.delete();

            self.ctx->global_symbol()->insert(i.value().name, info);
        }
        foreach (var i; dm->structs) {
            if (!i.value().is_public) {
                continue;
            }
            var info = symbol_info::instance(
                symbol_kind::struct_kind,
                dm->file_name.c_str,
                i.value().is_public
            );
            defer info.delete();

            self.ctx->global_symbol()->insert(i.value().name, info);
        }
        foreach (var i; dm->tagged_unions) {
            if (!i.value().is_public) {
                continue;
            }
            var info = symbol_info::instance(
                symbol_kind::tagged_union_kind,
                dm->file_name.c_str,
                i.value().is_public
            );
            defer info.delete();

            self.ctx->global_symbol()->insert(i.value().name, info);
        }
        foreach (var i; dm->functions) {
            if (!i.value().is_public) {
                continue;
            }
            var info = symbol_info::instance(
                symbol_kind::func_kind,
                dm->file_name.c_str,
                i.value().is_public
            );
            defer info.delete();

            self.ctx->global_symbol()->insert(i.value().name, info);
        }
        foreach (var i; dm->generic_structs) {
            if (!i.value().is_public) {
                continue;
            }
            var name: str& = i.value().name;
            var info = symbol_info::instance(
                symbol_kind::struct_kind,
                dm->file_name.c_str,
                i.value().is_public
            );
            defer info.delete();

            self.ctx->global_symbol()->insert(name, info);
            self.ctx->generic_symbol()->insert(name, info);
        }
        foreach (var i; dm->generic_functions) {
            if (!i.value().is_public) {
                continue;
            }
            var name: str& = i.value().name;
            var info = symbol_info::instance(
                symbol_kind::func_kind,
                dm->file_name.c_str,
                i.value().is_public
            );
            defer info.delete();

            self.ctx->global_symbol()->insert(name, info);
            self.ctx->generic_symbol()->insert(name, info);
        }
    }

    func import_specified(self, node: ast_use_stmt*, dm: colgm_module*, path: str*) {
        foreach (var i; node->import_symbol) {
            var name_node = i.get() => ast_identifier*;
            var name = name_node->content.__ptr__();

            var is_public = false;
            if (dm->enums.has(name)) {
                is_public = dm->enums.get(name)->is_public;
            } else if (dm->structs.has(name)) {
                is_public = dm->structs.get(name)->is_public;
            } else if (dm->tagged_unions.has(name)) {
                is_public = dm->tagged_unions.get(name)->is_public;
            } else if (dm->functions.has(name)) {
                is_public = dm->functions.get(name)->is_public;
            } else if (dm->generic_structs.has(name)) {
                is_public = dm->generic_structs.get(name)->is_public;
            } else if (dm->generic_functions.has(name)) {
                is_public = dm->generic_functions.get(name)->is_public;
            } else {
                var info = str::from("cannot find symbol \"");
                info.append_str(name[0]);
                info.append("\" in module \"");
                info.append_str(path[0]);
                info.append("\"");
                defer info.delete();

                self.err->error(name_node->base.location.__ptr__(), info.c_str);
                continue;
            }

            if (!is_public) {
                var info = str::from("cannot import private symbol \"");
                info.append_str(name[0]);
                info.append("\"");
                defer info.delete();

                self.err->error(name_node->base.location.__ptr__(), info.c_str);                
                continue;
            }

            var sym_info = symbol_info::instance(
                symbol_kind::error_kind, // will replace later
                dm->file_name.c_str,
                true
            );
            defer sym_info.delete();

            if (dm->enums.has(name)) {
                sym_info.kind = symbol_kind::enum_kind;
                self.ctx->global_symbol()->insert(name[0], sym_info);
            } else if (dm->structs.has(name)) {
                sym_info.kind = symbol_kind::struct_kind;
                self.ctx->global_symbol()->insert(name[0], sym_info);
            } else if (dm->tagged_unions.has(name)) {
                sym_info.kind = symbol_kind::tagged_union_kind;
                self.ctx->global_symbol()->insert(name[0], sym_info);
            } else if (dm->functions.has(name)) {
                sym_info.kind = symbol_kind::func_kind;
                self.ctx->global_symbol()->insert(name[0], sym_info);
            } else if (dm->generic_structs.has(name)) {
                sym_info.kind = symbol_kind::struct_kind;
                self.ctx->global_symbol()->insert(name[0], sym_info);
                self.ctx->generic_symbol()->insert(name[0], sym_info);
            } else if (dm->generic_functions.has(name)) {
                sym_info.kind = symbol_kind::func_kind;
                self.ctx->global_symbol()->insert(name[0], sym_info);
                self.ctx->generic_symbol()->insert(name[0], sym_info);
            }
        }
    }

    func import_from_module(self, path: str&, node: ast_use_stmt*) {
        if (!self.ctx->has_domain(path.__ptr__())) {
            var info = str::from("module \"");
            info.append_str(path);
            info.append("\" not found,");
            info.append(" may due to compilation failure or circle dependency");
            defer info.delete();

            self.err->error(
                node->base.location.__ptr__(),
                info.c_str
            );
            return;
        }
        var dm = self.ctx->get_domain(path.__ptr__());
        if (node->import_symbol.empty()) {
            self.import_all(dm);
        } else {
            self.import_specified(node, dm, path.__ptr__());
        }
    }

    func compile_module(self, name: str&, path: str&) -> bool {
        var ts = maketimestamp();
        ts.stamp();

        // change package status
        var info = self.pkg->get_package_info(name);
        info->status = p_status::analysing;

        var par = parser::instance(self.err, self.co);
        var rp = regist_pass::instance(
            self.err,
            self.pkg,
            self.ctx,
            self.co,
            self.mctx
        );
        var semantic = sema::instance(self.err, self.pkg, self.ctx, self.co);
        var ast2mir_worker = ast2mir::instance(
            self.err,
            self.ctx,
            self.pkg,
            self.mctx
        );
        defer {
            par.delete();
            rp.delete();
            semantic.delete();
            ast2mir_worker.delete();
        }

        par.parse(path.c_str, self.co->VIEW_DEFER_REPLACE);
        if (self.err->error_count > 0) {
            return false;
        }

        rp.run(par.root);
        if (self.err->error_count > 0) {
            return false;
        }

        semantic.analyse(par.root);
        if (self.err->error_count > 0) {
            return false;
        }

        ast2mir_worker.generate(par.root);

        info->status = p_status::analysed;
        if (self.co->VERBOSE) {
            var sema_duration = ts.elapsed_msec();
            io::stdout().green().out("  SEMANTIC ").reset();
            io::stdout().out("Finish module ");
            io::stdout().cyan().out("<").out(name.c_str).out("> ").reset();
            if (sema_duration < 1000.0) {
                io::stdout().out_f64(ts.elapsed_msec()).out(" ms\n");
            } else {
                io::stdout().out_f64(ts.elapsed_msec() / 1000.0).out(" s\n");
            }
        }

        // ctx's this file maybe over-written, set it back
        self.ctx->this_file.clear();
        self.ctx->this_file.append(self.root->base.location.file.c_str);
        return true;
    }

    func scan_single_import(self, node: ast_use_stmt*) {
        // name like: mod::foo::bar
        var expect_name = str::instance();
        defer expect_name.delete();
        // path like: mod/foo/bar.colgm
        var expect_path = str::from(self.pkg->library_path.c_str);
        defer expect_path.delete();

        // expect file path init with given library path
        while (expect_path.endswith("/")) {
            expect_path.pop_back();
        }

        // generate expect path
        foreach (var i; node->module_path) {
            var name = i.get();
            if (!name->is(ast_kind::ast_identifier)) {
                self.err->error(name->location.__ptr__(), "invalid module path");
                return;
            }
            var real_node = name => ast_identifier*;
            if (!expect_name.empty()) {
                expect_name.append("::");
            }
            if (!expect_path.empty()) {
                expect_path.append_char('/');
            }
            expect_name.append(real_node->content.c_str);
            expect_path.append(real_node->content.c_str);
        }
        // generate expect path extention
        expect_path.append(".colgm");

        // check if expect path exists
        if (!fs::exists(expect_path.c_str)) {
            var info = str::from("module \"");
            info.append(expect_name.c_str);
            info.append("\" not found, \"");
            info.append(expect_path.c_str);
            info.append("\" does not exist");
            defer info.delete();

            self.err->error(node->base.location.__ptr__(), info.c_str);
            return;
        }

        self.pkg->insert(expect_name, expect_path);

        if (self.pkg->get_status(expect_name) == p_status::not_used &&
            !self.compile_module(expect_name, expect_path)) {
            // failed to compile, skip importing this module
            return;
        }

        self.import_from_module(expect_path, node);
    }

    func scan_imports(self) {
        foreach (var i; self.root->imports) {
            var node = i.get();
            if (!node->is(ast_kind::ast_use_stmt)) {
                self.err->error(node->location.__ptr__(), "invalid import");
                return;
            }
            self.scan_single_import(node => ast_use_stmt*);
        }
    }
}

impl regist_pass {
    func load_primitive_into_global_symbol(self) {
        var prim_table = [
            "i64", "i32", "i16", "i8",
            "u64", "u32", "u16", "u8",
            "f64", "f32", "bool"
        ];

        for (var i = 0; i < 11; i += 1) {
            var name = str::from(prim_table[i]);
            var info = symbol_info::instance(
                symbol_kind::basic_kind,
                "",
                true // must be public
            );
            defer {
                name.delete();
                info.delete();
            }

            self.ctx->global_symbol()->insert(name, info);
        }
    }

    func regist_primitives(self) {
        self.load_primitive_into_global_symbol();
        var gt = self.ctx->global;
        if (gt->primitives.size != 0) {
            return;
        }

        var prim_table = [
            "i64", "i32", "i16", "i8",
            "u64", "u32", "u16", "u8",
            "f64", "f32", "bool"
        ];

        for (var i = 0; i < 11; i += 1) {
            var prim_name = str::from(prim_table[i]);
            var empty_prim = colgm_primitive::instance();
            empty_prim.name.append(prim_table[i]);
            defer {
                prim_name.delete();
                empty_prim.delete();
            }

            gt->primitives.insert(prim_name, empty_prim);
            self.regist_primitive_size_method(gt->primitives.get(prim_name.__ptr__()));
            self.regist_primitive_ptr_method(gt->primitives.get(prim_name.__ptr__()));
        }
    }

    func regist_primitive_size_method(self, pt: colgm_primitive*) {
        var name = str::from("__size__");
        var loc = span::null();
        var ret = type::u64_type();
        var func_info = colgm_func::instance(name, loc, ret);
        func_info.is_public = true;
        defer {
            func_info.delete();
            name.delete();
            loc.delete();
            ret.delete();
        }

        pt->static_method.insert(name, func_info);
    }

    func regist_primitive_ptr_method(self, pt: colgm_primitive*) {
        var name = str::from("__ptr__");
        var self_name = str::from("self");
        var self_type = type::instance(pt->name.c_str, "");
        self_type.is_reference = true;
        var loc = span::null();
        var ret = type::instance(pt->name.c_str, "");
        ret.pointer_depth = 1;
        defer {
            name.delete();
            self_name.delete();
            self_type.delete();
            loc.delete();
            ret.delete();
        }

        var func_info = colgm_func::instance(name, loc, ret);
        func_info.is_public = true;
        func_info.param_name.push(self_name.__ptr__());
        func_info.param_type.push(self_type.__ptr__());
        func_info.unordered_params.insert(self_name, ret);
        defer func_info.delete();

        pt->method.insert(name, func_info);
    }

    func regist_builtin_funcs(self, root: root*) {
        var time_func_name = str::from("__time__");
        var null_loc = span::null();
        var ret_type = type::const_str_literal_type();
        defer {
            time_func_name.delete();
            null_loc.delete();
            ret_type.delete();
        }

        var func_info = colgm_func::instance(time_func_name, null_loc, ret_type);
        func_info.is_extern = true;
        defer func_info.delete();

        var dm = self.ctx->get_domain(root->base.location.file.__ptr__());
        dm->functions.insert(time_func_name, func_info);

        var sym_info = symbol_info::instance(
            symbol_kind::func_kind,
            root->base.location.file.c_str,
            true // true for selves' domain
        );
        defer sym_info.delete();

        self.ctx->global_symbol()->insert(time_func_name, sym_info);        
    }
}

impl regist_pass {
    func check_is_valid_enum_value(self, node: ast_number_literal*) -> bool {
        var literal = node->literal.__ptr__();
        if (literal->find('.') != str::npos() ||
            literal->find('e') != str::npos()) {
            return false;
        }
        var num = to_f64(literal->c_str);
        // inf and nan is definitely floating point
        if (isinf(num) || isnan(num)) {
            return false;
        }
        if (num - floor(num) != 0.0) {
            return false;
        }
        return true;
    }

    func generate_enum_member(self, e: colgm_enum*, node: ast_enum_decl*) {
        if (node->is_public) {
            e->is_public = true;
        }

        var has_specified_value = false;
        var has_non_specified_value = false;
        foreach (var i; node->members) {
            var n = i.get();
            if (!n->is(ast_kind::ast_enum_member)) {
                self.err->error(n->location.__ptr__(),
                    "invalid ast node, expect enum member"
                );
                return;
            }
            var n_ast = n => ast_enum_member*;
            if (n_ast->value != nil) {
                has_specified_value = true;
            } else {
                has_non_specified_value = true;
            }
        }

        // specified value is required for all members now
        if (has_specified_value && has_non_specified_value) {
            self.err->error(node->base.location.__ptr__(),
                "should use specified number for all members"
            );
            return;
        }

        foreach (var i; node->members) {
            var n = i.get() => ast_enum_member*;
            if (n->value == nil) {
                continue;
            }
            if (!self.check_is_valid_enum_value(n->value)) {
                self.err->report_invalid_enum_value(
                    n->value->base.location.__ptr__(),
                    n->name->content.c_str
                );
            }
        }
        
        foreach (var i; node->members) {
            var n_ast = i.get()=> ast_enum_member*;
            var value = i.index() => i64;
            var member_name: str& = n_ast->name->content;
            if (n_ast->value != nil) {
                var nl = n_ast->value => ast_number_literal*;
                value = to_f64(nl->literal.c_str) => i64;
            }
            e->ordered_member.push(member_name.__ptr__());
            e->members.insert(member_name, value);
        }
    }

    func regist_single_enum(self, node: ast_enum_decl*) {
        var name: str& = node->name;
        if (self.ctx->global_symbol()->has(name.__ptr__())) {
            var info = str::from("enum \"");
            defer info.delete();
            info.append_str(name);
            info.append("\" conflicts with exist symbol");

            self.err->error(node->base.location.__ptr__(), info.c_str);
            return;
        }

        // allocate enum info
        var enum_info = colgm_enum::new(node->name, node->base.location);
        self.generate_enum_member(enum_info, node);
        // insert to domain
        var dm = self.ctx->get_domain(node->base.location.file.__ptr__());
        dm->enums.insert(name, enum_info[0]);
        enum_info->delete();
        free(enum_info => i8*);

        var sym_info = symbol_info::instance(
            symbol_kind::enum_kind,
            node->base.location.file.c_str,
            true // true for selves' domain
        );
        defer sym_info.delete();

        self.ctx->global_symbol()->insert(name, sym_info);        
    }

    func scan_enums(self) {
        foreach (var i; self.root->decls) {
            var node = i.get();
            if (!node->is(ast_kind::ast_enum_decl)) {
                continue;
            }
            var enum_node = node => ast_enum_decl*;
            self.regist_single_enum(enum_node);
        }
    }
}

impl regist_pass {
    func generate_function_params(self,
                                  f: colgm_func*,
                                  node: ast_func_decl*,
                                  is_global_func: bool) {
        if (node->is_public) {
            f->is_public = true;
        }
        if (node->is_extern) {
            f->is_extern = true;
        }

        var param_loc_map = hashmap<str, span>::instance();
        defer param_loc_map.delete();

        var v = node->params->params.__ptr__();
        for (var i: u64 = 0; i < v->size; i += 1) {
            var n = v->get(i);
            if (!n->is(ast_kind::ast_param)) {
                self.err->error(n->location.__ptr__(),
                    "invalid ast node, expect param"
                );
                continue;
            }
            var n_ast = n => ast_param*;
            var param_name: str& = n_ast->name->content;

            // check self param
            if (param_name.eq_const("self") && i != 0) {
                self.err->error(n->location.__ptr__(),
                    "\"self\" must be the first param"
                );
                continue;
            }
            if (param_name.eq_const("self") && i == 0 && is_global_func) {
                self.err->error(n->location.__ptr__(),
                    "global function cannot use \"self\" as parameter"
                );
                continue;
            }

            if (f->unordered_params.has(param_name.__ptr__())) {
                self.err->report_conflict_param(
                    n->location.__ptr__(),
                    param_loc_map.get(param_name.__ptr__()),
                    param_name.c_str
                );
                continue;
            }

            if (n_ast->type == nil) {
                // should be unreachable
                var param_type = type::error_type();
                defer param_type.delete();

                f->param_name.push(param_name.__ptr__());
                f->param_type.push(param_type.__ptr__());
                f->param_location.insert(param_name, n->location);
                f->unordered_params.insert(param_name, param_type);                
                param_loc_map.insert(param_name, n_ast->base.location);
            } else {
                var param_type = self.tr.resolve(n_ast->type);
                defer param_type.delete();

                f->param_name.push(param_name.__ptr__());
                f->param_type.push(param_type.__ptr__());
                f->param_location.insert(param_name, n->location);
                f->unordered_params.insert(param_name, param_type);
                param_loc_map.insert(param_name, n_ast->base.location);
            }
        }
    }

    func regist_single_global_func(self, node: ast_func_decl*) {
        var name: str& = node->name;
        if (self.ctx->global_symbol()->has(name.__ptr__())) {
            var info = str::from("\"");
            defer info.delete();
            info.append_str(name);
            info.append("\" conflicts with exist symbol");

            self.err->error(node->base.location.__ptr__(), info.c_str);
            return;
        }

        if (node->generic_types != nil) {
            self.ctx->generics.clear();
            var gtv = node->generic_types->types.__ptr__();
            for (var i: u64 = 0; i < gtv->size; i += 1) {
                var gt = gtv->get(i);
                if (!gt->is(ast_kind::ast_type_def)) {
                    self.err->error(gt->location.__ptr__(),
                        "invalid ast node, expect type def"
                    );
                    continue;
                }
                var n_td = gt => ast_type_def*;
                self.ctx->generics.insert(n_td->name->content.__ptr__());
            }
        }

        // allocate func info
        var func_info: colgm_func* = nil;
        if (node->return_type == nil) {
            var ret_type = type::void_type();
            defer ret_type.delete();

            func_info = colgm_func::new(
                node->name,
                node->base.location,
                ret_type
            );
        } else {
            var ret_type = self.tr.resolve(node->return_type);
            defer ret_type.delete();

            func_info = colgm_func::new(
                node->name,
                node->base.location,
                ret_type
            );
        }

        if (node->generic_types != nil) {
            var gtv = node->generic_types->types.__ptr__();
            for (var i: u64 = 0; i < gtv->size; i += 1) {
                var gt = gtv->get(i);
                if (!gt->is(ast_kind::ast_type_def)) {
                    self.err->error(gt->location.__ptr__(),
                        "invalid ast node, expect type def"
                    );
                    continue;
                }
                var n_td = gt => ast_type_def*;
                func_info->generic_template.push(n_td->name->content.__ptr__());
            }
            func_info->generic_func_decl = node->copy();
        }

        self.generate_function_params(func_info, node, true);

        // insert to domain
        var dm = self.ctx->get_domain(node->base.location.file.__ptr__());
        if (node->generic_types != nil) {
            dm->generic_functions.insert(name, func_info[0]);
        } else {
            dm->functions.insert(name, func_info[0]);
        }
        func_info->delete();
        free(func_info => i8*);

        var sym_info = symbol_info::instance(
            symbol_kind::func_kind,
            node->base.location.file.c_str,
            true // true for selves' domain
        );
        defer sym_info.delete();

        self.ctx->global_symbol()->insert(name, sym_info);
        if (node->generic_types != nil) {
            self.ctx->generic_symbol()->insert(name, sym_info);
        }
        self.ctx->generics.clear();
    }

    func scan_global_funcs(self) {
        foreach (var i; self.root->decls) {
            var node = i.get();
            if (!node->is(ast_kind::ast_func_decl)) {
                continue;
            }
            var func_node = node => ast_func_decl*;
            self.regist_single_global_func(func_node);
        }
    }
}

impl regist_pass {
    func regist_single_struct_field(self, node: ast_struct_decl*) {
        var name: str& = node->name;
        if (!self.ctx->global_symbol()->has(name.__ptr__())) {
            var info = str::from("cannot find symbol \"");
            defer info.delete();
            info.append_str(name);
            info.append("\"");

            self.err->error(node->base.location.__ptr__(), info.c_str);
            return;
        }

        if (node->generic_types != nil) {
            self.ctx->generics.clear();
            var gtv = node->generic_types->types.__ptr__();
            for (var i: u64 = 0; i < gtv->size; i += 1) {
                var gt = gtv->get(i);
                if (!gt->is(ast_kind::ast_type_def)) {
                    self.err->error(gt->location.__ptr__(),
                        "invalid ast node, expect type def"
                    );
                    continue;
                }
                var n_td = gt => ast_type_def*;
                self.ctx->generics.insert(n_td->name->content.__ptr__());
            }
        }

        var dm = self.ctx->get_domain(node->base.location.file.__ptr__());
        if (node->generic_types == nil && !dm->structs.has(name.__ptr__())) {
            return;
        }
        if (node->generic_types != nil && !dm->generic_structs.has(name.__ptr__())) {
            return;
        }
        var struct_info: colgm_struct* = nil;
        if (node->generic_types == nil) {
            struct_info = dm->structs.get(name.__ptr__());
        } else {
            struct_info = dm->generic_structs.get(name.__ptr__());
            var gtv = node->generic_types->types.__ptr__();
            for (var i: u64 = 0; i < gtv->size; i += 1) {
                var gt = gtv->get(i);
                if (!gt->is(ast_kind::ast_type_def)) {
                    self.err->error(gt->location.__ptr__(),
                        "invalid ast node, expect type def"
                    );
                    continue;
                }
                var n_td = gt => ast_type_def*;
                struct_info->generic_template.push(n_td->name->content.__ptr__());
            }
            struct_info->generic_struct_decl = node->copy();
        }

        foreach (var i; node->fields) {
            var fld = i.get();
            var fld_name: str& = fld->name->content;
            if (struct_info->fields.has(fld_name.__ptr__())) {
                var info = str::from("field \"");
                defer info.delete();
                info.append_str(fld_name);
                info.append("\" conflicts with exist field");

                self.err->error(node->base.location.__ptr__(), info.c_str);
                continue;
            }
            var sym_type = self.tr.resolve(fld->type);
            defer sym_type.delete();

            struct_info->fields.insert(fld_name, sym_type);
            struct_info->ordered_fields.push(fld_name.__ptr__());
            struct_info->fields_span.insert(fld_name, fld->base.location);            
        }

        var struct_self_type = type::instance(name.c_str, node->base.location.file.c_str);
        defer struct_self_type.delete();

        if (node->generic_types != nil) {
            foreach (var i; node->generic_types->types) {
                var gt = i.get();
                var ty = self.tr.resolve(gt => ast_type_def*);
                defer ty.delete();

                struct_self_type.generics.push(ty.__ptr__());                
            }
        }

        self.regist_struct_size_method(struct_info);
        self.regist_struct_alloc_method(struct_info, struct_self_type.__ptr__());
        self.regist_struct_ptr_method(struct_info, struct_self_type.__ptr__());
        self.ctx->generics.clear();        
    }

    func regist_struct_size_method(self, struct_info: colgm_struct*) {
        var name = str::from("__size__");
        var ret = type::u64_type();
        defer {
            name.delete();
            ret.delete();
        }

        var func_info = colgm_func::instance(name, struct_info->location, ret);
        func_info.is_public = true;
        defer func_info.delete();

        struct_info->static_method.insert(name, func_info);
    }

    func regist_struct_alloc_method(self,
                                    struct_info: colgm_struct*,
                                    struct_self_type: type*) {
        var name = str::from("__alloc__");
        var ret = struct_self_type->pointer_copy();
        defer {
            name.delete();
            ret.delete();
        }

        var func_info = colgm_func::instance(name, struct_info->location, ret);
        func_info.is_public = true;
        defer func_info.delete();

        struct_info->static_method.insert(name, func_info);
    }

    func regist_struct_ptr_method(self,
                                  struct_info: colgm_struct*,
                                  struct_self_type: type*) {
        var name = str::from("__ptr__");
        var self_name = str::from("self");
        var self_type = struct_self_type->clone();
        self_type.is_reference = true;
        var ret = struct_self_type->pointer_copy();
        defer {
            name.delete();
            self_name.delete();
            self_type.delete();
            ret.delete();
        }

        var func_info = colgm_func::instance(name, struct_info->location, ret);
        func_info.is_public = true;
        func_info.param_name.push(self_name.__ptr__());
        func_info.param_type.push(self_type.__ptr__());
        func_info.unordered_params.insert(self_name, ret);
        defer func_info.delete();

        struct_info->method.insert(name, func_info);
    }

    func regist_single_struct_symbol(self, node: ast_struct_decl*) {
        var name: str& = node->name;
        if (self.ctx->global_symbol()->has(name.__ptr__())) {
            var info = str::from("struct \"");
            defer info.delete();
            info.append_str(name);
            info.append("\" conflicts with exist symbol");

            self.err->error(node->base.location.__ptr__(), info.c_str);
            return;
        }

        // allocate struct info
        var struct_info = colgm_struct::new(node->name, node->base.location);
        if (node->is_extern) {
            struct_info->is_extern = true;
        }
        if (node->is_public) {
            struct_info->is_public = true;
        }
        // insert to domain
        var dm = self.ctx->get_domain(node->base.location.file.__ptr__());
        if (node->generic_types != nil) {
            dm->generic_structs.insert(name, struct_info[0]);
        } else {
            dm->structs.insert(name, struct_info[0]);
        }
        struct_info->delete();
        free(struct_info => i8*);

        var sym_info = symbol_info::instance(
            symbol_kind::struct_kind,
            node->base.location.file.c_str,
            true // true for selves's domain
        );
        defer sym_info.delete();

        self.ctx->global_symbol()->insert(name, sym_info);
        if (node->generic_types != nil) {
            self.ctx->generic_symbol()->insert(name, sym_info);
        }
    }

    func check_ref_enum(self, node: ast_tagged_union_decl*, un: colgm_tagged_union*) {
        if (node->ref_enum_name.empty()) {
            return;
        }

        if (!self.ctx->global_symbol()->has(node->ref_enum_name.__ptr__())) {
            var info = str::from("enum \"");
            defer info.delete();
            info.append_str(node->ref_enum_name);
            info.append("\" not found, make sure it is defined or imported");

            self.err->error(node->base.location.__ptr__(), info.c_str);
            return;
        }

        var enum_info = self.ctx->global_symbol()->get(node->ref_enum_name.__ptr__());
        if (enum_info->kind != symbol_kind::enum_kind) {
            var info = str::from("\"");
            defer info.delete();
            info.append_str(node->ref_enum_name);
            info.append("\" is not enum");

            self.err->error(node->base.location.__ptr__(), info.c_str);
            return;
        }

        var ty = type::instance(node->ref_enum_name.c_str, enum_info->loc_file.c_str);
        ty.is_enum = true;
        defer ty.delete();

        un->ref_enum_type.reset_with(ty.__ptr__());

        var dm = self.ctx->get_domain(enum_info->loc_file.__ptr__());
        var em = dm->enums.get(node->ref_enum_name.__ptr__());
        foreach (var i; node->members) {
            if (em->members.has(i.get()->name->content.__ptr__())) {
                continue;
            }
            var info = str::from("member \"");
            defer info.delete();
            info.append_str(i.get()->name->content);
            info.append("\" not found in enum \"");

            var full_name = ty.full_path_name(self.pkg);
            defer full_name.delete();
            info.append_str(full_name);

            info.append("\"");
            self.err->error(i.get()->base.location.__ptr__(), info.c_str);
        }
    }

    func load_tagged_union_member_map(self, node: ast_tagged_union_decl*, un: colgm_tagged_union*) {
        if (node->ref_enum_name.empty()) {
            foreach (var i; un->ordered_members) {
                un->member_int_map.insert(
                    i.get(),
                    un->member_int_map.size => i64
                );
            }
            return;
        }

        if (!self.ctx->global_symbol()->has(node->ref_enum_name.__ptr__())) {
            return;
        }

        var enum_info = self.ctx->global_symbol()->get(node->ref_enum_name.__ptr__());
        if (enum_info->kind != symbol_kind::enum_kind) {
            return;
        }

        var dm = self.ctx->get_domain(enum_info->loc_file.__ptr__());
        var em = dm->enums.get(node->ref_enum_name.__ptr__());
        foreach (var i; node->members) {
            if (em->members.has(i.get()->name->content.__ptr__())) {
                un->member_int_map.insert(
                    i.get()->name->content,
                    em->members.get(i.get()->name->content.__ptr__())
                );
                continue;
            }
        }
    }

    func regist_single_tagged_union_member(self, node: ast_tagged_union_decl*) {
        var name: str& = node->name;
        if (!self.ctx->global_symbol()->has(name.__ptr__())) {
            var info = str::from("cannot find symbol \"");
            defer info.delete();
            info.append_str(name);
            info.append("\"");

            self.err->error(node->base.location.__ptr__(), info.c_str);
            return;
        }

        var dm = self.ctx->get_domain(node->base.location.file.__ptr__());
        var union_info = dm->tagged_unions.get(name.__ptr__());

        if (node->members.empty()) {
            self.err->error(node->base.location.__ptr__(),
                "tagged union must have at least one member"
            );
            return;
        }

        var un_type = type::instance(name.c_str, node->base.location.file.c_str);
        defer un_type.delete();

        self.regist_tagged_union_size_method(union_info);
        self.regist_tagged_union_alloc_method(union_info, un_type.__ptr__());
        self.regist_tagged_union_ptr_method(union_info, un_type.__ptr__());

        foreach (var i; node->members) {
            var member = i.get();
            var member_name: str& = member->name->content;
            if (union_info->members.has(member_name.__ptr__())) {
                var info = str::from("member \"");
                defer info.delete();
                info.append_str(member_name);
                info.append("\" conflicts with exist member");

                self.err->error(node->base.location.__ptr__(), info.c_str);
                continue;
            }

            var member_type = self.tr.resolve(member->type);
            defer member_type.delete();

            union_info->members.insert(member_name, member_type);
            union_info->ordered_members.push(member_name.__ptr__());
            union_info->members_span.insert(member_name, member->base.location);
        }
        self.load_tagged_union_member_map(node, union_info);
    }

    func regist_tagged_union_size_method(self, un: colgm_tagged_union*) {
        var name = str::from("__size__");
        var ret = type::u64_type();
        defer {
            name.delete();
            ret.delete();
        }

        var func_info = colgm_func::instance(name, un->location, ret);
        func_info.is_public = true;
        defer func_info.delete();

        un->static_method.insert(name, func_info);
    }

    func regist_tagged_union_alloc_method(self,
                                          un: colgm_tagged_union*,
                                          un_type: type*) {
        var name = str::from("__alloc__");
        var ret = un_type->pointer_copy();
        defer {
            name.delete();
            ret.delete();
        }

        var func_info = colgm_func::instance(name, un->location, ret);
        func_info.is_public = true;
        defer func_info.delete();

        un->static_method.insert(name, func_info);
    }

    func regist_tagged_union_ptr_method(self,
                                        un: colgm_tagged_union*,
                                        un_type: type*) {
        var name = str::from("__ptr__");
        var self_name = str::from("self");
        var self_type = un_type->clone();
        self_type.is_reference = true;
        var ret = un_type->pointer_copy();
        defer {
            name.delete();
            self_name.delete();
            self_type.delete();
            ret.delete();
        }

        var func_info = colgm_func::instance(name, un->location, ret);
        func_info.is_public = true;
        func_info.param_name.push(self_name.__ptr__());
        func_info.param_type.push(self_type.__ptr__());
        func_info.unordered_params.insert(self_name, ret);
        defer func_info.delete();

        un->method.insert(name, func_info);
    }

    func regist_single_tagged_union_symbol(self, node: ast_tagged_union_decl*) {
        var name: str& = node->name;
        if (self.ctx->global_symbol()->has(name.__ptr__())) {
            var info = str::from("struct \"");
            defer info.delete();
            info.append_str(name);
            info.append("\" conflicts with exist symbol");

            self.err->error(node->base.location.__ptr__(), info.c_str);
            return;
        }

        // allocate struct info
        var union_info = colgm_tagged_union::instance(
            name.__ptr__(),
            node->base.location.__ptr__()
        );
        defer union_info.delete();
        if (node->is_extern) {
            union_info.is_extern = true;
        }
        if (node->is_public) {
            union_info.is_public = true;
        }
        self.check_ref_enum(node, union_info.__ptr__());

        // insert to domain
        var dm = self.ctx->get_domain(node->base.location.file.__ptr__());        
        dm->tagged_unions.insert(name, union_info);

        var sym_info = symbol_info::instance(
            symbol_kind::tagged_union_kind,
            node->base.location.file.c_str,
            true // true for selves's domain
        );
        defer sym_info.delete();

        self.ctx->global_symbol()->insert(name, sym_info);
    }

    func scan_complex_structs(self) {
        // regist symbol into symbol table first
        foreach (var i; self.root->decls) {
            var node = i.get();
            if (node->is(ast_kind::ast_struct_decl)) {
                var struct_node = node => ast_struct_decl*;
                self.regist_single_struct_symbol(struct_node);
            } else if (node->is(ast_kind::ast_tagged_union_decl)) {
                var union_node = node => ast_tagged_union_decl*;
                self.regist_single_tagged_union_symbol(union_node);
            }
        }

        // load field into struct info
        foreach (var i; self.root->decls) {
            var node = i.get();
            if (node->is(ast_kind::ast_struct_decl)) {
                var struct_node = node => ast_struct_decl*;
                self.regist_single_struct_field(struct_node);
            } else if (node->is(ast_kind::ast_tagged_union_decl)) {
                var union_node = node => ast_tagged_union_decl*;
                self.regist_single_tagged_union_member(union_node);
            }
        }

        // do self reference check
        self.check_self_reference();
    }

    func check_single_self_reference(self, name: str&) {
        var dm = self.ctx->get_domain(self.ctx->this_file.__ptr__());
        var structs = dm->structs.__ptr__();
        var tagged_unions = dm->tagged_unions.__ptr__();

        var bfs = queue<pair<str, str>>::instance();
        defer bfs.delete();

        var visited = hashset<str>::instance();
        defer visited.delete();

        var first = pair<str, str>::instance(name, name);
        defer first.delete();

        bfs.push(first.__ptr__());

        var location: span* = nil;
        if (structs->has(name.__ptr__())) {
            location = structs->get(name.__ptr__())->location.__ptr__();
        } else {
            location = tagged_unions->get(name.__ptr__())->location.__ptr__();
        }

        while (!bfs.empty()) {
            var current = bfs.front()->key.clone();
            var ref_path = bfs.front()->value.clone();
            defer current.delete();
            defer ref_path.delete();

            bfs.pop();

            if (visited.has(current.__ptr__())) {
                continue;
            } else {
                visited.insert(current.__ptr__());
            }

            if (structs->has(current.__ptr__())) {
                foreach (var f; structs->get(current.__ptr__())->fields) {
                    var fld_name = f.key();
                    var fld_type = f.value();
                    if (fld_type.is_pointer()) {
                        continue;
                    }

                    var new_ref_path = ref_path.clone();
                    defer new_ref_path.delete();
                    new_ref_path.append("::");
                    new_ref_path.append_str(fld_name);
                    new_ref_path.append(" -> ");
                    new_ref_path.append_str(fld_type.name);

                    if (fld_type.name.eq(name.__ptr__())) {
                        var info = str::from("self reference detected: ");
                        defer info.delete();
                        info.append_str(new_ref_path);

                        self.err->error(location, info.c_str);
                    } else if (structs->has(fld_type.name.__ptr__()) ||
                            tagged_unions->has(fld_type.name.__ptr__())) {
                        var new_pair = pair<str, str>::instance(
                            fld_type.name,
                            new_ref_path
                        );
                        defer new_pair.delete();

                        bfs.push(new_pair.__ptr__());
                    }
                }
            } else {
                foreach (var m; tagged_unions->get(current.__ptr__())->members) {
                    var member_name = m.key();
                    var member_type = m.value();
                    if (member_type.is_pointer()) {
                        continue;
                    }

                    var new_ref_path = ref_path.clone();
                    defer new_ref_path.delete();
                    new_ref_path.append("::");
                    new_ref_path.append_str(member_name);
                    new_ref_path.append(" -> ");
                    new_ref_path.append_str(member_type.name);

                    if (member_type.name.eq(name.__ptr__())) {
                        var info = str::from("self reference detected: ");
                        defer info.delete();
                        info.append_str(new_ref_path);

                        self.err->error(location, info.c_str);
                    } else if (structs->has(member_type.name.__ptr__()) ||
                            tagged_unions->has(member_type.name.__ptr__())) {
                        var new_pair = pair<str, str>::instance(
                            member_type.name,
                            new_ref_path
                        );
                        defer new_pair.delete();

                        bfs.push(new_pair.__ptr__());
                    }
                }
            }
        }
    }

    func check_self_reference(self) {
        var dm = self.ctx->get_domain(self.ctx->this_file.__ptr__());
        var structs = dm->structs.__ptr__();
        var tagged_unions = dm->tagged_unions.__ptr__();

        var need_check = vec<str>::instance();
        defer need_check.delete();

        foreach (var st; structs) {
            var info = st.value();
            foreach (var f; info.fields) {
                var field = f.value();
                if (!field.is_pointer() &&
                    structs->has(field.name.__ptr__())) {
                    need_check.push(st.key().__ptr__());
                    break;
                }
                if (!field.is_pointer() &&
                    tagged_unions->has(field.name.__ptr__())) {
                    need_check.push(st.key().__ptr__());
                    break;
                }
            }
        }
        foreach (var un; tagged_unions) {
            var info = un.value();
            foreach (var m; info.members) {
                var member = m.value();
                if (!member.is_pointer() &&
                    structs->has(member.name.__ptr__())) {
                    need_check.push(un.key().__ptr__());
                    break;
                }
                if (!member.is_pointer() &&
                    tagged_unions->has(member.name.__ptr__())) {
                    need_check.push(un.key().__ptr__());
                    break;
                }
            }
        }

        foreach (var s; need_check) {
            self.check_single_self_reference(s.get());
        }
    }
}

impl regist_pass {
    func is_method(self, node: ast_func_decl*) -> bool {
        var pms = node->params->params.__ptr__();
        if (pms->empty()) {
            return false;
        }

        var first_param = pms->get(0);
        if (!first_param->is(ast_kind::ast_param)) {
            return false;
        }
        var first_param_node = first_param => ast_param*;
        if (first_param_node->name->content.eq_const("self")) {
            return true;
        }
        return false;
    }

    func generate_struct_self_type_node(self,
                                        struct_info: colgm_struct*,
                                        node: ast_func_decl*) {
        var pms = node->params->params.__ptr__();
        var first_param = pms->get(0) => ast_param*;
        if (first_param->type != nil) {
            self.err->error(first_param->type->base.location.__ptr__(),
                            "\"self\" does not need type");
            return;
        }

        var tn = ast_type_def::new(first_param->base.location);
        tn->name = ast_identifier::new(first_param->base.location, struct_info->name);
        tn->is_reference = true;
        // copy generic template
        var GT = struct_info->generic_template.__ptr__();
        if (GT->size > 0) {
            tn->generic_types = ast_generic_type_list::new(first_param->base.location);
            for (var i: u64 = 0; i < GT->size; i += 1) {
                var g = GT->get(i);
                var tmp = ast_type_def::new(first_param->base.location);
                tmp->name = ast_identifier::new(first_param->base.location, g);
                tn->generic_types->types.push(tmp => ast*);
            }
        }
        first_param->type = tn;
    }

    func generate_impl_method_for_struct(self,
                                         struct_info: colgm_struct*,
                                         node: ast_func_decl*) {
        var name = node->get_monomorphic_name();
        if (struct_info->check_field_exists(name)) {
            var info = str::from("\"");
            defer info.delete();
            info.append_str(name);
            info.append("\" conflicts with exist field or method");

            self.err->error(node->base.location.__ptr__(), info.c_str);
            return;
        }

        // allocate func info
        var func_info: colgm_func* = nil;
        if (node->return_type == nil) {
            var ret_type = type::void_type();
            defer ret_type.delete();

            func_info = colgm_func::new(
                name,
                node->base.location,
                ret_type
            );
        } else {
            var ret_type = self.tr.resolve(node->return_type);
            defer ret_type.delete();

            func_info = colgm_func::new(
                name,
                node->base.location,
                ret_type
            );
        }
        defer {
            func_info->delete();
            free(func_info => i8*);
        }

        // generate self type node, after this process,
        // type node of self will not be nil
        self.generate_struct_self_type_node(struct_info, node);

        self.generate_function_params(func_info, node, false);
        struct_info->method.insert(name, func_info[0]);
    }

    func generate_impl_static_method_for_struct(self,
                                                struct_info: colgm_struct*,
                                                node: ast_func_decl*) {
        var name = node->get_monomorphic_name();
        if (struct_info->check_field_exists(name)) {
            var info = str::from("\"");
            defer info.delete();
            info.append_str(name);
            info.append("\" conflicts with exist field or method");

            self.err->error(node->base.location.__ptr__(), info.c_str);
            return;
        }

        // allocate func info
        var func_info: colgm_func* = nil;
        if (node->return_type == nil) {
            var ret_type = type::void_type();
            defer ret_type.delete();

            func_info = colgm_func::new(
                name,
                node->base.location,
                ret_type
            );
        } else {
            var ret_type = self.tr.resolve(node->return_type);
            defer ret_type.delete();

            func_info = colgm_func::new(
                name,
                node->base.location,
                ret_type
            );
        }
        defer {
            func_info->delete();
            free(func_info => i8*);
        }

        self.generate_function_params(func_info, node, false);
        struct_info->static_method.insert(name, func_info[0]);
    }

    func generate_union_self_type_node(self,
                                       union_info: colgm_tagged_union*,
                                       node: ast_func_decl*) {
        var pms = node->params->params.__ptr__();
        var first_param = pms->get(0) => ast_param*;
        if (first_param->type != nil) {
            self.err->error(first_param->type->base.location.__ptr__(),
                            "\"self\" does not need type");
            return;
        }

        var tn = ast_type_def::new(first_param->base.location);
        tn->name = ast_identifier::new(first_param->base.location, union_info->name);
        tn->is_reference = true;
        first_param->type = tn;
    }

    func generate_impl_method_for_tagged_union(self,
                                               union_info: colgm_tagged_union*,
                                               node: ast_func_decl*) {
        var name: str& = node->name;
        if (union_info->check_member_exists(name.__ptr__())) {
            var info = str::from("\"");
            defer info.delete();
            info.append_str(name);
            info.append("\" conflicts with exist member or method");

            self.err->error(node->base.location.__ptr__(), info.c_str);
            return;
        }

        // allocate func info
        var func_info: colgm_func* = nil;
        if (node->return_type == nil) {
            var ret_type = type::void_type();
            defer ret_type.delete();

            func_info = colgm_func::new(
                node->name,
                node->base.location,
                ret_type
            );
        } else {
            var ret_type = self.tr.resolve(node->return_type);
            defer ret_type.delete();

            func_info = colgm_func::new(
                node->name,
                node->base.location,
                ret_type
            );
        }
        defer {
            func_info->delete();
            free(func_info => i8*);
        }

        // generate self type node, after this process,
        // type node of self will not be nil
        self.generate_union_self_type_node(union_info, node);

        self.generate_function_params(func_info, node, false);
        union_info->method.insert(name, func_info[0]);
    }

    func generate_impl_static_method_for_tagged_union(self,
                                                      union_info: colgm_tagged_union*,
                                                      node: ast_func_decl*) {
        var name: str& = node->name;
        if (union_info->check_member_exists(name.__ptr__())) {
            var info = str::from("\"");
            defer info.delete();
            info.append_str(name);
            info.append("\" conflicts with exist member or method");

            self.err->error(node->base.location.__ptr__(), info.c_str);
            return;
        }

        // allocate func info
        var func_info: colgm_func* = nil;
        if (node->return_type == nil) {
            var ret_type = type::void_type();
            defer ret_type.delete();

            func_info = colgm_func::new(
                node->name,
                node->base.location,
                ret_type
            );
        } else {
            var ret_type = self.tr.resolve(node->return_type);
            defer ret_type.delete();

            func_info = colgm_func::new(
                node->name,
                node->base.location,
                ret_type
            );
        }
        defer {
            func_info->delete();
            free(func_info => i8*);
        }

        self.generate_function_params(func_info, node, false);
        union_info->static_method.insert(name, func_info[0]);
    }

    func regist_single_impl(self, node: ast_impl*) {
        var name = node->name.__ptr__();
        var dm = self.ctx->get_domain(node->base.location.file.__ptr__());
        if (dm->structs.has(name) || dm->generic_structs.has(name)) {
            var struct_info: colgm_struct* = nil;
            if (node->generic_types != nil) {
                struct_info = dm->generic_structs.get(name);
            } else {
                struct_info = dm->structs.get(name);
            }
            self.regist_single_impl_for_struct(node, struct_info);
            return;
        } else if (dm->tagged_unions.has(name)) {
            self.regist_single_impl_for_tagged_union(node, dm->tagged_unions.get(name));
            return;
        }

        self.err->out("cannot find struct or tagged union named \"")
                 .out(name->c_str)
                 .out("\"")
                 .emit_err(node->base.location.__ptr__());
    }

    func regist_single_impl_for_struct(self, node: ast_impl*, struct_info: colgm_struct*) {
        if (node->generic_types != nil) {
            self.ctx->generics.clear();
            var gtv = node->generic_types->types.__ptr__();
            for (var i: u64 = 0; i < gtv->size; i += 1) {
                var gt = gtv->get(i);
                if (!gt->is(ast_kind::ast_type_def)) {
                    self.err->error(gt->location.__ptr__(),
                        "invalid ast node, expect type def"
                    );
                    continue;
                }
                var n_td = gt => ast_type_def*;
                self.ctx->generics.insert(n_td->name->content.__ptr__());
            }
        }

        foreach (var i; node->methods) {
            var mthd = i.get() => ast_func_decl*;
            if (self.is_method(mthd)) {
                self.generate_impl_method_for_struct(struct_info, mthd);
            } else {
                self.generate_impl_static_method_for_struct(struct_info, mthd);
            }
        }

        // do copy here, because above logic does some parameter type node generation
        // if do copy above the logic, generated type nodes will not be copied
        if (node->generic_types != nil) {
            struct_info->generic_struct_impl.push(node->copy());
        }

        self.ctx->generics.clear();
    }

    func regist_single_impl_for_tagged_union(self, node: ast_impl*, union_info: colgm_tagged_union*) {
        if (node->generic_types != nil) {
            self.err->warn(
                node->base.location.__ptr__(),
                "generic template ignored"
            );
        }

        foreach (var i; node->methods) {
            var mthd = i.get() => ast_func_decl*;
            if (self.is_method(mthd)) {
                self.generate_impl_method_for_tagged_union(union_info, mthd);
            } else {
                self.generate_impl_static_method_for_tagged_union(union_info, mthd);
            }
        }
    }

    func scan_impls(self) {
        foreach (var i; self.root->decls) {
            var node = i.get();
            if (!node->is(ast_kind::ast_impl)) {
                continue;
            }
            var impl_node = node => ast_impl*;
            self.regist_single_impl(impl_node);
        }
    }
}

impl regist_pass {
    pub func run(self, root: root*) {
        // root should not be nil
        assert(root != nil, "root is nil");
        self.root = root;

        // clear this file's name and reset to the current ast file
        self.ctx->this_file.clear();
        self.ctx->this_file.append(root->base.location.file.c_str);

        // create domain if not exist
        self.ctx->create_domain_if_not_exist(root->base.location.file);

        var this_dm = self.ctx->get_domain(root->base.location.file.__ptr__());
        this_dm->file_name.clear();
        this_dm->file_name.append(root->base.location.file.c_str);

        // load primitive types:
        // i8, i16, i32, i64,
        // u8, u16, u32, u64,
        // f32, f64, bool
        // and load their methods
        self.regist_primitives();
        self.regist_builtin_funcs(root);

        // load import symbols from module
        // if the module is not compiled, directly compile it here
        // and then fetch the symbols
        self.scan_imports();
        if (self.err->error_count > 0) {
            return;
        }

        // collect all enums defined in this file
        // also collect their members
        self.scan_enums();

        // collect all structs defined in this file
        // in this process, struct's fields will be collected too
        self.scan_complex_structs();
        if (self.err->error_count > 0) {
            return;
        }

        // collect all global functions defined in this file
        self.scan_global_funcs();
        if (self.err->error_count > 0) {
            return;
        }

        // collect all impls defined in this file
        // in this process, structs' methods will be collected
        self.scan_impls();
        if (self.err->error_count > 0) {
            return;
        }

        // generic visitor, scan all the possible generic types
        // and insert them into the global symbol table
        // also do the type generation
        // type generation includes multiple steps:
        // 1. instantiate generic type (create a new type)
        // 2. replace generic symbol with specified type in struct fields, methods and functions
        // 3. scan possible generic types in the generated functions, and repeat step 1
        // if step 3 does not collect any new generic types, stop the process
        self.gnv.scan_and_insert(root);
    }
}