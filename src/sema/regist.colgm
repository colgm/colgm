use err::report::{ report };
use err::panic::{ panic, assert };

use std::io::{ io };
use std::str::{ str };
use std::libc::{ free };
use std::fs::{ fs };
use std::vec::{ primitive_vec };
use std::ptr::{ ptr, basic };
use std::math::{ isinf, isnan, floor };

use package::{ package, package_status };
use ast::ast::*;

use lex::lexer::{ lexer };
use parse::parser::{ parser };
use util::cli::{ cli_option };
use util::to_num::{ str_to_num };

use sema::symbol_info::{ symbol_kind, symbol_info };
use sema::enumerate::{ colgm_enum };
use sema::structure::{ colgm_struct };
use sema::function::{ colgm_func };
use sema::module::{ colgm_module };
use sema::context::{ sema_context };
use sema::primitive::{ colgm_primitive };
use sema::type::{ type, symbol };
use sema::type_resolve::{ type_resolve };
use sema::sema::{ sema };

pub struct regist_pass {
    this_file: str,
    err: report*,
    pkg: package*,
    root: root*,
    ctx: sema_context*,
    co: cli_option*,
    tr: type_resolve
}

impl regist_pass {
	pub func new(err: report*,
                 pkg: package*,
                 ctx: sema_context*,
                 co: cli_option*) -> regist_pass* {
		var res = regist_pass::__alloc__();
        if (res == nil) {
            panic("regist_pass::new: failed to allocate memory");
        }
        res->this_file = str::instance();
        res->err = err;
        res->pkg = pkg;
        res->root = nil;
        res->ctx = ctx;
        res->co = co;
        res->tr = type_resolve::instance(err, ctx);
        return res;
	}

    pub func delete(self) {
        self->this_file.delete();
    }
}

impl regist_pass {
    func import_all(self, node: ast_use_stmt*, dm: colgm_module*) {
        for (var i = dm->enums.iter(); !i.is_end(); i = i.next()) {
            var name = i.value()->name.__ptr__();
            var sym_info = symbol_info::new();
            sym_info->kind = symbol_kind::enum_kind;
            sym_info->loc_file.append_str(node->base.location->file.__ptr__());
            sym_info->is_public = i.value()->is_public;
            self->ctx->global_symbol()->insert(name, sym_info);
            sym_info->delete();
            free(sym_info => i8*);
        }
        for (var i = dm->structs.iter(); !i.is_end(); i = i.next()) {
            var name = i.value()->name.__ptr__();
            var sym_info = symbol_info::new();
            sym_info->kind = symbol_kind::struct_kind;
            sym_info->loc_file.append_str(node->base.location->file.__ptr__());
            sym_info->is_public = i.value()->is_public;
            self->ctx->global_symbol()->insert(name, sym_info);
            sym_info->delete();
            free(sym_info => i8*);
        }
        for (var i = dm->functions.iter(); !i.is_end(); i = i.next()) {
            var name = i.value()->name.__ptr__();
            var sym_info = symbol_info::new();
            sym_info->kind = symbol_kind::func_kind;
            sym_info->loc_file.append_str(node->base.location->file.__ptr__());
            sym_info->is_public = i.value()->is_public;
            self->ctx->global_symbol()->insert(name, sym_info);
            sym_info->delete();
            free(sym_info => i8*);
        }
        for (var i = dm->generic_structs.iter(); !i.is_end(); i = i.next()) {
            var name = i.value()->name.__ptr__();
            var sym_info = symbol_info::new();
            sym_info->kind = symbol_kind::struct_kind;
            sym_info->loc_file.append_str(node->base.location->file.__ptr__());
            sym_info->is_public = i.value()->is_public;
            self->ctx->generic_symbol()->insert(name, sym_info);
            sym_info->delete();
            free(sym_info => i8*);
        }
        for (var i = dm->generic_functions.iter(); !i.is_end(); i = i.next()) {
            var name = i.value()->name.__ptr__();
            var sym_info = symbol_info::new();
            sym_info->kind = symbol_kind::func_kind;
            sym_info->loc_file.append_str(node->base.location->file.__ptr__());
            sym_info->is_public = i.value()->is_public;
            self->ctx->generic_symbol()->insert(name, sym_info);
            sym_info->delete();
            free(sym_info => i8*);
        }
    }

    func import_specified(self, node: ast_use_stmt*, dm: colgm_module*, path: str*) {
        for (var i: u64 = 0; i < node->import_symbol.size; i += 1) {
            var name_node = node->import_symbol.get(i).get() => ast_identifier*;
            var name = name_node->name.__ptr__();

            var is_public = false;
            if (dm->enums.has(name)) {
                is_public = dm->enums.get(name)->is_public;
            } else if (dm->structs.has(name)) {
                is_public = dm->structs.get(name)->is_public;
            } else if (dm->functions.has(name)) {
                is_public = dm->functions.get(name)->is_public;
            } else if (dm->generic_structs.has(name)) {
                is_public = dm->generic_structs.get(name)->is_public;
            } else if (dm->generic_functions.has(name)) {
                is_public = dm->generic_functions.get(name)->is_public;
            } else {
                // do not report now
                // var info = str::instance();
                // info.append_i8_vec("cannot find symbol \"");
                // info.append_str(name);
                // info.append_i8_vec("\" in module \"");
                // info.append_str(path);
                // info.append_i8_vec("\"");
                // self->err->error(name_node->base.location, info.c_str);
                // info.delete();
                continue;
            }

            if (!is_public) {
                var info = str::instance();
                info.append_i8_vec("cannot import private symbol \"");
                info.append_str(name);
                info.append_i8_vec("\"");
                self->err->error(name_node->base.location, info.c_str);
                info.delete();
                continue;
            }

            var sym_info = symbol_info::new();
            sym_info->is_public = true;
            if (dm->enums.has(name)) {
                sym_info->kind = symbol_kind::enum_kind;
                sym_info->loc_file.append_str(node->base.location->file.__ptr__());
                self->ctx->global_symbol()->insert(name, sym_info);
            } else if (dm->structs.has(name)) {
                sym_info->kind = symbol_kind::struct_kind;
                sym_info->loc_file.append_str(node->base.location->file.__ptr__());
                self->ctx->global_symbol()->insert(name, sym_info);
            } else if (dm->functions.has(name)) {
                sym_info->kind = symbol_kind::func_kind;
                sym_info->loc_file.append_str(node->base.location->file.__ptr__());
                self->ctx->global_symbol()->insert(name, sym_info);
            } else if (dm->generic_structs.has(name)) {
                sym_info->kind = symbol_kind::struct_kind;
                sym_info->loc_file.append_str(node->base.location->file.__ptr__());
                self->ctx->generic_symbol()->insert(name, sym_info);
            } else if (dm->generic_functions.has(name)) {
                sym_info->kind = symbol_kind::func_kind;
                sym_info->loc_file.append_str(node->base.location->file.__ptr__());
                self->ctx->generic_symbol()->insert(name, sym_info);
            }
            sym_info->delete();
            free(sym_info => i8*);
        }
    }

    func import_from_module(self, path: str*, node: ast_use_stmt*) {
        if (!self->ctx->global->domain.has(path)) {
            self->err->error(node->base.location, "module not found");
            return;
        }
        var dm = self->ctx->global->domain.get(path);
        if (node->import_symbol.size == 0) {
            self->import_all(node, dm);
        } else {
            self->import_specified(node, dm, path);
        }
    }

    func compile_module(self, name: str*, path: str*) {
        // change package status
        var info = self->pkg->get_package_info(name);
        info->status = package_status::analysing;

        var lex = lexer::new(self->err);
        var par = parser::new(self->err, lex, self->co);
        var rp = regist_pass::new(self->err,
                                  self->pkg,
                                  self->ctx,
                                  self->co);
        var semantic = sema::new(self->err, self->pkg, self->ctx, self->co);

        lex->scan(path->c_str);
        if (self->err->error_count > 0) {
            self->ctx->log_dump();
            return;
        }

        par->parse();
        if (self->err->error_count > 0) {
            self->ctx->log_dump();
            return;
        }

        rp->run(par->root);
        if (self->err->error_count > 0) {
            self->ctx->log_dump();
            return;
        }

        semantic->scan(par->root);
        if (self->err->error_count > 0) {
            self->ctx->log_dump();
            return;
        }

        lex->delete();
        par->delete();
        rp->delete();
        semantic->delete();
        free(lex => i8*);
        free(par => i8*);
        free(rp => i8*);
        free(semantic => i8*);

        info->status = package_status::analysed;

        // ctx's this file maybe over-written, set it back
        self->ctx->this_file.clear();
        self->ctx->this_file.append_i8_vec(self->this_file.c_str);
    }

    func scan_single_import(self, node: ast_use_stmt*) {
        var expect_name = str::instance();
        var expect_path = str::from(self->pkg->library_path.c_str);

        // expect file path init with given library path
        while (expect_path.ends_with('/')) {
            expect_path.pop_back();
        }

        // generate expect path
        for (var i: u64 = 0; i < node->module_path.size; i += 1) {
            var name = node->module_path.get(i).get();
            if (!name->is(ast_kind::ast_identifier)) {
                self->err->error(name->location, "invalid module path");
                expect_name.delete();
                expect_path.delete();
                return;
            }
            var real_node = name => ast_identifier*;
            if (!expect_name.empty()) {
                expect_name.append_i8_vec("::");
            }
            if (!expect_path.empty()) {
                expect_path.append_char('/');
            }
            expect_name.append_i8_vec(real_node->name.c_str);
            expect_path.append_i8_vec(real_node->name.c_str);
        }
        // generate expect path extention
        expect_path.append_i8_vec(".colgm");

        // check if expect path exists
        if (!fs::exists(expect_path.c_str)) {
            var info = str::instance();
            info.append_i8_vec("module \"");
            info.append_i8_vec(expect_name.c_str);
            info.append_i8_vec("\" not found, \"");
            info.append_i8_vec(expect_path.c_str);
            info.append_i8_vec("\" does not exist");
            self->err->error(node->base.location, info.c_str);
            info.delete();
        }

        self->pkg->insert(expect_name.__ptr__(), expect_path.__ptr__());

        if (self->pkg->get_status(expect_name.__ptr__()) ==
            package_status::not_used) {
            self->compile_module(expect_name.__ptr__(), expect_path.__ptr__());
        }

        self->import_from_module(expect_path.__ptr__(), node);

        expect_name.delete();
        expect_path.delete();
    }

    func scan_imports(self) {
        for (var i: u64 = 0; i < self->root->imports.size; i += 1) {
            var node = self->root->imports.get(i).get();
            if (!node->is(ast_kind::ast_use_stmt)) {
                self->err->error(node->location, "invalid import");
                return;
            }
            self->scan_single_import(node => ast_use_stmt*);
        }
    }
}

impl regist_pass {
    func load_primitive_into_global_symbol(self) {
        var prim_table = [const i8*; 11];
        prim_table[0] = "i64";
        prim_table[1] = "i32";
        prim_table[2] = "i16";
        prim_table[3] = "i8";
        prim_table[4] = "u64";
        prim_table[5] = "u32";
        prim_table[6] = "u16";
        prim_table[7] = "u8";
        prim_table[8] = "f64";
        prim_table[9] = "f32";
        prim_table[10] = "bool";

        for (var i = 0; i < 11; i += 1) {
            var name = str::from(prim_table[i]);

            var sym_info = symbol_info::new();
            sym_info->kind = symbol_kind::basic_kind;
            sym_info->loc_file.append_i8_vec("");
            sym_info->is_public = true; // must be public
            self->ctx->global_symbol()->insert(name.__ptr__(), sym_info);

            name.delete();
            sym_info->delete();
            free(sym_info => i8*);
        }
    }

    func regist_primitives(self) {
        self->load_primitive_into_global_symbol();
        var gt = self->ctx->global;
        if (gt->primitives.size != 0) {
            return;
        }

        var prim_table = [const i8*; 11];
        prim_table[0] = "i64";
        prim_table[1] = "i32";
        prim_table[2] = "i16";
        prim_table[3] = "i8";
        prim_table[4] = "u64";
        prim_table[5] = "u32";
        prim_table[6] = "u16";
        prim_table[7] = "u8";
        prim_table[8] = "f64";
        prim_table[9] = "f32";
        prim_table[10] = "bool";

        for (var i = 0; i < 11; i += 1) {
            var prim_name = str::from(prim_table[i]);
            var empty_prim = colgm_primitive::instance();
            empty_prim.name.append_i8_vec(prim_table[i]);

            gt->primitives.insert(prim_name.__ptr__(), empty_prim.__ptr__());
            prim_name.delete();
            empty_prim.delete();
        }
    }
}

impl regist_pass {
    func check_is_valid_enum_value(self, node: ast_number_literal*) -> bool {
        var literal = node->literal.__ptr__();
        if (literal->find('.') != str::npos() ||
            literal->find('e') != str::npos()) {
            return false;
        }
        var num: f64 = str_to_num(literal->c_str);
        if (isinf(num) || isnan(num)) {
            return false;
        }
        if (num - floor(num) != 0.0) {
            return false;
        }
        return true;
    }

    func generate_enum_member(self, e: colgm_enum*, node: ast_enum_decl*) {
        if (node->is_public) {
            e->is_public = true;
        }

        var has_specified_value = false;
        var has_non_specified_value = false;
        var v = node->members.__ptr__();
        for (var i: u64 = 0; i < v->size; i += 1) {
            var n = v->get(i).get();
            if (!n->is(ast_kind::ast_enum_member)) {
                self->err->error(n->location,
                    "invalid ast node, expect enum member"
                );
                return;
            }
            var n_ast = n => ast_enum_member*;
            if (n_ast->value != nil) {
                has_specified_value = true;
            } else {
                has_non_specified_value = true;
            }
        }

        // specified value is required for all members now
        if (has_specified_value && has_non_specified_value) {
            self->err->error(node->base.location,
                "should use specified number for all members"
            );
            return;
        }
        
        for (var i: u64 = 0; i < v->size; i += 1) {
            var n_ast = v->get(i).get() => ast_enum_member*;
            var value = basic<u64>::wrap(i);
            var member_name = n_ast->name->name.__ptr__();
            if (n_ast->value != nil) {
                var nl = n_ast->value => ast_number_literal*;
                var res = str_to_num(nl->literal.c_str);
                value = basic<u64>::wrap(res => u64);
            }
            e->ordered_member.push(member_name);
            e->members.insert(member_name, value.__ptr__());
        }
    }

    func regist_single_enum(self, node: ast_enum_decl*) {
        var name = node->name.__ptr__();
        if (self->ctx->global_symbol()->has(name) ||
            self->ctx->generic_symbol()->has(name)) {
            var info = str::instance();
            info.append_i8_vec("enum \"");
            info.append_str(name);
            info.append_i8_vec("\" conflicts with exist symbol");
            self->err->error(node->base.location, info.c_str);
            info.delete();
            return;
        }

        // allocate enum info
        var enum_info = colgm_enum::new(name, node->base.location);
        self->generate_enum_member(enum_info, node);
        // insert to domain
        var dm = self->ctx->get_domain(node->base.location->file.__ptr__());
        dm->enums.insert(name, enum_info);
        enum_info->delete();
        free(enum_info => i8*);

        var sym_info = symbol_info::new();
        sym_info->kind = symbol_kind::enum_kind;
        sym_info->loc_file.append_str(node->base.location->file.__ptr__());
        sym_info->is_public = true; // true for selves' domain
        self->ctx->global_symbol()->insert(name, sym_info);
        sym_info->delete();
        free(sym_info => i8*);
    }

    func scan_enums(self) {
        for (var i: u64 = 0; i < self->root->decls.size; i += 1) {
            var node = self->root->decls.get(i).get();
            if (!node->is(ast_kind::ast_enum_decl)) {
                continue;
            }
            var enum_node = node => ast_enum_decl*;
            self->regist_single_enum(enum_node);
        }
    }
}

impl regist_pass {
    func generate_function_params(self,
                                  f: colgm_func*,
                                  node: ast_func_decl*,
                                  is_global_func: bool) {
        if (node->is_public) {
            f->is_public = true;
        }
        if (node->is_extern) {
            f->is_extern = true;
        }

        var v = node->params->params.__ptr__();
        for (var i: u64 = 0; i < v->size; i += 1) {
            var n = v->get(i).get();
            if (!n->is(ast_kind::ast_param)) {
                self->err->error(n->location,
                    "invalid ast node, expect param"
                );
                continue;
            }
            var n_ast = n => ast_param*;
            var param_name = n_ast->name->name.__ptr__();

            // check self param
            if (param_name->eq_const("self") && i != 0) {
                self->err->error(n->location,
                    "\"self\" must be the first param"
                );
                continue;
            }
            if (param_name->eq_const("self") && i == 0 && is_global_func) {
                self->err->error(n->location,
                    "global function cannot use \"self\" as parameter"
                );
                continue;
            }

            if (f->unordered_params.has(param_name)) {
                var info = str::instance();
                info.append_i8_vec("param \"");
                info.append_str(param_name);
                info.append_i8_vec("\" conflicts with exist param");
                self->err->error(n->location, info.c_str);
                info.delete();
                continue;
            }

            if (n_ast->type == nil) {
                // should be unreachable
                var param_type = type::error_type();
                f->param_name.push(param_name);
                f->param_type.push(param_type.__ptr__());
                f->unordered_params.insert(param_name, param_type.__ptr__());
            } else {
                var param_type = self->tr.resolve(n_ast->type);
                f->param_name.push(param_name);
                f->param_type.push(param_type.__ptr__());
                f->unordered_params.insert(param_name, param_type.__ptr__());
            }
        }
    }

    func regist_single_global_func(self, node: ast_func_decl*) {
        var name = node->name.__ptr__();
        if (self->ctx->global_symbol()->has(name) ||
            self->ctx->generic_symbol()->has(name)) {
            var info = str::instance();
            info.append_i8_vec("\"");
            info.append_str(name);
            info.append_i8_vec("\" conflicts with exist symbol");
            self->err->error(node->base.location, info.c_str);
            info.delete();
            return;
        }

        // TODO
        if (node->generic_types != nil) {
            return;
        }

        // allocate func info
        var func_info: colgm_func* = nil;
        if (node->return_type == nil) {
            var ret_type = type::void_type();
            func_info = colgm_func::new(
                name,
                node->base.location,
                ret_type.__ptr__()
            );
            ret_type.delete();
        } else {
            var ret_type = self->tr.resolve(node->return_type);
            func_info = colgm_func::new(
                name,
                node->base.location,
                ret_type.__ptr__()
            );
            ret_type.delete();
        }

        self->generate_function_params(func_info, node, true);

        // insert to domain
        var dm = self->ctx->get_domain(node->base.location->file.__ptr__());
        dm->functions.insert(name, func_info);
        func_info->delete();
        free(func_info => i8*);

        var sym_info = symbol_info::new();
        sym_info->kind = symbol_kind::func_kind;
        sym_info->loc_file.append_str(node->base.location->file.__ptr__());
        sym_info->is_public = true; // true for selves' domain
        self->ctx->global_symbol()->insert(name, sym_info);
        sym_info->delete();
        free(sym_info => i8*);
    }

    func scan_global_funcs(self) {
        for (var i: u64 = 0; i < self->root->decls.size; i += 1) {
            var node = self->root->decls.get(i).get();
            if (!node->is(ast_kind::ast_func_decl)) {
                continue;
            }
            var func_node = node => ast_func_decl*;
            self->regist_single_global_func(func_node);
        }
    }
}

impl regist_pass {
    func regist_single_struct(self, node: ast_struct_decl*) {
        var name = node->name.__ptr__();
        if (!self->ctx->global_symbol()->has(name) &&
            !self->ctx->generic_symbol()->has(name)) {
            var info = str::instance();
            info.append_i8_vec("cannot find symbol \"");
            info.append_str(name);
            info.append_i8_vec("\"");
            self->err->error(node->base.location, info.c_str);
            info.delete();
            return;
        }

        if (node->generic_types != nil) {
            self->ctx->generics.clear();
            var gtv = node->generic_types->types.__ptr__();
            for (var i: u64 = 0; i < gtv->size; i += 1) {
                var gt = gtv->get(i).get();
                if (!gt->is(ast_kind::ast_type_def)) {
                    self->err->error(gt->location,
                        "invalid ast node, expect type def"
                    );
                    continue;
                }
                var n_td = gt => ast_type_def*;
                self->ctx->generics.insert(n_td->name->name.__ptr__());
            }
        }

        var dm = self->ctx->get_domain(node->base.location->file.__ptr__());
        if (node->generic_types == nil && !dm->structs.has(name)) {
            return;
        }
        if (node->generic_types != nil && !dm->generic_structs.has(name)) {
            return;
        }
        var struct_info: colgm_struct* = nil;
        if (node->generic_types == nil) {
            struct_info = dm->structs.get(name);
        } else {
            struct_info = dm->generic_structs.get(name);
            var gtv = node->generic_types->types.__ptr__();
            for (var i: u64 = 0; i < gtv->size; i += 1) {
                var gt = gtv->get(i).get();
                if (!gt->is(ast_kind::ast_type_def)) {
                    self->err->error(gt->location,
                        "invalid ast node, expect type def"
                    );
                    continue;
                }
                var n_td = gt => ast_type_def*;
                struct_info->generic_template.push(n_td->name->name.__ptr__());
            }
        }

        if (node->generic_types != nil) {
            // TODO
            return;
        }

        for (var i: u64 = 0; i < node->fields.size; i += 1) {
            var fld = node->fields.get(i).get() ;
            if (!fld->is(ast_kind::ast_struct_field)) {
                continue;
            }

            var fld_ast = fld => ast_struct_field*;
            var fld_name = fld_ast->name->name.__ptr__();
            if (struct_info->fields.has(fld_name)) {
                var info = str::instance();
                info.append_i8_vec("field \"");
                info.append_str(fld_name);
                info.append_i8_vec("\" conflicts with exist field");
                self->err->error(node->base.location, info.c_str);
                info.delete();
                continue;
            }
            var sym = symbol {
                name: fld_name->copy_instance(),
                sym_type: self->tr.resolve(fld_ast->type)
            };
            struct_info->fields.insert(name, sym.__ptr__());
            struct_info->ordered_fields.push(sym.__ptr__());
            sym.delete();
        }
    }

    func regist_single_struct_symbol(self, node: ast_struct_decl*) {
        var name = node->name.__ptr__();
        if (self->ctx->global_symbol()->has(name) ||
            self->ctx->generic_symbol()->has(name)) {
            var info = str::instance();
            info.append_i8_vec("struct \"");
            info.append_str(name);
            info.append_i8_vec("\" conflicts with exist symbol");
            self->err->error(node->base.location, info.c_str);
            info.delete();
            return;
        }

        // allocate struct info
        var struct_info = colgm_struct::new(name, node->base.location);
        if (node->is_extern) {
            struct_info->is_extern = true;
        }
        if (node->is_public) {
            struct_info->is_public = true;
        }
        // insert to domain
        var dm = self->ctx->get_domain(node->base.location->file.__ptr__());
        if (node->generic_types != nil) {
            dm->generic_structs.insert(name, struct_info);
        } else {
            dm->structs.insert(name, struct_info);
        }
        struct_info->delete();
        free(struct_info => i8*);

        var sym_info = symbol_info::new();
        sym_info->kind = symbol_kind::struct_kind;
        sym_info->loc_file.append_str(node->base.location->file.__ptr__());
        sym_info->is_public = true; // true for selves's domain
        if (node->generic_types != nil) {
            self->ctx->generic_symbol()->insert(name, sym_info);
        } else {
            self->ctx->global_symbol()->insert(name, sym_info);
        }
        sym_info->delete();
        free(sym_info => i8*);
    }

    func scan_structs(self) {
        for (var i: u64 = 0; i < self->root->decls.size; i += 1) {
            var node = self->root->decls.get(i).get();
            if (!node->is(ast_kind::ast_struct_decl)) {
                continue;
            }
            var struct_node = node => ast_struct_decl*;
            self->regist_single_struct_symbol(struct_node);
        }

        for (var i: u64 = 0; i < self->root->decls.size; i += 1) {
            var node = self->root->decls.get(i).get();
            if (!node->is(ast_kind::ast_struct_decl)) {
                continue;
            }
            var struct_node = node => ast_struct_decl*;
            self->regist_single_struct(struct_node);
        }
    }
}

impl regist_pass {
    func is_method(self, node: ast_func_decl*) -> bool {
        var pms = node->params->params.__ptr__();
        if (pms->size == 0) {
            return false;
        }

        var first_param = pms->get(0).get();
        if (!first_param->is(ast_kind::ast_param)) {
            return false;
        }
        var first_param_node = first_param => ast_param*;
        if (first_param_node->name->name.eq_const("self")) {
            return true;
        }
        return false;
    }

    func check_field_not_exist(self,
                               struct_info: colgm_struct*,
                               name: str*) -> bool {
        if (struct_info->fields.has(name)) {
            return false;
        }
        if (struct_info->static_methods.has(name)) {
            return false;
        }
        if (struct_info->methods.has(name)) {
            return false;
        }
        return true;
    }

    func generate_self_type_node(self, struct_name: str*, node: ast_func_decl*) {
        var pms = node->params->params.__ptr__();
        var first_param = pms->get(0).get() => ast_param*;
        if (first_param->type != nil) {
            panic("unreachable");
            return;
        }

        var tn = ast_type_def::new(first_param->base.location->copy());
        tn->name = ast_identifier::new(first_param->base.location->copy(),
                                       struct_name);
        tn->pointer_depth = 1;
        first_param->type = tn;
    }

    func generate_impl_method(self,
                              struct_name: str*,
                              struct_info: colgm_struct*,
                              node: ast_func_decl*) {
        var name = node->name.__ptr__();
        if (!self->check_field_not_exist(struct_info, name)) {
            var info = str::instance();
            info.append_i8_vec("field \"");
            info.append_str(name);
            info.append_i8_vec("\" conflicts with exist field or method");
            self->err->error(node->base.location, info.c_str);
            info.delete();
            return;
        }

        // allocate func info
        var func_info: colgm_func* = nil;
        if (node->return_type == nil) {
            var ret_type = type::void_type();
            func_info = colgm_func::new(
                name,
                node->base.location,
                ret_type.__ptr__()
            );
            ret_type.delete();
        } else {
            var ret_type = self->tr.resolve(node->return_type);
            func_info = colgm_func::new(
                name,
                node->base.location,
                ret_type.__ptr__()
            );
            ret_type.delete();
        }

        self->generate_self_type_node(struct_name, node);
        self->generate_function_params(func_info, node, false);
        struct_info->methods.insert(name, func_info);
        func_info->delete();
        free(func_info => i8*);
    }

    func generate_impl_static_method(self,
                              struct_info: colgm_struct*,
                              node: ast_func_decl*) {
        var name = node->name.__ptr__();
        if (!self->check_field_not_exist(struct_info, name)) {
            var info = str::instance();
            info.append_i8_vec("field \"");
            info.append_str(name);
            info.append_i8_vec("\" conflicts with exist field or method");
            self->err->error(node->base.location, info.c_str);
            info.delete();
            return;
        }

        // allocate func info
        var func_info: colgm_func* = nil;
        if (node->return_type == nil) {
            var ret_type = type::void_type();
            func_info = colgm_func::new(
                name,
                node->base.location,
                ret_type.__ptr__()
            );
            ret_type.delete();
        } else {
            var ret_type = self->tr.resolve(node->return_type);
            func_info = colgm_func::new(
                name,
                node->base.location,
                ret_type.__ptr__()
            );
            ret_type.delete();
        }

        self->generate_function_params(func_info, node, false);
        struct_info->static_methods.insert(name, func_info);
        func_info->delete();
        free(func_info => i8*);
    }

    func regist_single_impl(self, node: ast_impl*) {
        if (node->generic_types != nil) {
            return;
        }

        var name = node->name.__ptr__();
        var dm = self->ctx->get_domain(node->base.location->file.__ptr__());
        if (!dm->structs.has(name)) {
            var info = str::instance();
            info.append_i8_vec("cannot find struct \"");
            info.append_str(name);
            info.append_i8_vec("\"");
            self->err->error(node->base.location, info.c_str);
            info.delete();
            return;
        }

        var struct_info = dm->structs.get(name);
        for (var i: u64 = 0; i < node->methods.size; i += 1) {
            var mthd = node->methods.get(i).get();
            if (!mthd->is(ast_kind::ast_func_decl)) {
                continue;
            }

            var mthd_node = mthd => ast_func_decl*;
            if (self->is_method(mthd_node)) {
                self->generate_impl_method(name, struct_info, mthd_node);
            } else {
                self->generate_impl_static_method(struct_info, mthd_node);
            }
        }
    }

    func scan_impls(self) {
        for (var i: u64 = 0; i < self->root->decls.size; i += 1) {
            var node = self->root->decls.get(i).get();
            if (!node->is(ast_kind::ast_impl)) {
                continue;
            }
            var impl_node = node => ast_impl*;
            self->regist_single_impl(impl_node);
        }
    }
}

impl regist_pass {
    pub func run(self, root: root*) {
        // root should not be nil
        assert(root != nil, "root is nil");
        self->root = root;

        // clear this file's name and reset to the current ast file
        self->this_file.clear();
        self->this_file.append_i8_vec(root->base.location->file.c_str);
        self->ctx->this_file.clear();
        self->ctx->this_file.append_i8_vec(root->base.location->file.c_str);
        self->ctx->create_domain_if_not_exist(self->this_file.__ptr__());
        var this_dm = self->ctx->get_domain(self->this_file.__ptr__());
        this_dm->file_name.clear();
        this_dm->file_name.append_i8_vec(root->base.location->file.c_str);

        self->regist_primitives();
        self->scan_imports();
        if (self->err->error_count > 0) {
            self->ctx->log_dump();
            return;
        }

        self->scan_enums();
        self->scan_structs();
        if (self->err->error_count > 0) {
            self->ctx->log_dump();
            return;
        }

        self->scan_global_funcs();
        if (self->err->error_count > 0) {
            self->ctx->log_dump();
            return;
        }

        self->scan_impls();
        if (self->err->error_count > 0) {
            self->ctx->log_dump();
            return;
        }
    }
}