use err::report::{ report };
use std::io::{ io };
use std::str::{ str };
use package::{ package };
use ast::ast::*;
use std::fs::{ fs };
use sema::context::{ colgm_primitive, sema_context };

pub struct regist_pass {
    this_file: str,
    err: report*,
    pkg: package*,
    root: root*,
    ctx: sema_context*
}

impl regist_pass {
	pub func new(err: report*,
                 pkg: package*,
                 ctx: sema_context*) -> regist_pass* {
		var res = regist_pass::__alloc__();
        res->this_file = str::instance();
        res->err = err;
        res->pkg = pkg;
        res->root = nil => root*;
        res->ctx = ctx;
        return res;
	}

    pub func delete(self) {
        self->this_file.delete();
    }
}

impl regist_pass {
    func scan_single_import(self, node: ast_use_stmt*) {
        var expect_name = str::instance();
        var expect_path = str::from(self->pkg->library_path.c_str);

        // expect path init with given library path
        while (expect_path.ends_with('/')) {
            expect_path.pop_back();
        }

        // generate expect path
        for (var i: u64 = 0; i < node->module_path.size; i += 1) {
            var name = node->module_path.get(i).get();
            if (name->kind != ast_kind::ast_identifier) {
                self->err->error(name->location, "invalid module path");
                expect_name.delete();
                expect_path.delete();
                return;
            }
            var real_node = name => ast_identifier*;
            if (!expect_name.empty()) {
                expect_name.append_i8_vec("::");
            }
            if (!expect_path.empty()) {
                expect_path.append_char('/');
            }
            expect_name.append_i8_vec(real_node->name.c_str);
            expect_path.append_i8_vec(real_node->name.c_str);
        }
        // generate expect path extention
        expect_path.append_i8_vec(".colgm");

        // check if expect path exists
        if (!fs::exists(expect_path.c_str)) {
            var info = str::instance();
            info.append_i8_vec("module \"");
            info.append_i8_vec(expect_name.c_str);
            info.append_i8_vec("\" not found, \"");
            info.append_i8_vec(expect_path.c_str);
            info.append_i8_vec("\" does not exist");
            self->err->error(node->base.location, info.c_str);
            info.delete();
        }

        self->pkg->insert(expect_name.__ptr__(), expect_path.__ptr__());
        expect_name.delete();
        expect_path.delete();
    }

    func scan_imports(self) {
        for (var i: u64 = 0; i < self->root->imports.size; i += 1) {
            var node = self->root->imports.get(i).get();
            if (node->kind != ast_kind::ast_use_stmt) {
                self->err->error(node->location, "invalid import");
                return;
            }
            self->scan_single_import(node => ast_use_stmt*);
        }
    }
}

impl regist_pass {
    func regist_primitives(self) {
        var gt = self->ctx->global;
        if (gt->primitives.size != 0) {
            return;
        }

        var prim_table = [const i8*; 11];
        prim_table[0] = "i64";
        prim_table[1] = "i32";
        prim_table[2] = "i16";
        prim_table[3] = "i8";
        prim_table[4] = "u64";
        prim_table[5] = "u32";
        prim_table[6] = "u16";
        prim_table[7] = "u8";
        prim_table[8] = "f64";
        prim_table[9] = "f32";
        prim_table[10] = "bool";

        for (var i = 0; i < 11; i += 1) {
            var prim_name = str::from(prim_table[i]);
            var empty_prim = colgm_primitive::instance();
            empty_prim.name.append_i8_vec(prim_table[i]);

            gt->primitives.insert(prim_name.__ptr__(), empty_prim.__ptr__());
            prim_name.delete();
            empty_prim.delete();
        }
    }
}

impl regist_pass {
    func scan_enums(self) {}

    func scan_global_funcs(self) {}

    func scan_structs(self) {}

    func scan_impls(self) {}
}

impl regist_pass {
    pub func run(self, root: root*) {
        self->root = root;

        self->this_file.clear();
        self->this_file.append_i8_vec(root->base.location->file.c_str);
        self->ctx->create_domain(self->this_file.__ptr__());

        self->regist_primitives();
        for (var i = self->ctx->global->primitives.iter();
             !i.is_end();
             i = i.next()) {
            io::stderr().out("[").green().out("sema").reset().out("]");
            io::stderr().out(" insert primitive ").out(i.key()->c_str).out("\n");
        }
        self->scan_imports();
        if (self->err->error_count > 0) {
            return;
        }

        self->scan_enums();
        self->scan_structs();
        if (self->err->error_count > 0) {
            return;
        }

        self->scan_global_funcs();
        if (self->err->error_count > 0) {
            return;
        }

        self->scan_impls();
        if (self->err->error_count > 0) {
            return;
        }
    }
}