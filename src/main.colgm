use std::libc::{ free, streq, strlen };
use err::span::*;
use err::report::*;
use cli::*;
use std::io::{ readfile_into_string, io };
use std::fs::{ fs };
use lexer::{ lexer };
use parser::{ parser };
use package::{ package };

struct compiler {
    rep: report*,
    pkg: package*,
    lex: lexer*,
    par: parser*
}

impl compiler {
    pub func instance() -> compiler {
        var rep = report::new();
        var pkg = package::new(rep);
        var lex = lexer::new(rep);
        var par = parser::new(rep, lex);
        return compiler {
            rep: rep,
            pkg: pkg,
            lex: lex,
            par: par
        };
    }

    pub func delete(self) {
        if (self->rep => i8* != nil) {
            self->rep->delete();
            free(self->rep => i8*);
        }
        if (self->pkg => i8* != nil) {
            self->pkg->delete();
            free(self->pkg => i8*);
        }
        if (self->lex => i8* != nil) {
            self->lex->delete();
            free(self->lex => i8*);
        }
        if (self->par => i8* != nil) {
            self->par->delete();
            free(self->par => i8*);
        }
    }
}

func compile(option: cli_option) {
    var err = io::stderr();
    if (!fs::exists(option.filename)) {
        err.red().out("Error: ").reset();
        err.out("failed to load file <").out(option.filename)
           .out(">, check if exists and is readable\n");
        return;
    }
    #if (option.library_path != nil &&
    #    !fs::is_dir(option.library_path)) {
    #    err.red().out("Error: ").reset();
    #    err.out("failed to load library path <").out(option.library_path)
    #       .out(">, check if exists and is directory\n");
    #    return;
    #}

    err.out("[").green().out("colgm").reset().out("]")
       .out(" source file  : ").out(option.filename).out("\n");
    err.out("[").green().out("colgm").reset().out("]")
       .out(" library path : ").out(option.library_path).out("\n");

    var cc = compiler::instance();

    # do lexer scanning
    cc.lex->scan(option.filename);
    if (cc.rep->error_count > 0) {
        cc.delete();
        return;
    }
    if (option.OPTION_VIEW_TOKEN) {
        cc.lex->dump();
    }

    cc.par->parse();
    if (cc.rep->error_count > 0) {
        cc.delete();
        return;
    }
    if (option.OPTION_VIEW_AST) {
        cc.par->dump();
    }

    cc.delete();
}

func main(argc: i32, argv: i8**) -> i32 {
    if (argc==(1 => i32)) {
        logo(argv[0]);
        return 0 => i32;
    }

    if (argc==(2 => i32) && (streq(argv[1], "-h") || streq(argv[1], "--help"))) {
        help();
        return 0 => i32;
    }
    if (argc==(2 => i32) && (streq(argv[1], "-v") || streq(argv[1], "--version"))) {
        io::stderr().out(version()).endln();
        return 0 => i32;
    }

    var option = cli_option::instance();
    for(var i = 1 => i32; i < argc; i += 1 => i32) {
        if (streq(argv[i], "-l") || streq(argv[i], "--lex")) {
            option.OPTION_VIEW_TOKEN = true;
        } elsif (streq(argv[i], "-a") || streq(argv[i], "--ast")) {
            option.OPTION_VIEW_AST = true;
        } elsif (streq(argv[i], "-s") || streq(argv[i], "--sema")) {
            option.OPTION_VIEW_SEMA = true;
        } elsif (streq(argv[i], "--library")) {
            if (i + (1 => i32) >= argc) {
                io::stderr().red().out("Error:").reset()
                            .out(" missing library path").endln();
                return (-1) => i32;
            }
            if (option.library_path != nil) {
                io::stderr().red().out("Error:").reset()
                            .out(" multiple library path specified").endln();
                return (-1) => i32;
            }
            option.library_path = argv[i + (1 => i32)];
            if (strlen(option.library_path)==0 || option.library_path[0]=='-') {
                io::stderr().red().out("Error:").reset()
                            .out(" invalid library path <")
                            .out(option.library_path).out(">").endln();
                return (-1) => i32;
            }
            i += 1 => i32;
        } elsif (streq(argv[i], "--dump-lib")) {
            option.OPTION_VIEW_LIB = true;
        } elsif (streq(argv[i], "--mir")) {
            option.OPTION_VIEW_MIR = true;
        } elsif (streq(argv[i], "--sir")) {
            option.OPTION_VIEW_SIR = true;
        } elsif (argv[i][0]=='-') {
            io::stderr().red().out("Error:").reset()
                        .out(" invalid argument: ").out(argv[i]).endln();
            return (-1) => i32;
        } else if (option.filename == nil) {
            option.filename = argv[i];
        } else {
            io::stderr().red().out("Error:").reset()
                        .out(" invalid argument: ").out(argv[i]).endln();
            return (-1) => i32;
        }
    }

    if (option.filename == nil) {
        io::stderr().red().out("Error:").reset()
                    .out(" no source file specified").endln();
        return (-1) => i32;
    }
    if (option.library_path == nil) {
        option.library_path = ".";
    }

    compile(option);
    return 0 => i32;
}
