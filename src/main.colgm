use std::libc::{ free, streq, strlen };
use err::span::*;
use err::report::*;
use cli::*;
use std::io::{ readfile_into_string, io, fs };
use lexer::{ lexer };
use parser::{ parser };

func free_components(rep: report*, lex: lexer*, par: parser*) {
    if (rep => i8* != nil) {
        rep->delete();
        free(rep => i8*);
    }
    if (lex => i8* != nil) {
        lex->delete();
        free(lex => i8*);
    }
    if (par => i8* != nil) {
        par->delete();
        free(par => i8*);
    }
}

func compile(filename: i8*, library_path: i8*, option: cli_option*) {
    if (!fs::exists(filename)) {
        io::stderr().red().out("Error: ").reset();
        io::stderr().out("failed to load file <").out(filename)
                    .out(">, check if it exists and is readable\n");
        return;
    }

    io::stderr().out("[colgm] source file: \"")
                .out(filename)
                .out("\"")
                .endln();
    if (library_path!=nil) {
        io::stderr().out("[colgm] library path: \"")
                    .out(library_path)
                    .out("\"")
                    .endln();
    } else {
        io::stderr().out("[colgm] library path: <none>").endln();
    }

    var rep = report::new();
    var lex = lexer::new(rep);
    var par = parser::new(rep, lex);

    # do lexer scanning
    lex->scan(filename);
    if (rep->error_count > 0) {
        free_components(rep, lex, par);
        return;
    }
    if (option->OPTION_VIEW_TOKEN) {
        lex->dump();
    }

    par->parse();
    if (rep->error_count > 0) {
        free_components(rep, lex, par);
        return;
    }

    free_components(rep, lex, par);
}

func main(argc: i32, argv: i8**) -> i32 {
    if (argc==(1 => i32)) {
        logo(argv[0]);
        return 0 => i32;
    }

    if (argc==(2 => i32) && (streq(argv[1], "-h") || streq(argv[1], "--help"))) {
        help();
        return 0 => i32;
    }
    if (argc==(2 => i32) && (streq(argv[1], "-v") || streq(argv[1], "--version"))) {
        io::stderr().out(version()).endln();
        return 0 => i32;
    }

    var filename = nil;
    var library_path = nil;
    var option = cli_option::new();
    for(var i = 1 => i32; i < argc; i += 1 => i32) {
        if (streq(argv[i], "-l") || streq(argv[i], "--lex")) {
            option->OPTION_VIEW_TOKEN = true;
        } elsif (streq(argv[i], "-a") || streq(argv[i], "--ast")) {
            option->OPTION_VIEW_AST = true;
        } elsif (streq(argv[i], "-s") || streq(argv[i], "--sema")) {
            option->OPTION_VIEW_SEMA = true;
        } elsif (streq(argv[i], "-L") || streq(argv[i], "--library")) {
            if (i + (1 => i32) >= argc) {
                io::stderr().red().out("Error:").reset()
                            .out(" missing library path").endln();
                return (-1) => i32;
            }
            library_path = argv[i + (1 => i32)];
            if (strlen(library_path)==0 || library_path[0]=='-') {
                io::stderr().red().out("Error:").reset()
                            .out(" invalid library path <")
                            .out(library_path).out(">").endln();
                return (-1) => i32;
            }
            i += 1 => i32;
        } elsif (streq(argv[i], "--dump-lib")) {
            option->OPTION_VIEW_LIB = true;
        } elsif (streq(argv[i], "--mir")) {
            option->OPTION_VIEW_MIR = true;
        } elsif (streq(argv[i], "--sir")) {
            option->OPTION_VIEW_SIR = true;
        } elsif (argv[i][0]=='-') {
            io::stderr().red().out("Error:").reset()
                        .out(" invalid argument: ").out(argv[i]).endln();
            return (-1) => i32;
        } else {
            filename = argv[i];
        }
    }

    if (filename == nil) {
        io::stderr().red().out("Error:").reset()
                    .out(" no source file specified").endln();
        return (-1) => i32;
    }

    compile(filename, library_path, option);
    free(option => i8*);
    return 0 => i32;
}
