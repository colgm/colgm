use std::libc::{ streq, strlen, system };
use std::io::{ io };
use std::fs::{ fs };
use std::str::{ str };

use util::cli::*;
use util::frontend::{ frontend };
use util::clang_finder::{ find_clang };
use util::timestamp::{ maketimestamp };
use util::package::{ package };
use util::platform::{ is_windows };

use sema::context::{ global_symbol_table, sema_context };
use sema::regist::{ regist_pass };
use sema::sema::{ sema };

use mir::mir::*;
use mir::context::{ mir_context };
use mir::ast2mir::{ ast2mir };

use target::nasal::mir2nasal::{ mir2nasal };
use target::markdown::sema2md::{ sema2md };

use sir::sir::*;
use sir::context::{ sir_context };
use sir::mir2sir::{ mir2sir };

func adjust_compile_option(cmd: str&) {
    if (!is_windows()) {
        // clang on windows need to link with msvcrt.lib
        // but macOS/linux need to link with math library
        cmd.append(" -rdynamic -lm");
    } else {
        // specify the triple, without suffix
        cmd.append(" -Xclang -triple=x86_64-pc-windows-msvc");
        cmd.append(" -ldbghelp -lws2_32 -lkernel32");
    }
}

func clang_compile(co: cli_option&) -> i32 {
    if (co.EMIT_LLVM_ONLY) {
        io::stdout().green().out("     CLANG ").reset();
        io::stdout().out("Compilation disabled by option\n");
        return 0;
    }

    var time_stamp = maketimestamp();
    time_stamp.stamp();

    var clang = find_clang();
    defer clang.delete();

    if (clang.empty()) {
        io::stdout().red().out("     CLANG ").reset();
        io::stdout().out("Cannot find suitable clang\n");
        return -1;
    } else if (co.VERBOSE) {
        io::stdout().green().out("     CLANG ").reset();
        io::stdout().out("Find clang ");
        io::stdout().cyan().out("<").out(clang.c_str).out("> ").reset();
        io::stdout().out_f64(time_stamp.elapsed_msec()).out(" ms\n");
    }

    var cmd = str::instance();
    if (is_windows()) {
        // LLVM usually installed in C:\Program Files\LLVM
        // so we need to use "\" to escape the space in path
        cmd.append("\"").append(clang.c_str).append("\"");
    } else {
        cmd.append(clang.c_str);
    }
    defer cmd.delete();

    var ll_file = str::from(co.output_file);
    ll_file.append(".ll");
    defer ll_file.delete();

    if (!fs::exists(ll_file.c_str)) {
        return -1;
    }

    cmd.append(" ").append(co.get_opt_level()).append(" ");
    cmd.append(ll_file.c_str);
    if (co.DEBUG_MODE) {
        cmd.append(" -g");
    }
    cmd.append(" -o ").append(co.output_file);
    adjust_compile_option(cmd);

    if (co.VERBOSE) {
        io::stdout().green().out("     CLANG ").reset();
        io::stdout().out("Executing ");
        io::stdout().cyan().out("\"").out(cmd.c_str).out("\"\n").reset();
    } else {
        io::stdout().green().out("     CLANG ").reset();
        io::stdout().out("Compiling...\r");
    }

    time_stamp.stamp();
    var ret_code = system(cmd.c_str);
    if (ret_code == 0) {
        io::stdout().green().out("     CLANG ").reset();
        io::stdout().out("Compilation ").cyan().out("succeeded ").reset();
    } else {
        io::stdout().red().out("     CLANG ").reset();
        io::stdout().out("Compilation ").red().out("failed ").reset();
    }

    var compile_duration = time_stamp.elapsed_msec();
    if (compile_duration < 1000.0) {
        io::stdout().out_f64(compile_duration).out(" ms\n");
    } else {
        io::stdout().out_f64(compile_duration / 1000.0).out(" s\n");
    }

    return ret_code;
}

func nasal_target_output(option: cli_option,
                         glb: global_symbol_table*,
                         mctx: mir_context*,
                         pkg: package&) {
    var time_stamp = maketimestamp();
    var nas_file = str::from(option.output_file);
    nas_file.append(".nas");
    defer nas_file.delete();

    io::stdout().green().out("  MIR-PASS ").reset();
    io::stdout().out("Generating ");
    io::stdout().cyan().out("<").out(option.output_file).out(".nas> ").reset();
    time_stamp.stamp();
    mir2nasal::instance(glb, mctx, pkg.__ptr__()).dump(nas_file.c_str);
    io::stdout().out_f64(time_stamp.elapsed_msec()).out(" ms\n");
}

func output_ll_file(option: cli_option&, sctx: sir_context&) {
    var ll_file = str::from(option.output_file);
    ll_file.append(".ll");
    defer ll_file.delete();

    if (option.VERBOSE) {
        io::stdout().green().out("  SIR-PASS ").reset();
        io::stdout().out("Generating ");
        io::stdout().cyan().out("<").out(option.output_file).out(".ll> ").reset();
    }

    // make time stamp
    var time_stamp = maketimestamp();
    time_stamp.stamp();

    // output
    var file_output = io::fileout(ll_file.c_str);
    sctx.dump(file_output);
    file_output.close();

    if (option.VERBOSE) {
        io::stdout().out_f64(time_stamp.elapsed_msec()).out(" ms\n");
    }
}

func compile(option: cli_option&) -> i32 {
    var err = io::stderr();
    if (!fs::exists(option.input_file)) {
        err.red().out("Error: ").reset();
        err.out("failed to load file <").out(option.input_file);
        err.out(">, check if exists and is readable\n");
        return -1;
    }
    if (fs::is_dir(option.input_file)) {
        err.red().out("Error: ").reset();
        err.out("failed to load file <").out(option.input_file);
        err.out(">, this is a directory\n");
        return -1;
    }
    if (option.library_path != nil && !fs::is_dir(option.library_path)) {
        err.red().out("Error: ").reset();
        err.out("failed to load library path <").out(option.library_path);
        err.out(">, check if exists and is directory\n");
        return -1;
    }

    var cwd = fs::getcwd();
    defer cwd.delete();
    if (!cwd.empty()) {
        io::stdout().green().out("     COLGM ").reset();
        io::stdout().out("In directory ");
        io::stdout().cyan().out("<").out(cwd.c_str).out(">").reset().endln();
    }

    var cc = frontend::instance(option);
    defer cc.delete();

    // global symbol table
    var gt = global_symbol_table::instance(option.input_file);
    defer gt.delete();

    // semantic context
    var ctx = sema_context::instance(gt.__ptr__());
    defer ctx.delete();

    // mir context
    var mctx = mir_context::instance();
    defer mctx.delete();

    // sir context
    var sctx = sir_context::instance();
    defer sctx.delete();

    var regpass = regist_pass::instance(
        cc.err,
        cc.pkg.__ptr__(),
        ctx.__ptr__(),
        cc.copt,
        mctx.__ptr__()
    );
    defer regpass.delete();

    var semantic = sema::instance(
        cc.err,
        cc.pkg.__ptr__(),
        ctx.__ptr__(),
        cc.copt
    );
    defer semantic.delete();

    var ast2mir_worker = ast2mir::instance(
        cc.err,
        ctx.__ptr__(),
        cc.pkg.__ptr__(),
        mctx.__ptr__()
    );
    defer ast2mir_worker.delete();

    var mir2sir_worker = mir2sir::instance(
        ctx.__ptr__(),
        sctx.__ptr__(),
        cc.pkg.__ptr__(),
        cc.err
    );
    defer mir2sir_worker.delete();

    cc.pkg.library_path.clear();
    cc.pkg.library_path.append(option.library_path);

    var time_stamp = maketimestamp();

    time_stamp.stamp();
    cc.par.parse(option.input_file, option.VIEW_DEFER_REPLACE);
    if (option.VERBOSE) {
        io::stdout().green().out("    PARSER ").reset();
        io::stdout().out("Parse syntax ");
        io::stdout().out_f64(time_stamp.elapsed_msec()).out(" ms\n");
    }

    if (cc.err->error_count > 0) {
        return -1;
    }
    if (option.VIEW_AST) {
        cc.par.dump(io::stdout());
    }

    time_stamp.stamp();
    regpass.run(cc.par.root);
    if (cc.err->error_count > 0) {
        return -1;
    }

    semantic.analyse(cc.par.root);
    var sema_duration = time_stamp.elapsed_msec();

    io::stdout().green().out("  SEMANTIC ").reset();
    io::stdout().out("Finish module ");
    io::stdout().cyan().out("<").out(option.input_file).out("> ").reset();
    if (sema_duration < 1000.0) {
        io::stdout().out_f64(time_stamp.elapsed_msec()).out(" ms\n");
    } else {
        io::stdout().out_f64(sema_duration / 1000.0).out(" s\n");
    }

    if (cc.err->error_count > 0) {
        return -1;
    }
    if (option.VIEW_RESOLVED_AST) {
        semantic.view_resolved_ast(io::stdout());
    }
    if (option.VIEW_SEMA) {
        semantic.ctx->dump(io::stdout(), cc.pkg.__ptr__());
    }
    if (option.EMIT_MARKDOWN_ONLY) {
        sema2md(ctx, cc.pkg, "colgm.sema.md");
        return 0;
    }

    ast2mir_worker.generate(cc.par.root);
    if (cc.err->error_count > 0) {
        return -1;
    }

    // run mir pass
    mctx.adjust_posix_open(option.VERBOSE);
    mctx.add_default_func(option.VERBOSE);

    if (option.VIEW_MIR) {
        mctx.dump(io::stdout(), cc.pkg);
    }
    if (option.DUMP_MIR) {
        var fout = io::fileout("mir.dump.txt");
        mctx.dump(fout, cc.pkg);
        fout.close();
    }
    if (option.EMIT_NASAL_ONLY) {
        nasal_target_output(option, gt.__ptr__(), mctx.__ptr__(), cc.pkg);
        return 0;
    }

    mir2sir_worker.generate(
        mctx,
        option.VIEW_UNUSED_FUNC,
        option.with_optimization(),
        option.VERBOSE,
        option.DEBUG_MODE
    );
    if (option.VIEW_SIR) {
        sctx.dump(io::stdout());
    }
    if (cc.err->error_count > 0) {
        return -1;
    }

    output_ll_file(option, sctx);

    return clang_compile(option);
}

func is_opt_option(arg: const i8*) -> bool {
    if (strlen(arg) != 3) {
        return false;
    }
    if (arg[0] != '-' || arg[1] != 'O') {
        return false;
    }

    var level = ['0', '1', '2', '3', 'z', 's'];
    for (var i = 0; i < 6; i += 1) {
        if (arg[2] == level[i]) {
            return true;
        }
    }
    return false;
}

func main(argc: i32, argv: i8**) -> i32 {
    if (argc == 1) {
        logo(argv[0]);
        return 0;
    }

    if (argc == 2 && (streq(argv[1], "-h") || streq(argv[1], "--help"))) {
        help();
        return 0;
    }
    if (argc == 2 && (streq(argv[1], "-v") || streq(argv[1], "--version"))) {
        print_version();
        return 0;
    }

    var option = cli_option::instance();
    for (var i: i32 = 1; i < argc; i += 1) {
        if (streq(argv[i], "-h") || streq(argv[i], "--help")) {
            help();
            return 0;
        } elsif (streq(argv[i], "-v") || streq(argv[i], "--version")) {
            print_version();
            return 0;
        } elsif (streq(argv[i], "-a") || streq(argv[i], "--ast")) {
            option.VIEW_AST = true;
        } elsif (streq(argv[i], "-s") || streq(argv[i], "--sema")) {
            option.VIEW_SEMA = true;
        } elsif (streq(argv[i], "-V") || streq(argv[i], "--verbose")) {
            option.VERBOSE = true;
        } elsif (streq(argv[i], "-g") || streq(argv[i], "--debug")) {
            option.DEBUG_MODE = true;
        } elsif (streq(argv[i], "-L") || streq(argv[i], "--library")) {
            if (i + 1 >= argc) {
                report_missing_given_info("library path");
            }
            if (option.library_path != nil) {
                report_multiple_given_info("library path");
            }
            option.library_path = argv[i + 1];
            if (strlen(option.library_path) == 0 || option.library_path[0] == '-') {
                report_invalid_given_info("library path", option.library_path);
            }
            i += 1;
        } elsif (streq(argv[i], "-o") || streq(argv[i], "--output")) {
            if (i + 1 >= argc) {
                report_missing_given_info("output file");
            }
            if (option.output_file != nil) {
                report_multiple_given_info("output file");
            }
            option.output_file = argv[i + 1];
            if (strlen(option.output_file) == 0 || option.output_file[0] == '-') {
                report_invalid_given_info("output file", option.output_file);
            }
            i += 1;
        } elsif (streq(argv[i], "--arch")) {
            if (i + 1 >= argc) {
                report_missing_given_info("arch");
            }
            if (option.arch != nil) {
                report_multiple_given_info("arch");
            }
            option.arch = argv[i + 1];
            if (strlen(option.arch) == 0 || option.arch[0] == '-') {
                report_invalid_given_info("arch", option.arch);
            }
            i += 1;
        } elsif (streq(argv[i], "--platform")) {
            if (i + 1 >= argc) {
                report_missing_given_info("platform");
            }
            if (option.platform != nil) {
                report_multiple_given_info("platform");
            }
            option.platform = argv[i + 1];
            if (strlen(option.platform) == 0 || option.platform[0] == '-') {
                report_invalid_given_info("platform", option.platform);
            }
            i += 1;
        } elsif (streq(argv[i], "--view-resolved-ast")) {
            option.VIEW_RESOLVED_AST = true;
        } elsif (streq(argv[i], "--view-type-replace")) {
            option.VIEW_TYPE_REPLACE_INFO = true;
        } elsif (streq(argv[i], "--view-unused-func")) {
            option.VIEW_UNUSED_FUNC = true;
        } elsif (streq(argv[i], "--view-defer-replace")) {
            option.VIEW_DEFER_REPLACE = true;
        } elsif (streq(argv[i], "--mir")) {
            option.VIEW_MIR = true;
        } elsif (streq(argv[i], "--dump-mir")) {
            option.DUMP_MIR = true;
        } elsif (streq(argv[i], "--sir")) {
            option.VIEW_SIR = true;
        } elsif (streq(argv[i], "-emit-llvm") || streq(argv[i], "--emit-llvm")) {
            option.EMIT_LLVM_ONLY = true;
        } elsif (streq(argv[i], "-emit-nasal") || streq(argv[i], "--emit-nasal")) {
            option.EMIT_NASAL_ONLY = true;
        } elsif (streq(argv[i], "-emit-markdown") || streq(argv[i], "--emit-markdown")) {
            option.EMIT_MARKDOWN_ONLY = true;
        } elsif (is_opt_option(argv[i])) {
            option.set_opt_level(argv[i]);
        } elsif (argv[i][0] == '-') {
            report_invalid_argument(argv[i]);
        } elsif (option.input_file == nil) {
            option.input_file = argv[i];
        } else {
            report_invalid_argument(argv[i]);
        }
    }

    if (option.input_file == nil) {
        io::stderr().red().out("Error:").reset()
                    .out(" no source file specified").endln();
        return -1;
    }

    // set default output file
    if (option.output_file == nil) {
        if (is_windows()) {
            option.output_file = "a.exe";
        } else {
            option.output_file = "a.out";
        }
    }

    // set default library path
    if (option.library_path == nil) {
        option.library_path = ".";
    }

    // clang may return 256 if error ocurred
    // when cast to u8 (on some platforms), this equals to returning 0
    // so we check the return code
    if (compile(option) != 0) {
        return -1;
    }
    return 0;
}
