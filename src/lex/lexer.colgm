use std::str::{ str };
use std::vec::{ vec };
use std::libc::{ malloc, realloc, free, exit };
use std::io::{ readfile_into_string, io };
use std::fs::{ fs };
use err::report::{ report };
use err::span::{ span };

pub enum tok_kind {
    tok_null,       // reserved
    tok_num,        // number literal
    tok_str,        // string literal
    tok_ch,         // character literal
    tok_id,         // identifier
    tok_true,       // keyword true
    tok_false,      // keyword false
    tok_use,        // keyword use
    tok_enum,       // keyword enum
    tok_for,        // keyword for
    tok_forindex,   // keyword forindex
    tok_foreach,    // keyword foreach
    tok_while,      // keyword while
    tok_var,        // keyword var
    tok_struct,     // keyword struct
    tok_pub,        // keyword pub
    tok_extern,     // keyword extern
    tok_const,      // keyword const
    tok_impl,       // keyword impl
    tok_func,       // keyword func
    tok_match,      // keyword match
    tok_break,      // keyword break
    tok_continue,   // keyword continue
    tok_return,     // keyword return
    tok_if,         // keyword if
    tok_elsif,      // keyword elsif
    tok_else,       // keyword else
    tok_nil,        // keyword nil
    tok_lparen,     // (
    tok_rparen,     // )
    tok_lbracket,   // [
    tok_rbracket,   // ]
    tok_lbrace,     // {
    tok_rbrace,     // }
    tok_semi,       // ;
    tok_op_and,     // conditional binary operator and/&&
    tok_op_or,      // conditional binary operator or/||
    tok_comma,      // ,
    tok_dot,        // .
    tok_ellipsis,   // ...
    tok_quesmark,   // ?
    tok_colon,      // :
    tok_coloncolon, // ::
    tok_add,        // +
    tok_sub,        // -
    tok_mul,        // *
    tok_div,        // /
    tok_rem,        // %
    tok_floater,    // bitwise operator not '~'
    tok_bit_and,    // bitwise operator &
    tok_bit_or,     // bitwise operator |
    tok_bit_xor,    // bitwise operator ^
    tok_op_not,     // conditional binary operator !
    tok_eq,         // =
    tok_addeq,      // +=
    tok_subeq,      // -=
    tok_muleq,      // *=
    tok_diveq,      // /=
    tok_remeq,      // %=
    tok_floatereq,  // bitwise operator ~=
    tok_bit_and_eq, // bitwise operator &=
    tok_bit_or_eq,  // bitwise operator |=
    tok_bit_xor_eq, // bitwise operator ^=
    tok_cmp_eq,     // ==
    tok_neq,        // !=
    tok_less,       // <
    tok_leq,        // <=
    tok_grt,        // >
    tok_geq,        // >=
    tok_arrow,      // ->
    tok_wide_arrow, // =>
    tok_sharp,      // #
    tok_eof         // <eof> token
}

pub struct token {
    kind: tok_kind,
    content: str*,
    location: span*
}

impl token {
    pub func new(kind: tok_kind, content: str*, loc: span*) -> token* {
        var res = token::__alloc__();
        res->kind = kind;
        res->content = content;
        res->location = loc;
        return res;
    }

    pub func copy(self) -> token* {
        var res = token::__alloc__();
        res->kind = self->kind;
        res->content = self->content->copy();
        res->location = self->location->copy();
        return res;
    }

    pub func delete(self) {
        self->content->delete();
        free(self->content => i8*);
        self->location->delete();
        free(self->location => i8*);
    }
}

pub struct lexer {
    err: report*,
    toks: vec<token>,
    pos: u64,
    filename: str,
    line: i64,
    column: i64
}

impl lexer {
    pub func new(e: report*) -> lexer* {
        var res = lexer::__alloc__();
        res->err = e;
        res->toks = vec<token>::instance();
        res->pos = 0;
        res->filename.init();
        res->line = 0;
        res->column = 0;
        return res;
    }

    pub func delete(self) {
        self->filename.delete();
        self->toks.delete();
    }

    pub func push_token(self, kind: tok_kind, content: str*, loc: span*) {
        var res = token {
            kind: kind,
            content: content,
            location: loc
        };
        // do token::copy, content and loc are all copied
        self->toks.push(res.__ptr__());
    }
}

impl lexer {
    func tok_kind_to_str(kind: tok_kind) -> const i8* {
        match(kind) {
            tok_kind::tok_null =>       return "[tok_null      ]";
            tok_kind::tok_num =>        return "[tok_num       ]";
            tok_kind::tok_str =>        return "[tok_str       ]";
            tok_kind::tok_ch =>         return "[tok_ch        ]";
            tok_kind::tok_id =>         return "[tok_id        ]";
            tok_kind::tok_true =>       return "[tok_true      ]";
            tok_kind::tok_false =>      return "[tok_false     ]";
            tok_kind::tok_use =>        return "[tok_use       ]";
            tok_kind::tok_enum =>       return "[tok_enum      ]";
            tok_kind::tok_for =>        return "[tok_for       ]";
            tok_kind::tok_forindex =>   return "[tok_forindex  ]";
            tok_kind::tok_foreach =>    return "[tok_foreach   ]";
            tok_kind::tok_while =>      return "[tok_while     ]";
            tok_kind::tok_var =>        return "[tok_var       ]";
            tok_kind::tok_struct =>     return "[tok_struct    ]";
            tok_kind::tok_pub =>        return "[tok_pub       ]";
            tok_kind::tok_extern =>     return "[tok_extern    ]";
            tok_kind::tok_const =>      return "[tok_const     ]";
            tok_kind::tok_impl =>       return "[tok_impl      ]";
            tok_kind::tok_func =>       return "[tok_func      ]";
            tok_kind::tok_match =>      return "[tok_match     ]";
            tok_kind::tok_break =>      return "[tok_break     ]";
            tok_kind::tok_continue =>   return "[tok_continue  ]";
            tok_kind::tok_return =>     return "[tok_return    ]";
            tok_kind::tok_if =>         return "[tok_if        ]";
            tok_kind::tok_elsif =>      return "[tok_elsif     ]";
            tok_kind::tok_else =>       return "[tok_else      ]";
            tok_kind::tok_nil =>        return "[tok_nil       ]";
            tok_kind::tok_lparen =>     return "[tok_lparen    ]";
            tok_kind::tok_rparen =>     return "[tok_rparen    ]";
            tok_kind::tok_lbracket =>   return "[tok_lbracket  ]";
            tok_kind::tok_rbracket =>   return "[tok_rbracket  ]";
            tok_kind::tok_lbrace =>     return "[tok_lbrace    ]";
            tok_kind::tok_rbrace =>     return "[tok_rbrace    ]";
            tok_kind::tok_semi =>       return "[tok_semi      ]";
            tok_kind::tok_op_and =>     return "[tok_op_and    ]";
            tok_kind::tok_op_or =>      return "[tok_op_or     ]";
            tok_kind::tok_comma =>      return "[tok_comma     ]";
            tok_kind::tok_dot =>        return "[tok_dot       ]";
            tok_kind::tok_ellipsis =>   return "[tok_ellipsis  ]";
            tok_kind::tok_quesmark =>   return "[tok_quesmark  ]";
            tok_kind::tok_colon =>      return "[tok_colon     ]";
            tok_kind::tok_coloncolon => return "[tok_coloncolon]";
            tok_kind::tok_add =>        return "[tok_add       ]";
            tok_kind::tok_sub =>        return "[tok_sub       ]";
            tok_kind::tok_mul =>        return "[tok_mul       ]";
            tok_kind::tok_div =>        return "[tok_div       ]";
            tok_kind::tok_rem =>        return "[tok_rem       ]";
            tok_kind::tok_floater =>    return "[tok_floater   ]";
            tok_kind::tok_bit_and =>    return "[tok_bit_and   ]";
            tok_kind::tok_bit_or =>     return "[tok_bit_or    ]";
            tok_kind::tok_bit_xor =>    return "[tok_bit_xor   ]";
            tok_kind::tok_op_not =>     return "[tok_op_not    ]";
            tok_kind::tok_eq =>         return "[tok_eq        ]";
            tok_kind::tok_addeq =>      return "[tok_addeq     ]";
            tok_kind::tok_subeq =>      return "[tok_subeq     ]";
            tok_kind::tok_muleq =>      return "[tok_muleq     ]";
            tok_kind::tok_diveq =>      return "[tok_diveq     ]";
            tok_kind::tok_remeq =>      return "[tok_remeq     ]";
            tok_kind::tok_floatereq =>  return "[tok_floatereq ]";
            tok_kind::tok_bit_and_eq => return "[tok_bit_and_eq]";
            tok_kind::tok_bit_or_eq =>  return "[tok_bit_or_eq ]";
            tok_kind::tok_bit_xor_eq => return "[tok_bit_xor_eq]";
            tok_kind::tok_cmp_eq =>     return "[tok_cmp_eq    ]";
            tok_kind::tok_neq =>        return "[tok_neq       ]";
            tok_kind::tok_less =>       return "[tok_less      ]";
            tok_kind::tok_leq =>        return "[tok_leq       ]";
            tok_kind::tok_grt =>        return "[tok_grt       ]";
            tok_kind::tok_geq =>        return "[tok_geq       ]";
            tok_kind::tok_arrow =>      return "[tok_arrow     ]";
            tok_kind::tok_wide_arrow => return "[tok_wide_arrow]";
            tok_kind::tok_sharp =>      return "[tok_sharp     ]";
            tok_kind::tok_eof =>        return "[tok_eof       ]";
        }
        return "[unknown token ]";
    }
}

impl lexer {
    func is_note(pos: u64, src: str*) -> bool {
        if (src->get(pos)!='/') {
            return false;
        }
        if (pos + 1 < src->size &&
            src->get(pos + 1)=='/') {
            return true;
        }
        return false;
    }

    func is_identifier_head(c: i8) -> bool {
        return ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z') || (c == '_');
    }

    func is_identifier_body(c: i8) -> bool {
        return lexer::is_identifier_head(c) || ('0' <= c && c <= '9');
    }

    func is_single_char_token(c: i8) -> bool {
        return c == '(' || c == ')' || c == '[' || c == ']' ||
               c == '{' || c == '}' || c == ';' || c == ',' ||
               c == '?' || c == '#';
    }

    func is_digit(c: i8) -> bool {
        return '0' <= c && c <= '9';
    }

    func is_hex(c: i8) -> bool {
        return ('a' <= c && c <= 'f') ||
               ('A' <= c && c <= 'F') ||
               lexer::is_digit(c);
    }

    func is_oct(c: i8) -> bool {
        return '0' <= c && c <= '7';
    }

    func need_lookahead_eq(c: i8) -> bool {
        return c == '+' || c == '-' || c == '*' || c == '/' ||
               c == '%' || c == '~' || c == '^' || c == '=' ||
               c == '<' || c == '>' || c == '!';
    }

    func need_lookahead_other(c: i8) -> bool {
        return c == '&' || c == '|';
    }

    func is_arrow(pos: u64, src: str*) -> bool {
        if (src->get(pos)!='-') {
            return false;
        }
        if (pos + 1 < src->size && src->get(pos + 1)=='>') {
            return true;
        }
        return false;
    }

    func is_wide_arrow(pos: u64, src: str*) -> bool {
        if (src->get(pos)!='=') {
            return false;
        }
        if (pos + 1 < src->size && src->get(pos + 1)=='>') {
            return true;
        }
        return false;
    }

    func is_str(c: i8) -> bool {
        return c == '"' || c == '\'';
    }

    func check_id_kind(src: str*) -> tok_kind {
        if (src->eq_const("true")) {
            return tok_kind::tok_true;
        } elsif (src->eq_const("false")) {
            return tok_kind::tok_false;
        } elsif (src->eq_const("use")) {
            return tok_kind::tok_use;
        } elsif (src->eq_const("enum")) {
            return tok_kind::tok_enum;
        } elsif (src->eq_const("for")) {
            return tok_kind::tok_for;
        } elsif (src->eq_const("forindex")) {
            return tok_kind::tok_forindex;
        } elsif (src->eq_const("foreach")) {
            return tok_kind::tok_foreach;
        } elsif (src->eq_const("while")) {
            return tok_kind::tok_while;
        } elsif (src->eq_const("var")) {
            return tok_kind::tok_var;
        } elsif (src->eq_const("struct")) {
            return tok_kind::tok_struct;
        } elsif (src->eq_const("pub")) {
            return tok_kind::tok_pub;
        } elsif (src->eq_const("extern")) {
            return tok_kind::tok_extern;
        } elsif (src->eq_const("const")) {
            return tok_kind::tok_const;
        } elsif (src->eq_const("impl")) {
            return tok_kind::tok_impl;
        } elsif (src->eq_const("func")) {
            return tok_kind::tok_func;
        } elsif (src->eq_const("match")) {
            return tok_kind::tok_match;
        } elsif (src->eq_const("break")) {
            return tok_kind::tok_break;
        } elsif (src->eq_const("continue")) {
            return tok_kind::tok_continue;
        } elsif (src->eq_const("return")) {
            return tok_kind::tok_return;
        } elsif (src->eq_const("if")) {
            return tok_kind::tok_if;
        } elsif (src->eq_const("elsif")) {
            return tok_kind::tok_elsif;
        } elsif (src->eq_const("else")) {
            return tok_kind::tok_else;
        } elsif (src->eq_const("nil")) {
            return tok_kind::tok_nil;
        } elsif (src->eq_const("and")) {
            return tok_kind::tok_op_and;
        } elsif (src->eq_const("or")) {
            return tok_kind::tok_op_or;
        }
        return tok_kind::tok_id;
    }
}

impl lexer {
    func generate_single_char_token(self, src: str*) {
        var loc = span::instance();
        loc.file.copy_const(self->filename.c_str);
        loc.begin_line = self->line;
        loc.begin_column = self->column;

        var tmp = str::instance();
        var ch = src->get(self->pos);
        tmp.append_char(ch);

        self->pos += 1;
        self->column += 1;

        loc.end_line = self->line;
        loc.end_column = self->column;

        if (ch == '(') {
            self->push_token(tok_kind::tok_lparen, tmp.__ptr__(), loc.__ptr__());
        } elsif (ch == ')') {
            self->push_token(tok_kind::tok_rparen, tmp.__ptr__(), loc.__ptr__());
        } elsif (ch == '[') {
            self->push_token(tok_kind::tok_lbracket, tmp.__ptr__(), loc.__ptr__());
        } elsif (ch == ']') {
            self->push_token(tok_kind::tok_rbracket, tmp.__ptr__(), loc.__ptr__());
        } elsif (ch == '{') {
            self->push_token(tok_kind::tok_lbrace, tmp.__ptr__(), loc.__ptr__());
        } elsif (ch == '}') {
            self->push_token(tok_kind::tok_rbrace, tmp.__ptr__(), loc.__ptr__());
        } elsif (ch == ';') {
            self->push_token(tok_kind::tok_semi, tmp.__ptr__(), loc.__ptr__());
        } elsif (ch == ',') {
            self->push_token(tok_kind::tok_comma, tmp.__ptr__(), loc.__ptr__());
        } elsif (ch == '?') {
            self->push_token(tok_kind::tok_quesmark, tmp.__ptr__(), loc.__ptr__());
        } elsif (ch == '#') {
            self->push_token(tok_kind::tok_sharp, tmp.__ptr__(), loc.__ptr__());
        }

        loc.delete();
        tmp.delete();
    }

    func generate_maybe_need_eq_oprs(self, src: str*) {
        var loc = span::instance();
        loc.file.copy_const(self->filename.c_str);
        loc.begin_line = self->line;
        loc.begin_column = self->column;

        var tmp = str::instance();
        tmp.append_char(src->get(self->pos));
        self->pos += 1;
        if (self->pos < src->size && src->get(self->pos) == '=') {
            tmp.append_char(src->get(self->pos));
            self->pos += 1;
        }

        self->column += tmp.size => i64;
        loc.end_line = self->line;
        loc.end_column = self->column;

        if (tmp.eq_const("+")) {
            self->push_token(tok_kind::tok_add, tmp.__ptr__(), loc.__ptr__());
        } elsif (tmp.eq_const("+=")) {
            self->push_token(tok_kind::tok_addeq, tmp.__ptr__(), loc.__ptr__());
        } elsif (tmp.eq_const("-")) {
            self->push_token(tok_kind::tok_sub, tmp.__ptr__(), loc.__ptr__());
        } elsif (tmp.eq_const("-=")) {
            self->push_token(tok_kind::tok_subeq, tmp.__ptr__(), loc.__ptr__());
        } elsif (tmp.eq_const("*")) {
            self->push_token(tok_kind::tok_mul, tmp.__ptr__(), loc.__ptr__());
        } elsif (tmp.eq_const("*=")) {
            self->push_token(tok_kind::tok_muleq, tmp.__ptr__(), loc.__ptr__());
        } elsif (tmp.eq_const("/")) {
            self->push_token(tok_kind::tok_div, tmp.__ptr__(), loc.__ptr__());
        } elsif (tmp.eq_const("/=")) {
            self->push_token(tok_kind::tok_diveq, tmp.__ptr__(), loc.__ptr__());
        } elsif (tmp.eq_const("%")) {
            self->push_token(tok_kind::tok_rem, tmp.__ptr__(), loc.__ptr__());
        } elsif (tmp.eq_const("%=")) {
            self->push_token(tok_kind::tok_remeq, tmp.__ptr__(), loc.__ptr__());
        } elsif (tmp.eq_const("~")) {
            self->push_token(tok_kind::tok_floater, tmp.__ptr__(), loc.__ptr__());
        } elsif (tmp.eq_const("~=")) {
            self->push_token(tok_kind::tok_floatereq, tmp.__ptr__(), loc.__ptr__());
        } elsif (tmp.eq_const("^")) {
            self->push_token(tok_kind::tok_bit_xor, tmp.__ptr__(), loc.__ptr__());
        } elsif (tmp.eq_const("^=")) {
            self->push_token(tok_kind::tok_bit_xor_eq, tmp.__ptr__(), loc.__ptr__());
        } elsif (tmp.eq_const("=")) {
            self->push_token(tok_kind::tok_eq, tmp.__ptr__(), loc.__ptr__());
        } elsif (tmp.eq_const("==")) {
            self->push_token(tok_kind::tok_cmp_eq, tmp.__ptr__(), loc.__ptr__());
        } elsif (tmp.eq_const("<")) {
            self->push_token(tok_kind::tok_less, tmp.__ptr__(), loc.__ptr__());
        } elsif (tmp.eq_const("<=")) {
            self->push_token(tok_kind::tok_leq, tmp.__ptr__(), loc.__ptr__());
        } elsif (tmp.eq_const(">")) {
            self->push_token(tok_kind::tok_grt, tmp.__ptr__(), loc.__ptr__());
        } elsif (tmp.eq_const(">=")) {
            self->push_token(tok_kind::tok_geq, tmp.__ptr__(), loc.__ptr__());
        } elsif (tmp.eq_const("!")) {
            self->push_token(tok_kind::tok_op_not, tmp.__ptr__(), loc.__ptr__());
        } elsif (tmp.eq_const("!=")) {
            self->push_token(tok_kind::tok_neq, tmp.__ptr__(), loc.__ptr__());
        }

        loc.delete();
        tmp.delete();
    }

    func generate_lookahead_other(self, src: str*) {
        var loc = span::instance();
        loc.file.copy_const(self->filename.c_str);
        loc.begin_line = self->line;
        loc.begin_column = self->column;

        var tmp = str::instance();
        var ch = src->get(self->pos);
        tmp.append_char(ch);
        self->pos += 1;
        if (ch == '&' && self->pos < src->size) {
            if (src->get(self->pos) == '&' || src->get(self->pos) == '=') {
                tmp.append_char(src->get(self->pos));
                self->pos += 1;
            }
        } elsif (ch == '|' && self->pos < src->size) {
            if (src->get(self->pos) == '|' || src->get(self->pos) == '=') {
                tmp.append_char(src->get(self->pos));
                self->pos += 1;
            }
        }

        self->column += tmp.size => i64;
        loc.end_line = self->line;
        loc.end_column = self->column;

        if (tmp.eq_const("&")) {
            self->push_token(tok_kind::tok_bit_and, tmp.__ptr__(), loc.__ptr__());
        } elsif (tmp.eq_const("&=")) {
            self->push_token(tok_kind::tok_bit_and_eq, tmp.__ptr__(), loc.__ptr__());
        } elsif (tmp.eq_const("&&")) {
            self->push_token(tok_kind::tok_op_and, tmp.__ptr__(), loc.__ptr__());
        } elsif (tmp.eq_const("|")) {
            self->push_token(tok_kind::tok_bit_or, tmp.__ptr__(), loc.__ptr__());
        } elsif (tmp.eq_const("|=")) {
            self->push_token(tok_kind::tok_bit_or_eq, tmp.__ptr__(), loc.__ptr__());
        } elsif (tmp.eq_const("||")) {
            self->push_token(tok_kind::tok_op_or, tmp.__ptr__(), loc.__ptr__());
        }

        loc.delete();
        tmp.delete();
    }

    func generate_arrow(self, src: str*) {
        var loc = span::instance();
        loc.file.copy_const(self->filename.c_str);
        loc.begin_line = self->line;
        loc.begin_column = self->column;

        var tmp = str::instance();
        tmp.append_char(src->get(self->pos));
        self->pos += 1;
        tmp.append_char(src->get(self->pos));
        self->pos += 1;

        self->column += 2;
        loc.end_line = self->line;
        loc.end_column = self->column;

        if (tmp.get(0)=='-') {
            self->push_token(
                tok_kind::tok_arrow,
                tmp.__ptr__(),
                loc.__ptr__()
            );
        } else {
            self->push_token(
                tok_kind::tok_wide_arrow,
                tmp.__ptr__(),
                loc.__ptr__()
            );
        }

        loc.delete();
        tmp.delete();
    }

    func generate_identifier(self, src: str*) {
        var loc = span::instance();
        loc.file.copy_const(self->filename.c_str);
        loc.begin_line = self->line;
        loc.begin_column = self->column;

        var tmp = str::instance();
        while(self->pos < src->size &&
              lexer::is_identifier_body(src->get(self->pos))) {
            tmp.append_char(src->get(self->pos));
            self->pos += 1;
        }

        self->column += tmp.size => i64;
        loc.end_line = self->line;
        loc.end_column = self->column;

        self->push_token(
            lexer::check_id_kind(tmp.__ptr__()),
            tmp.__ptr__(),
            loc.__ptr__()
        );

        loc.delete();
        tmp.delete();
    }

    func generate_number(self, src: str*) {
        var loc = span::instance();
        loc.file.copy_const(self->filename.c_str);
        loc.begin_line = self->line;
        loc.begin_column = self->column;

        var tmp = str::instance();
        if (src->get(self->pos)=='0' &&
            self->pos + (1) < src->size &&
            src->get(self->pos + (1)) == 'x') {
            tmp.append_i8_vec("0x");
            self->pos += 2;
            while(self->pos < src->size && lexer::is_hex(src->get(self->pos))) {
                tmp.append_char(src->get(self->pos));
                self->pos += 1;
            }
            if (tmp.size > 2) {
                self->column += tmp.size => i64;
                loc.end_line = self->line;
                loc.end_column = self->column;
                self->push_token(
                    tok_kind::tok_num,
                    tmp.__ptr__(),
                    loc.__ptr__()
                );
            } else {
                self->column += tmp.size => i64;
                loc.end_line = self->line;
                loc.end_column = self->column;
                self->err->error(loc.__ptr__(), "invalid hex number.");
            }

            loc.delete();
            tmp.delete();
            return;
        }
        if (src->get(self->pos)=='0' &&
            self->pos + 1 < src->size &&
            src->get(self->pos + 1) == 'o') {
            tmp.append_i8_vec("0o");
            self->pos += 2;
            while(self->pos < src->size && lexer::is_oct(src->get(self->pos))) {
                tmp.append_char(src->get(self->pos));
                self->pos += 1;
            }
            if (tmp.size > 2) {
                self->column += tmp.size => i64;
                loc.end_line = self->line;
                loc.end_column = self->column;
                self->push_token(
                    tok_kind::tok_num,
                    tmp.__ptr__(),
                    loc.__ptr__()
                );
            } else {
                self->column += tmp.size => i64;
                loc.end_line = self->line;
                loc.end_column = self->column;
                self->err->error(loc.__ptr__(), "invalid oct number.");
            }

            loc.delete();
            tmp.delete();
            return;
        }

        // get integer part
        tmp.append_char(src->get(self->pos));
        self->pos += 1;
        while(self->pos < src->size && lexer::is_digit(src->get(self->pos))) {
            tmp.append_char(src->get(self->pos));
            self->pos += 1;
        }

        // get float part
        if (self->pos < src->size && src->get(self->pos) == '.') {
            var lookahead_pos = self->pos + 1;

            // just return, this dot is not part of number
            if (lookahead_pos >= src->size) {
                self->column += tmp.size => i64;
                loc.end_line = self->line;
                loc.end_column = self->column;
                self->push_token(
                    tok_kind::tok_num,
                    tmp.__ptr__(),
                    loc.__ptr__()
                );

                loc.delete();
                tmp.delete();
                return;
            }

            var lookahead_ch = src->get(lookahead_pos);

            // just return, this dot is not part of number
            if (!lexer::is_digit(lookahead_ch)) {
                self->column += tmp.size => i64;
                loc.end_line = self->line;
                loc.end_column = self->column;
                self->push_token(
                    tok_kind::tok_num,
                    tmp.__ptr__(),
                    loc.__ptr__()
                );

                loc.delete();
                tmp.delete();
                return;
            }

            tmp.append_char('.');
            self->pos += 1;
            while(self->pos < src->size && lexer::is_digit(src->get(self->pos))) {
                tmp.append_char(src->get(self->pos));
                self->pos += 1;
            }
        }

        // get F-E part
        if (self->pos < src->size &&
            (src->get(self->pos) == 'e' || src->get(self->pos) == 'E')) {
            // just return
            if (self->pos + 1 >= src->size) {
                self->column += tmp.size => i64;
                loc.end_line = self->line;
                loc.end_column = self->column;
                self->push_token(
                    tok_kind::tok_num,
                    tmp.__ptr__(),
                    loc.__ptr__()
                );

                loc.delete();
                tmp.delete();
                return;
            }

            var lookahead_pos = self->pos + 1;

            if (lexer::is_digit(src->get(lookahead_pos))) {
                tmp.append_char(src->get(self->pos));
                self->pos += 1;
                while(self->pos < src->size && lexer::is_digit(src->get(self->pos))) {
                    tmp.append_char(src->get(self->pos));
                    self->pos += 1;
                }
                self->column += tmp.size => i64;
                loc.end_line = self->line;
                loc.end_column = self->column;
                self->push_token(
                    tok_kind::tok_num,
                    tmp.__ptr__(),
                    loc.__ptr__()
                );

                loc.delete();
                tmp.delete();
                return;
            }

            if ((src->get(lookahead_pos)=='-' || src->get(lookahead_pos)=='+') &&
                lookahead_pos + 1 < src->size &&
                lexer::is_digit(src->get(lookahead_pos + 1))) {
                tmp.append_char(src->get(self->pos));
                tmp.append_char(src->get(self->pos + 1));
                self->pos += 2;
                while(self->pos < src->size && lexer::is_digit(src->get(self->pos))) {
                    tmp.append_char(src->get(self->pos));
                    self->pos += 1;
                }
                self->column += tmp.size => i64;
                loc.end_line = self->line;
                loc.end_column = self->column;
                self->push_token(
                    tok_kind::tok_num,
                    tmp.__ptr__(),
                    loc.__ptr__()
                );

                loc.delete();
                tmp.delete();
                return;
            }
        }

        self->column += tmp.size => i64;
        loc.end_line = self->line;
        loc.end_column = self->column;
        self->push_token(
            tok_kind::tok_num,
            tmp.__ptr__(),
            loc.__ptr__()
        );

        loc.delete();
        tmp.delete();
    }

    func generate_string(self, src: str*) {
        var loc = span::new();
        loc->file.copy_const(self->filename.c_str);
        loc->begin_line = self->line;
        loc->begin_column = self->column;

        var quote_type = src->get(self->pos);
        var tmp = str::new();
        // skip first quote
        self->pos += 1;
        self->column += 1;

        while(self->pos < src->size && src->get(self->pos) != quote_type) {
            var this_ch = src->get(self->pos);
            if (this_ch=='\n') {
                self->line += 1;
                self->column = 0;
            } else {
                self->column += 1;
            }

            if (this_ch=='\\' && self->pos + 1 < src->size) {
                self->pos += 1;
                var next_ch = src->get(self->pos);
                if (next_ch=='0') {
                    tmp->append_char('\0');
                } elsif (next_ch=='a') {
                    tmp->append_char('\a');
                } elsif (next_ch=='b') {
                    tmp->append_char('\b');
                } elsif (next_ch=='e') {
                    tmp->append_char('\e');
                } elsif (next_ch=='t') {
                    tmp->append_char('\t');
                } elsif (next_ch=='n') {
                    tmp->append_char('\n');
                } elsif (next_ch=='v') {
                    tmp->append_char('\v');
                } elsif (next_ch=='f') {
                    tmp->append_char('\f');
                } elsif (next_ch=='r') {
                    tmp->append_char('\r');
                } elsif (next_ch=='?') {
                    tmp->append_char('\?');
                } elsif (next_ch=='\\') {
                    tmp->append_char('\\');
                } elsif (next_ch=='\'') {
                    tmp->append_char('\'');
                } elsif (next_ch=='\"') {
                    tmp->append_char('\"');
                } else {
                    tmp->append_char(next_ch);
                }
                if (next_ch=='\n') {
                    self->line += 1;
                    self->column = 0;
                } else {
                    self->column += 1;
                }
            } else {
                tmp->append_char(this_ch);
            }
            self->pos += 1;
        }
        if (self->pos >= src->size) {
            loc->end_line = self->line;
            loc->end_column = self->column;
            self->err->error(loc, "get <eof> when generating string.");
            loc->delete();
            free(loc => i8*);
            return;
        }

        // skip last quote
        self->pos += 1;
        self->column += 1;

        loc->end_line = self->line;
        loc->end_column = self->column;

        if (quote_type == '"') {
            self->push_token(tok_kind::tok_str, tmp, loc);
        } else {
            if (tmp->size != 1) {
                self->err->error(loc, "should only contain one character.");
            }
            self->push_token(tok_kind::tok_ch, tmp, loc);
        }
    }

    func generate_coloncolon(self, src: str*) {
        var loc = span::instance();
        loc.file.copy_const(self->filename.c_str);
        loc.begin_line = self->line;
        loc.begin_column = self->column;

        var tmp = str::instance();
        tmp.append_char(':');
        self->pos += 1;
        self->column += 1;

        if (self->pos < src->size && src->get(self->pos) == ':') {
            tmp.append_char(':');
            self->pos += 1;
            self->column += 1;
            loc.end_line = self->line;
            loc.end_column = self->column;

            self->push_token(
                tok_kind::tok_coloncolon,
                tmp.__ptr__(),
                loc.__ptr__()
            );
        } else {
            loc.end_line = self->line;
            loc.end_column = self->column;
            self->push_token(
                tok_kind::tok_colon,
                tmp.__ptr__(),
                loc.__ptr__()
            );
        }

        loc.delete();
        tmp.delete();
    }

    func generate_ellipsis(self, src: str*) {
        var loc = span::instance();
        loc.file.copy_const(self->filename.c_str);
        loc.begin_line = self->line;
        loc.begin_column = self->column;

        var tmp = str::instance();
        tmp.append_char('.');
        self->pos += 1;
        self->column += 1;

        if (self->pos + 1 < src->size &&
            src->get(self->pos) == '.' &&
            src->get(self->pos + 1) == '.') {
            tmp.append_char('.')->append_char('.');
            self->pos += 2;
            self->column += 2;
            loc.end_line = self->line;
            loc.end_column = self->column;

            self->push_token(
                tok_kind::tok_ellipsis,
                tmp.__ptr__(),
                loc.__ptr__()
            );
        } else {
            loc.end_line = self->line;
            loc.end_column = self->column;

            self->push_token(
                tok_kind::tok_dot,
                tmp.__ptr__(),
                loc.__ptr__()
            );
        }

        loc.delete();
        tmp.delete();
    }

    func skip_note(self, src: str*) {
        while(self->pos < src->size && src->get(self->pos) != '\n') {
            self->pos += 1;
            self->column += 1;
        }
    }

    func generate_eof_token(self) {
        var eof_span = span::instance();
        eof_span.file.copy_const(self->filename.c_str);
        eof_span.begin_line = self->line;
        eof_span.begin_column = self->column;
        eof_span.end_line = self->line;
        eof_span.end_column = self->column;

        var eof_content = str::instance();
        eof_content.append_i8_vec("<eof>");
        self->push_token(
            tok_kind::tok_eof,
            eof_content.__ptr__(),
            eof_span.__ptr__()
        );

        eof_span.delete();
        eof_content.delete();
    }

    pub func scan(self, filename: i8*) {
        self->filename.clear();
        self->filename.copy_const(filename);
        self->err->load_file_source(filename);

        var src = str::new();
        readfile_into_string(filename, src);

        self->pos = 0;
        self->line = 0;
        self->column = 0;
        while(self->pos < src->size) {
            if (lexer::is_note(self->pos, src)) {
                self->skip_note(src);
            } elsif (lexer::is_identifier_head(src->get(self->pos))) {
                self->generate_identifier(src);
            } elsif (lexer::is_digit(src->get(self->pos))) {
                self->generate_number(src);
            } elsif (lexer::is_str(src->get(self->pos))) {
                self->generate_string(src);
            } elsif (lexer::is_arrow(self->pos, src) ||
                     lexer::is_wide_arrow(self->pos, src)) {
                // need to be put before normal operator scan process
                // otherwise `=>` will be recognized as `=` `>`
                self->generate_arrow(src);
            } elsif (lexer::is_single_char_token(src->get(self->pos))) {
                self->generate_single_char_token(src);
            } elsif (lexer::need_lookahead_eq(src->get(self->pos))) {
                self->generate_maybe_need_eq_oprs(src);
            } elsif (lexer::need_lookahead_other(src->get(self->pos))) {
                self->generate_lookahead_other(src);
            } elsif (src->get(self->pos)==':') {
                self->generate_coloncolon(src);
            } elsif (src->get(self->pos)=='.') {
                self->generate_ellipsis(src);
            } else {
                if (src->get(self->pos)=='\n') {
                    self->line += 1;
                    self->column = 0;
                } else {
                    self->column += 1;
                }
                self->pos += 1;
            }
        }

        self->generate_eof_token();

        // lifetime end for src
        src->delete();
        free(src => i8*);
    }

    pub func dump(self) {
        var index: u64 = 0;
        while(index < self->toks.size) {
            var loc = self->toks.get(index)->location;
            io::stderr().out(lexer::tok_kind_to_str(self->toks.get(index)->kind))
                        .out(" [").out(loc->file.c_str)
                        .out(":").out_i64(loc->begin_line + 1)
                        .out(":").out_i64(loc->begin_column + 1)
                        .out(" -> ").out(loc->file.c_str)
                        .out(":").out_i64(loc->end_line + 1)
                        .out(":").out_i64(loc->end_column + 1)
                        .out("] \"")
                        .out(self->toks.get(index)->content->c_str)
                        .out("\"")
                        .endln();
            index += 1;
        }
    }
}
