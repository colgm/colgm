use err::span::{ span };
use err::panic::{ unreachable };

use std::libc::{ free };
use std::str::{ str };
use std::vec::{ vec, primitive_vec };
use std::ptr::{ ptr };
use std::io::{ io };
use package::{ package };

use sema::type::{ type };

pub enum mir_kind {
    mir_none,
    mir_block,
    mir_unary,
    mir_binary,
    mir_type_convert,
    mir_nil,
    mir_number,
    mir_string,
    mir_char,
    mir_bool,
    mir_array,
    mir_struct_init,
    mir_call,
    mir_call_id,
    mir_call_index,
    mir_call_func,
    mir_get_field,
    mir_get_path,
    mir_ptr_get_field,
    mir_define,
    mir_assign,
    mir_if,
    mir_branch,
    mir_switch_case,
    mir_switch,
    mir_break,
    mir_continue,
    mir_loop,
    mir_return
}

pub enum mir_unary_opr {
    neg,
    bnot,
    lnot
}

pub enum mir_binary_opr {
    add,
    sub,
    mul,
    div,
    rem,
    cmpeq,
    cmpne,
    less,
    leq,
    grt,
    geq,
    cmpand,
    cmpor,
    band,
    bor,
    bxor
}

pub enum mir_assign_opr {
    eq,
    addeq,
    subeq,
    multeq,
    diveq,
    remeq,
    andeq,
    xoreq,
    oreq
}

pub struct mir {
    kind: mir_kind,
    location: span
}

impl mir {
    pub func instance(k: mir_kind, l: span*) -> mir {
        return mir { kind: k, location: l->copy_instance() };
    }

    pub func delete(self) {
        self->location.delete();
        match (self->kind) {
            mir_kind::mir_block => {
                var n = self => mir_block*;
                n->delete();
            }
            mir_kind::mir_unary => {
                var n = self => mir_unary*;
                n->delete();
            }
            mir_kind::mir_binary => {
                var n = self => mir_binary*;
                n->delete();
            }
            mir_kind::mir_type_convert => {
                var n = self => mir_type_convert*;
                n->delete();
            }
            mir_kind::mir_nil => {
                var n = self => mir_nil*;
                n->delete();
            }
            mir_kind::mir_number => {
                var n = self => mir_number*;
                n->delete();
            }
            mir_kind::mir_string => {
                var n = self => mir_string*;
                n->delete();
            }
            mir_kind::mir_char => {
                var n = self => mir_char*;
                n->delete();
            }
            mir_kind::mir_bool => {
                var n = self => mir_bool*;
                n->delete();
            }
            mir_kind::mir_array => {
                var n = self => mir_array*;
                n->delete();
            }
            mir_kind::mir_struct_init => {
                var n = self => mir_struct_init*;
                n->delete();
            }
            mir_kind::mir_call => {
                var n = self => mir_call*;
                n->delete();
            }
            mir_kind::mir_call_id => {
                var n = self => mir_call_id*;
                n->delete();
            }
            mir_kind::mir_call_index => {
                var n = self => mir_call_index*;
                n->delete();
            }
            mir_kind::mir_call_func => {
                var n = self => mir_call_func*;
               n->delete();
            }
            mir_kind::mir_get_field => {
                var n = self => mir_get_field*;
                n->delete();
            }
            mir_kind::mir_get_path => {
                var n = self => mir_get_path*;
                n->delete();
            }
            mir_kind::mir_ptr_get_field => {
                var n = self => mir_ptr_get_field*;
                n->delete();
            }
            mir_kind::mir_define => {
                var n = self => mir_define*;
                n->delete();
            }
            mir_kind::mir_assign => {
                var n = self => mir_assign*;
                n->delete();
            }
            mir_kind::mir_if => {
                var n = self => mir_if*;
                n->delete();
            }
            mir_kind::mir_branch => {
                var n = self => mir_branch*;
                n->delete();
            }
            mir_kind::mir_switch_case => {
                var n = self => mir_switch_case*;
                n->delete();
            }
            mir_kind::mir_switch => {
                var n = self => mir_switch*;
                n->delete();
            }
            mir_kind::mir_break => {
                var n = self => mir_break*;
                n->delete();
            }
            mir_kind::mir_continue => {
                var n = self => mir_continue*;
                n->delete();
            }
            mir_kind::mir_loop => {
                var n = self => mir_loop*;
                n->delete();
            }
            mir_kind::mir_return => {
                var n = self => mir_return*;
                n->delete();
            }
            _ => { unreachable(); }
        }
    }

    pub func dump(self, out: io, pkg: package*, depth: u32) {
        for (var i: u32 = 0; i < depth; i = i + 1) {
            out.out("  ");
        }
        out.out("[0x").out_hex(self => i64).out("]----");
        match (self->kind) {
            mir_kind::mir_block => {
                var n = self => mir_block*;
                n->dump(out, pkg, depth);
            }
            mir_kind::mir_unary => {
                var n = self => mir_unary*;
                n->dump(out, pkg, depth);
            }
            mir_kind::mir_binary => {
                var n = self => mir_binary*;
                n->dump(out, pkg, depth);
            }
            mir_kind::mir_type_convert => {
                var n = self => mir_type_convert*;
                n->dump(out, pkg, depth);
            }
            mir_kind::mir_nil => {
                var n = self => mir_nil*;
                n->dump(out, pkg, depth);
            }
            mir_kind::mir_number => {
                var n = self => mir_number*;
                n->dump(out, pkg, depth);
            }
            mir_kind::mir_string => {
                var n = self => mir_string*;
                n->dump(out, pkg, depth);
            }
            mir_kind::mir_char => {
                var n = self => mir_char*;
                n->dump(out, pkg, depth);
            }
            mir_kind::mir_bool => {
                var n = self => mir_bool*;
                n->dump(out, pkg, depth);
            }
            mir_kind::mir_array => {
                var n = self => mir_array*;
                n->dump(out, pkg, depth);
            }
            mir_kind::mir_struct_init => {
                var n = self => mir_struct_init*;
                n->dump(out, pkg, depth);
            }
            mir_kind::mir_call => {
                var n = self => mir_call*;
                n->dump(out, pkg, depth);
            }
            mir_kind::mir_call_id => {
                var n = self => mir_call_id*;
                n->dump(out, pkg, depth);
            }
            mir_kind::mir_call_index => {
                var n = self => mir_call_index*;
                n->dump(out, pkg, depth);
            }
            mir_kind::mir_call_func => {
                var n = self => mir_call_func*;
                n->dump(out, pkg, depth);
            }
            mir_kind::mir_get_field => {
                var n = self => mir_get_field*;
                n->dump(out, pkg, depth);
            }
            mir_kind::mir_get_path => {
                var n = self => mir_get_path*;
                n->dump(out, pkg, depth);
            }
            mir_kind::mir_ptr_get_field => {
                var n = self => mir_ptr_get_field*;
                n->dump(out, pkg, depth);
            }
            mir_kind::mir_break => {
                var n = self => mir_break*;
                n->dump(out, pkg, depth);
            }
            mir_kind::mir_continue => {
                var n = self => mir_continue*;
                n->dump(out, pkg, depth);
            }
            mir_kind::mir_return => {
                var n = self => mir_return*;
                n->dump(out, pkg, depth);
            }
            _ => {
                out.out("unknown mir").endln();
            }
        }
    }
}

pub struct mir_block {
    base: mir,
    content: primitive_vec<ptr<mir>>
}

impl mir_block {
    pub func new(l: span*) -> mir_block* {
        var res = mir_block::__alloc__();
        res->base = mir::instance(mir_kind::mir_block, l);
        res->content = primitive_vec<ptr<mir>>::instance();
        return res;
    }

    pub func delete(self) {
        for (var i = self->content.iter(); !i.is_end(); i = i.next()) {
            var item = i.get().unwrap();
            item->delete();
            free(item => i8*);
        }
        self->content.delete();
    }

    pub func dump(self, out: io, pkg: package*, depth: u32) {
        out.out("mir_block").endln();
        for (var i = self->content.iter(); !i.is_end(); i = i.next()) {
            var item = i.get().unwrap();
            item->dump(out, pkg, depth + 1);
        }
    }
}

pub struct mir_unary {
    base: mir,
    op: mir_unary_opr,
    resolved_type: type,
    value: mir_block*
}

impl mir_unary {
    pub func new(l: span*, op: mir_unary_opr, t: type*, v: mir_block*) -> mir_unary* {
        var res = mir_unary::__alloc__();
        res->base = mir::instance(mir_kind::mir_unary, l);
        res->op = op;
        res->resolved_type = t->copy_instance();
        res->value = v;
        return res;
    }

    pub func delete(self) {
        self->resolved_type.delete();
        if (self->value != nil) {
            var n = self->value => mir*;
            n->delete();
            free(n => i8*);
        }
    }

    pub func dump(self, out: io, pkg: package*, depth: u32) {
        out.out("mir_unary ");
        match (self->op) {
            mir_unary_opr::neg => out.out("-");
            mir_unary_opr::bnot => out.out("~");
            mir_unary_opr::lnot => out.out("!");
        }
        out.endln();

        var n = self->value => mir*;
        n->dump(out, pkg, depth + 1);
    }
}

pub struct mir_binary {
    base: mir,
    op: mir_binary_opr,
    resolved_type: type,
    left: mir_block*,
    right: mir_block*
}

impl mir_binary {
    pub func new(l: span*,
                 op: mir_binary_opr,
                 t: type*,
                 lhs: mir_block*,
                 rhs: mir_block*) -> mir_binary* {
        var res = mir_binary::__alloc__();
        res->base = mir::instance(mir_kind::mir_binary, l);
        res->op = op;
        res->resolved_type = t->copy_instance();
        res->left = lhs;
        res->right = rhs;
        return res;
    }

    pub func delete(self) {
        self->resolved_type.delete();
        if (self->left != nil) {
            var n = self->left => mir*;
            n->delete();
            free(n => i8*);
        }
        if (self->right != nil) {
            var n = self->right => mir*;
            n->delete();
            free(n => i8*);
        }
    }

    pub func dump(self, out: io, pkg: package*, depth: u32) {
        out.out("mir_binary ");
        match (self->op) {
            mir_binary_opr::add => out.out("+");
            mir_binary_opr::sub => out.out("-");
            mir_binary_opr::mul => out.out("*");
            mir_binary_opr::div => out.out("/");
            mir_binary_opr::rem => out.out("%");
            mir_binary_opr::cmpeq => out.out("==");
            mir_binary_opr::cmpne => out.out("!=");
            mir_binary_opr::less => out.out("<");
            mir_binary_opr::leq => out.out("<=");
            mir_binary_opr::grt => out.out(">");
            mir_binary_opr::geq => out.out(">=");
            mir_binary_opr::cmpand => out.out("&&");
            mir_binary_opr::cmpor => out.out("||");
            mir_binary_opr::band => out.out("&");
            mir_binary_opr::bor => out.out("|");
            mir_binary_opr::bxor => out.out("^");
        }
        out.endln();

        var n = self->left => mir*;
        n->dump(out, pkg, depth + 1);
        n = self->right => mir*;
        n->dump(out, pkg, depth + 1);
    }
}

pub struct mir_type_convert {
    base: mir,
    source: mir_block*,
    target: type
}

impl mir_type_convert {
    pub func new(l: span*, src: mir_block*, t: type*) -> mir_type_convert* {
        var res = mir_type_convert::__alloc__();
        res->base = mir::instance(mir_kind::mir_type_convert, l);
        res->source = src;
        res->target = t->copy_instance();
        return res;
    }

    pub func delete(self) {
        if (self->source != nil) {
            var n = self->source => mir*;
            n->delete();
            free(n => i8*);
        }
        self->target.delete();
    }

    pub func dump(self, out: io, pkg: package*, depth: u32) {
        var name = self->target.full_path_name(pkg, true);
        out.out("mir_type_convert => ").out(name.c_str).endln();
        name.delete();

        var n = self->source => mir*;
        n->dump(out, pkg, depth + 1);
    }
}

pub struct mir_nil {
    base: mir,
    resolved_type: type
}

impl mir_nil {
    pub func new(l: span*, t: type*) -> mir_nil* {
        var res = mir_nil::__alloc__();
        res->base = mir::instance(mir_kind::mir_nil, l);
        res->resolved_type = t->copy_instance();
        return res;
    }

    pub func delete(self) {
        self->resolved_type.delete();
    }

    pub func dump(self, out: io, pkg: package*, depth: u32) {
        var tn = self->resolved_type.full_path_name(pkg, true);
        out.out("mir_nil [").out(tn.c_str).out("]").endln();
        tn.delete();
    }
}

pub struct mir_number {
    base: mir,
    value: str,
    resolved_type: type
}

impl mir_number {
    pub func new(l: span*, num: str*, t: type*) -> mir_number* {
        var res = mir_number::__alloc__();
        res->base = mir::instance(mir_kind::mir_number, l);
        res->value = num->copy_instance();
        res->resolved_type = t->copy_instance();
        return res;
    }

    pub func delete(self) {
        self->value.delete();
        self->resolved_type.delete();
   }

    pub func dump(self, out: io, pkg: package*, depth: u32) {
        var tn = self->resolved_type.full_path_name(pkg, true);
        out.out("mir_number: ").out(self->value.c_str);
        out.out(" [").out(tn.c_str).out("]").endln();
        tn.delete();
    }
}

pub struct mir_string {
    base: mir,
    value: str,
    resolved_type: type
}

impl mir_string {
    pub func new(l: span*, s: str*, t: type*) -> mir_string* {
        var res = mir_string::__alloc__();
        res->base = mir::instance(mir_kind::mir_string, l);
        res->value = s->copy_instance();
        res->resolved_type = t->copy_instance();
        return res;
    }

    pub func delete(self) {
        self->value.delete();
        self->resolved_type.delete();
    }

    pub func dump(self, out: io, pkg: package*, depth: u32) {
        out.out("mir_string: \"").out(self->value.c_str).out("\"").endln();
    }
}

pub struct mir_char {
    base: mir,
    value: str,
    resolved_type: type
}

impl mir_char {
    pub func new(l: span*, s: str*, t: type*) -> mir_char* {
        var res = mir_char::__alloc__();
        res->base = mir::instance(mir_kind::mir_char, l);
        res->value = s->copy_instance();
        res->resolved_type = t->copy_instance();
        return res;
    }

    pub func delete(self) {
        self->value.delete();
        self->resolved_type.delete();
    }

    pub func dump(self, out: io, pkg: package*, depth: u32) {
        out.out("mir_char: '").out(self->value.c_str).out("'").endln();
    }
}

pub struct mir_bool {
    base: mir,
    value: bool,
    resolved_type: type
}

impl mir_bool {
    pub func new(l: span*, flag: bool, t: type*) -> mir_bool* {
        var res = mir_bool::__alloc__();
        res->base = mir::instance(mir_kind::mir_bool, l);
        res->value = flag;
        res->resolved_type = t->copy_instance();
        return res;
    }

    pub func delete(self) {
        self->resolved_type.delete();
    }

    pub func dump(self, out: io, pkg: package*, depth: u32) {
        out.out("mir_bool: ");
        if (self->value) {
            out.out("true").endln();
        } else {
            out.out("false").endln();
        }
    }
}

pub struct mir_array {
    base: mir,
    size: u64,
    resolved_type: type
}

impl mir_array {
    pub func new(l: span*, s: u64, t: type*) -> mir_array* {
        var res = mir_array::__alloc__();
        res->base = mir::instance(mir_kind::mir_array, l);
        res->size = s;
        res->resolved_type = t->copy_instance();
        return res;
    }

    pub func delete(self) {
        self->resolved_type.delete();
    }

    pub func dump(self, out: io, pkg: package*, depth: u32) {
        var name = self->resolved_type.full_path_name(pkg, true);
        out.out("mir_array: ").out_i64(self->size => i64);
        out.out(" of ").out(name.c_str).endln();
        name.delete();
    }
}

struct init_field {
    name: str,
    content: mir_block*,
    resolved_type: type
}

impl init_field {
    pub func copy(self) -> init_field* {
        var res = init_field::__alloc__();
        res->name = self->name.copy_instance();
        res->content = self->content;
        res->resolved_type = self->resolved_type.copy_instance();
        return res;
    }

    pub func delete(self) {
        self->name.delete();
        if (self->content != nil) {
            var n = self->content => mir*;
            n->delete();
            free(n => i8*);
        }
        self->resolved_type.delete();
    }

    pub func dump(self, out: io, pkg: package*, depth: u32) {
        for (var j: u32 = 0; j < depth; j += 1) {
            out.out("  ");
        }
        out.out("[").out(self->name.c_str).out("]: [");
        var tn = self->resolved_type.full_path_name(pkg, true);
        out.out(tn.c_str).out("]").endln();
        tn.delete();

        var n = self->content => mir*;
        n->dump(out, pkg, depth + 1);
    }
}

pub struct mir_struct_init {
    base: mir,
    resolved_type: type,
    fields: vec<init_field>
}

impl mir_struct_init {
    pub func new(l: span*, t: type*) -> mir_struct_init* {
        var res = mir_struct_init::__alloc__();
        res->base = mir::instance(mir_kind::mir_struct_init, l);
        res->resolved_type = t->copy_instance();
        res->fields = vec<init_field>::instance();
        return res;
    }

    pub func delete(self) {
        self->resolved_type.delete();
        self->fields.delete();
    }

    pub func add_field(self, n: str*, b: mir_block*, t: type*) {
        var in_fld = init_field {
            name: n->copy_instance(),
            content: b,
            resolved_type: t->copy_instance()
        };
        self->fields.push(in_fld.__ptr__());
        in_fld.content = nil;
        in_fld.delete();
    }

    pub func dump(self, out: io, pkg: package*, depth: u32) {
        var sn = self->resolved_type.full_path_name(pkg, true);
        out.out("mir_struct_init: ").out(sn.c_str).endln();
        sn.delete();

        for (var i = self->fields.iter(); !i.is_end(); i = i.next()) {
            i.get()->dump(out, pkg, depth + 1);
        }
    }
}

pub struct mir_call {
    base: mir,
    content: mir_block*,
    resolved_type: type
}

impl mir_call {
    pub func new(l: span*, b: mir_block*, t: type*) -> mir_call* {
        var res = mir_call::__alloc__();
        res->base = mir::instance(mir_kind::mir_call, l);
        res->content = b;
        res->resolved_type = t->copy_instance();
        return res;
    }

    pub func delete(self) {
        if (self->content != nil) {
            var n = self->content => mir*;
            n->delete();
            free(n => i8*);
        }
        self->resolved_type.delete();
    }

    pub func dump(self, out: io, pkg: package*, depth: u32) {
        var tn = self->resolved_type.full_path_name(pkg, true);
        out.out("mir_call [").out(tn.c_str).out("]").endln();
        tn.delete();

        var t = self->content => mir*;
        t->dump(out, pkg, depth + 1);
    }
}

pub struct mir_call_id {
    base: mir,
    name: str,
    resolved_type: type
}

impl mir_call_id {
    pub func new(l: span*, n: str*, t: type*) -> mir_call_id* {
        var res = mir_call_id::__alloc__();
        res->base = mir::instance(mir_kind::mir_call_id, l);
        res->name = n->copy_instance();
        res->resolved_type = t->copy_instance();
        return res;
    }

    pub func delete(self) {
        self->name.delete();
        self->resolved_type.delete();
    }

    pub func dump(self, out: io, pkg: package*, depth: u32) {
        out.out("mir_call_id: ").out(self->name.c_str);

        var tn = self->resolved_type.full_path_name(pkg, true);
        out.out(" [").out(tn.c_str).out("]").endln();
        tn.delete();
    }
}

pub struct mir_call_index {
    base: mir,
    index: mir_block*,
    resolved_type: type
}

impl mir_call_index {
    pub func new(l: span*, idx: mir_block*, t: type*) -> mir_call_index* {
        var res = mir_call_index::__alloc__();
        res->base = mir::instance(mir_kind::mir_call_index, l);
        res->index = idx;
        res->resolved_type = t->copy_instance();
        return res;
    }

    pub func delete(self) {
        if (self->index != nil) {
            var n = self->index => mir*;
            n->delete();
            free(n => i8*);
        }
        self->resolved_type.delete();
    }

    pub func dump(self, out: io, pkg: package*, depth: u32) {
        var tn = self->resolved_type.full_path_name(pkg, true);
        out.out("mir_call_index [").out(tn.c_str).out("]").endln();
        tn.delete();

        var t = self->index => mir*;
        t->dump(out, pkg, depth + 1);
    }
}

pub struct mir_call_func {
    base: mir,
    args: mir_block*,
    resolved_type: type
}

impl mir_call_func {
    pub func new(l: span*, a: mir_block*, t: type*) -> mir_call_func* {
        var res = mir_call_func::__alloc__();
        res->base = mir::instance(mir_kind::mir_call_func, l);
        res->args = a;
        res->resolved_type = t->copy_instance();
        return res;
    }

    pub func delete(self) {
        if (self->args != nil) {
            var n = self->args => mir*;
            n->delete();
            free(n => i8*);
        }
        self->resolved_type.delete();
    }

    pub func dump(self, out: io, pkg: package*, depth: u32) {
        var tn = self->resolved_type.full_path_name(pkg, true);
        out.out("mir_call_func [").out(tn.c_str).out("]").endln();
        tn.delete();

        var t = self->args => mir*;
        t->dump(out, pkg, depth + 1);
    }
}

pub struct mir_get_field {
    base: mir,
    name: str,
    resolved_type: type
}

impl mir_get_field {
    pub func new(l: span*, n: str*, t: type*) -> mir_get_field* {
        var res = mir_get_field::__alloc__();
        res->base = mir::instance(mir_kind::mir_get_field, l);
        res->name = n->copy_instance();
        res->resolved_type = t->copy_instance();
        return res;
    }

    pub func delete(self) {
        self->name.delete();
        self->resolved_type.delete();
    }

    pub func dump(self, out: io, pkg: package*, depth: u32) {
        out.out("mir_get_field: ").out(self->name.c_str);

        var tn = self->resolved_type.full_path_name(pkg, true);
        out.out(" [").out(tn.c_str).out("]").endln();
        tn.delete();
    }
}

pub struct mir_ptr_get_field {
    base: mir,
    name: str,
    resolved_type: type
}

impl mir_ptr_get_field {
    pub func new(l: span*, n: str*, t: type*) -> mir_ptr_get_field* {
        var res = mir_ptr_get_field::__alloc__();
        res->base = mir::instance(mir_kind::mir_ptr_get_field, l);
        res->name = n->copy_instance();
        res->resolved_type = t->copy_instance();
        return res;
    }

    pub func delete(self) {
        self->name.delete();
        self->resolved_type.delete();
    }

    pub func dump(self, out: io, pkg: package*, depth: u32) {
        out.out("mir_ptr_get_field: ").out(self->name.c_str);

        var tn = self->resolved_type.full_path_name(pkg, true);
        out.out(" [").out(tn.c_str).out("]").endln();
        tn.delete();
    }
}

pub struct mir_get_path {
    base: mir,
    name: str,
    resolved_type: type
}

impl mir_get_path {
    pub func new(l: span*, n: str*, t: type*) -> mir_get_path* {
        var res = mir_get_path::__alloc__();
        res->base = mir::instance(mir_kind::mir_get_path, l);
        res->name = n->copy_instance();
        res->resolved_type = t->copy_instance();
        return res;
    }

    pub func delete(self) {
        self->name.delete();
        self->resolved_type.delete();
    }

    pub func dump(self, out: io, pkg: package*, depth: u32) {
        out.out("mir_get_path: ").out(self->name.c_str);

        var tn = self->resolved_type.full_path_name(pkg, true);
        out.out(" [").out(tn.c_str).out("]").endln();
        tn.delete();
    }
}

pub struct mir_define {
    base: mir,
    init_value: mir_block*,
    resolved_type: type
}

impl mir_define {
    pub func new(l: span*) -> mir_define* {
        var res = mir_define::__alloc__();
        res->base = mir::instance(mir_kind::mir_define, l);
        res->init_value = nil;
        res->resolved_type = type::instance();
        return res;
    }

    pub func delete(self) {
        if (self->init_value != nil) {
            var n = self->init_value => mir*;
            n->delete();
            free(n => i8*);
        }
        self->resolved_type.delete();
    }
}

pub struct mir_assign {
    base: mir,
    opr: mir_assign_opr,
    left: mir_block*,
    right: mir_block*
}

impl mir_assign {
    pub func new(l: span*) -> mir_assign* {
        var res = mir_assign::__alloc__();
        res->base = mir::instance(mir_kind::mir_assign, l);
        res->left = nil;
        res->right = nil;
        return res;
    }

    pub func delete(self) {
        if (self->left != nil) {
            var n= self->left => mir*;
            n->delete();
            free(n => i8*);
        }
        if (self->right != nil) {
            var n= self->right => mir*;
            n->delete();
            free(n => i8*);
        }
    }
}

pub struct mir_if {
    base: mir,
    condition: mir_block*,
    content: mir_block*
}

impl mir_if {
    pub func new(l: span*) -> mir_if* {
        var res = mir_if::__alloc__();
        res->base = mir::instance(mir_kind::mir_if, l);
        res->condition = nil;
        res->content = nil;
        return res;
    }

    pub func delete(self) {
        if (self->condition != nil) {
            var n= self->condition => mir*;
            n->delete();
            free(n => i8*);
        }
        if (self->content != nil) {
            var n= self->content => mir*;
            n->delete();
            free(n => i8*);
        }
    }
}

pub struct mir_branch {
    base: mir,
    branch: primitive_vec<ptr<mir_if>>
}

impl mir_branch {
    pub func new(l: span*) -> mir_branch* {
        var res = mir_branch::__alloc__();
        res->base = mir::instance(mir_kind::mir_branch, l);
        res->branch = primitive_vec<ptr<mir_if>>::instance();
        return res;
    }

    pub func delete(self) {
        for (var i = self->branch.iter(); !i.is_end(); i = i.next()) {
            var n = i.get().unwrap() => mir*;
            n->delete();
            free(n => i8*);
        }
        self->branch.delete();
    }
}

pub struct mir_switch_case {
    base: mir,
    value: i64,
    content: mir_block*
}

impl mir_switch_case {
    pub func new(l: span*) -> mir_switch_case* {
        var res = mir_switch_case::__alloc__();
        res->base = mir::instance(mir_kind::mir_switch_case, l);
        res->content = nil;
        return res;
    }

    pub func delete(self) {
        if (self->content != nil) {
            var n= self->content => mir*;
            n->delete();
            free(n => i8*);
        }
    }
}

pub struct mir_switch {
    base: mir,
    condition: mir_block*,
    cases: primitive_vec<ptr<mir_switch_case>>,
    default_case: mir_block*
}

impl mir_switch {
    pub func new(l: span*) -> mir_switch* {
        var res = mir_switch::__alloc__();
        res->base = mir::instance(mir_kind::mir_switch, l);
        res->condition = nil;
        res->cases = primitive_vec<ptr<mir_switch_case>>::instance();
        res->default_case = nil;
        return res;
    }

    pub func delete(self) {
        if (self->condition != nil) {
            var n= self->condition => mir*;
            n->delete();
            free(n => i8*);
        }
        for (var i = self->cases.iter(); !i.is_end(); i = i.next()) {
            var n = i.get().unwrap() => mir*;
            n->delete();
            free(n => i8*);
        }
        self->cases.delete();
        if (self->default_case != nil) {
            var n= self->default_case => mir*;
            n->delete();
            free(n => i8*);
        }
    }
}

pub struct mir_break {
    base: mir
}

impl mir_break {
    pub func new(l: span*) -> mir_break* {
        var res = mir_break::__alloc__();
        res->base = mir::instance(mir_kind::mir_break, l);
        return res;
    }

    pub func delete(self) {}

    pub func dump(self, out: io, pkg: package*, depth: u32) {
        out.out("mir_break").endln();
    }
}

pub struct mir_continue {
    base: mir
}

impl mir_continue {
    pub func new(l: span*) -> mir_continue* {
        var res = mir_continue::__alloc__();
        res->base = mir::instance(mir_kind::mir_continue, l);
        return res;
    }

    pub func delete(self) {}

    pub func dump(self, out: io, pkg: package*, depth: u32) {
        out.out("mir_continue").endln();
    }
}

pub struct mir_loop {
    base: mir,
    condition: mir_block*,
    content: mir_block*,
    update: mir_block*
}

impl mir_loop {
    pub func new(l: span*) -> mir_loop* {
        var res = mir_loop::__alloc__();
        res->base = mir::instance(mir_kind::mir_loop, l);
        res->condition = nil;
        res->content = nil;
        res->update = nil;
        return res;
    }

    pub func delete(self) {
        if (self->condition != nil) {
            var n= self->condition => mir*;
            n->delete();
            free(n => i8*);
        }
        if (self->content != nil) {
            var n= self->content => mir*;
            n->delete();
            free(n => i8*);
        }
        if (self->update != nil) {
            var n= self->update => mir*;
            n->delete();
            free(n => i8*);
        }
    }
}

pub struct mir_return {
    base: mir,
    value: mir_block*
}

impl mir_return {
    pub func new(l: span*, v: mir_block*) -> mir_return* {
        var res = mir_return::__alloc__();
        res->base = mir::instance(mir_kind::mir_return, l);
        res->value = v;
        return res;
    }

    pub func delete(self) {
        if (self->value != nil) {
            var n= self->value => mir*;
            n->delete();
        }
    }

    pub func dump(self, out: io, pkg: package*, depth: u32) {
        out.out("mir_ret").endln();
        if (self->value != nil) {
            var t = self->value => mir*;
            t->dump(out, pkg, depth + 1);
        }
    }
}
