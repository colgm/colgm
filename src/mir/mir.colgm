use err::span::{ span };
use err::panic::{ unreachable };

use std::libc::{ free };
use std::str::{ str };
use std::vec::{ vec, primitive_vec };
use std::ptr::{ ptr };
use std::io::{ io };

use package::{ package };
use util::mangling::{ llvm_raw_string };

use sema::type::{ type };

pub enum mir_kind {
    mir_none,
    mir_block,
    mir_unary,
    mir_binary,
    mir_type_convert,
    mir_nil,
    mir_number,
    mir_string,
    mir_char,
    mir_bool,
    mir_array,
    mir_struct_init,
    mir_call,
    mir_call_id,
    mir_call_index,
    mir_call_func,
    mir_get_field,
    mir_get_path,
    mir_ptr_get_field,
    mir_define,
    mir_assign,
    mir_if,
    mir_branch,
    mir_switch_case,
    mir_switch,
    mir_break,
    mir_continue,
    mir_loop,
    mir_return
}

pub enum mir_unary_opr {
    neg,
    bnot,
    lnot
}

pub enum mir_binary_opr {
    add,
    sub,
    mul,
    div,
    rem,
    cmpeq,
    cmpne,
    less,
    leq,
    grt,
    geq,
    cmpand,
    cmpor,
    band,
    bor,
    bxor
}

pub enum mir_assign_opr {
    eq,
    addeq,
    subeq,
    muleq,
    diveq,
    remeq,
    andeq,
    xoreq,
    oreq
}

pub struct mir {
    kind: mir_kind,
    location: span
}

impl mir {
    pub func instance(k: mir_kind, l: span*) -> mir {
        return mir { kind: k, location: l->copy_instance() };
    }

    pub func delete(self) {
        self->location.delete();
        match (self->kind) {
            mir_kind::mir_block => {
                var n = self => mir_block*;
                n->delete();
            }
            mir_kind::mir_unary => {
                var n = self => mir_unary*;
                n->delete();
            }
            mir_kind::mir_binary => {
                var n = self => mir_binary*;
                n->delete();
            }
            mir_kind::mir_type_convert => {
                var n = self => mir_type_convert*;
                n->delete();
            }
            mir_kind::mir_nil => {
                var n = self => mir_nil*;
                n->delete();
            }
            mir_kind::mir_number => {
                var n = self => mir_number*;
                n->delete();
            }
            mir_kind::mir_string => {
                var n = self => mir_string*;
                n->delete();
            }
            mir_kind::mir_char => {
                var n = self => mir_char*;
                n->delete();
            }
            mir_kind::mir_bool => {
                var n = self => mir_bool*;
                n->delete();
            }
            mir_kind::mir_array => {
                var n = self => mir_array*;
                n->delete();
            }
            mir_kind::mir_struct_init => {
                var n = self => mir_struct_init*;
                n->delete();
            }
            mir_kind::mir_call => {
                var n = self => mir_call*;
                n->delete();
            }
            mir_kind::mir_call_id => {
                var n = self => mir_call_id*;
                n->delete();
            }
            mir_kind::mir_call_index => {
                var n = self => mir_call_index*;
                n->delete();
            }
            mir_kind::mir_call_func => {
                var n = self => mir_call_func*;
               n->delete();
            }
            mir_kind::mir_get_field => {
                var n = self => mir_get_field*;
                n->delete();
            }
            mir_kind::mir_get_path => {
                var n = self => mir_get_path*;
                n->delete();
            }
            mir_kind::mir_ptr_get_field => {
                var n = self => mir_ptr_get_field*;
                n->delete();
            }
            mir_kind::mir_define => {
                var n = self => mir_define*;
                n->delete();
            }
            mir_kind::mir_assign => {
                var n = self => mir_assign*;
                n->delete();
            }
            mir_kind::mir_if => {
                var n = self => mir_if*;
                n->delete();
            }
            mir_kind::mir_branch => {
                var n = self => mir_branch*;
                n->delete();
            }
            mir_kind::mir_switch_case => {
                var n = self => mir_switch_case*;
                n->delete();
            }
            mir_kind::mir_switch => {
                var n = self => mir_switch*;
                n->delete();
            }
            mir_kind::mir_break => {
                var n = self => mir_break*;
                n->delete();
            }
            mir_kind::mir_continue => {
                var n = self => mir_continue*;
                n->delete();
            }
            mir_kind::mir_loop => {
                var n = self => mir_loop*;
                n->delete();
            }
            mir_kind::mir_return => {
                var n = self => mir_return*;
                n->delete();
            }
            _ => { unreachable(); }
        }
    }

    pub func dump(self, out: io, pkg: package*, depth: u32) {
        for (var i: u32 = 0; i < depth; i = i + 1) {
            out.out(".");
        }
        
        match (self->kind) {
            mir_kind::mir_block => {
                var n = self => mir_block*;
                n->dump(out, pkg, depth);
            }
            mir_kind::mir_unary => {
                var n = self => mir_unary*;
                n->dump(out, pkg, depth);
            }
            mir_kind::mir_binary => {
                var n = self => mir_binary*;
                n->dump(out, pkg, depth);
            }
            mir_kind::mir_type_convert => {
                var n = self => mir_type_convert*;
                n->dump(out, pkg, depth);
            }
            mir_kind::mir_nil => {
                var n = self => mir_nil*;
                n->dump(out, pkg, depth);
            }
            mir_kind::mir_number => {
                var n = self => mir_number*;
                n->dump(out, pkg, depth);
            }
            mir_kind::mir_string => {
                var n = self => mir_string*;
                n->dump(out, pkg, depth);
            }
            mir_kind::mir_char => {
                var n = self => mir_char*;
                n->dump(out, pkg, depth);
            }
            mir_kind::mir_bool => {
                var n = self => mir_bool*;
                n->dump(out, pkg, depth);
            }
            mir_kind::mir_array => {
                var n = self => mir_array*;
                n->dump(out, pkg, depth);
            }
            mir_kind::mir_struct_init => {
                var n = self => mir_struct_init*;
                n->dump(out, pkg, depth);
            }
            mir_kind::mir_call => {
                var n = self => mir_call*;
                n->dump(out, pkg, depth);
            }
            mir_kind::mir_call_id => {
                var n = self => mir_call_id*;
                n->dump(out, pkg, depth);
            }
            mir_kind::mir_call_index => {
                var n = self => mir_call_index*;
                n->dump(out, pkg, depth);
            }
            mir_kind::mir_call_func => {
                var n = self => mir_call_func*;
                n->dump(out, pkg, depth);
            }
            mir_kind::mir_get_field => {
                var n = self => mir_get_field*;
                n->dump(out, pkg, depth);
            }
            mir_kind::mir_get_path => {
                var n = self => mir_get_path*;
                n->dump(out, pkg, depth);
            }
            mir_kind::mir_ptr_get_field => {
                var n = self => mir_ptr_get_field*;
                n->dump(out, pkg, depth);
            }
            mir_kind::mir_define => {
                var n = self => mir_define*;
                n->dump(out, pkg, depth);
            }
            mir_kind::mir_assign => {
                var n = self => mir_assign*;
                n->dump(out, pkg, depth);
            }
            mir_kind::mir_if => {
                var n = self => mir_if*;
                n->dump(out, pkg, depth);
            }
            mir_kind::mir_branch => {
                var n = self => mir_branch*;
                n->dump(out, pkg, depth);
            }
            mir_kind::mir_switch_case => {
                var n = self => mir_switch_case*;
                n->dump(out, pkg, depth);
            }
            mir_kind::mir_switch => {
                var n = self => mir_switch*;
                n->dump(out, pkg, depth);
            }
            mir_kind::mir_break => {
                var n = self => mir_break*;
                n->dump(out, pkg, depth);
            }
            mir_kind::mir_continue => {
                var n = self => mir_continue*;
                n->dump(out, pkg, depth);
            }
            mir_kind::mir_loop => {
                var n = self => mir_loop*;
                n->dump(out, pkg, depth);
            }
            mir_kind::mir_return => {
                var n = self => mir_return*;
                n->dump(out, pkg, depth);
            }
            _ => {
                unreachable();
            }
        }
    }
}

pub struct mir_block {
    base: mir,
    content: primitive_vec<ptr<mir>>
}

impl mir_block {
    pub func new(l: span*) -> mir_block* {
        var res = mir_block::__alloc__();
        res->base = mir::instance(mir_kind::mir_block, l);
        res->content = primitive_vec<ptr<mir>>::instance();
        return res;
    }

    pub func delete(self) {
        foreach (var i; self->content) {
            var item = i.get().unwrap();
            item->delete();
            free(item => i8*);
        }
        self->content.delete();
    }

    pub func dump(self, out: io, pkg: package*, depth: u32) {
        out.purple().out("MIRBlock").reset();
        out.light_orange().out(" 0x").out_hex(self => i64).reset().out(" ");
        self->base.location.dump(out);
        foreach (var i; self->content) {
            var item = i.get().unwrap();
            item->dump(out, pkg, depth + 1);
        }
    }

    pub func add(self, n: mir*) {
        self->content.push(ptr<mir>::wrap(n));
    }
}

pub struct mir_unary {
    base: mir,
    op: mir_unary_opr,
    resolved_type: type,
    value: mir_block*
}

impl mir_unary {
    pub func new(l: span*, op: mir_unary_opr, t: type*, v: mir_block*) -> mir_unary* {
        var res = mir_unary::__alloc__();
        res->base = mir::instance(mir_kind::mir_unary, l);
        res->op = op;
        res->resolved_type = t->copy_instance();
        res->value = v;
        return res;
    }

    pub func delete(self) {
        self->resolved_type.delete();
        if (self->value != nil) {
            var n = self->value => mir*;
            n->delete();
            free(n => i8*);
        }
    }

    pub func dump(self, out: io, pkg: package*, depth: u32) {
        out.purple().out("MIRUnary").reset();
        out.light_orange().out(" 0x").out_hex(self => i64).reset();
        out.out(" ");
        match (self->op) {
            mir_unary_opr::neg => out.green().out("-").reset();
            mir_unary_opr::bnot => out.green().out("~").reset();
            mir_unary_opr::lnot => out.green().out("!").reset();
        }
        out.out(" ");
        self->base.location.dump(out);

        var n = self->value => mir*;
        n->dump(out, pkg, depth + 1);
    }
}

pub struct mir_binary {
    base: mir,
    op: mir_binary_opr,
    resolved_type: type,
    left: mir_block*,
    right: mir_block*
}

impl mir_binary {
    pub func new(l: span*,
                 op: mir_binary_opr,
                 t: type*,
                 lhs: mir_block*,
                 rhs: mir_block*) -> mir_binary* {
        var res = mir_binary::__alloc__();
        res->base = mir::instance(mir_kind::mir_binary, l);
        res->op = op;
        res->resolved_type = t->copy_instance();
        res->left = lhs;
        res->right = rhs;
        return res;
    }

    pub func delete(self) {
        self->resolved_type.delete();
        if (self->left != nil) {
            var n = self->left => mir*;
            n->delete();
            free(n => i8*);
        }
        if (self->right != nil) {
            var n = self->right => mir*;
            n->delete();
            free(n => i8*);
        }
    }

    pub func dump(self, out: io, pkg: package*, depth: u32) {
        out.purple().out("MIRBinary").reset();
        out.light_orange().out(" 0x").out_hex(self => i64).reset();
        out.out(" ");
        match (self->op) {
            mir_binary_opr::add => out.green().out("+").reset();
            mir_binary_opr::sub => out.green().out("-").reset();
            mir_binary_opr::mul => out.green().out("*").reset();
            mir_binary_opr::div => out.green().out("/").reset();
            mir_binary_opr::rem => out.green().out("%").reset();
            mir_binary_opr::cmpeq => out.green().out("==").reset();
            mir_binary_opr::cmpne => out.green().out("!=").reset();
            mir_binary_opr::less => out.green().out("<").reset();
            mir_binary_opr::leq => out.green().out("<=").reset();
            mir_binary_opr::grt => out.green().out(">").reset();
            mir_binary_opr::geq => out.green().out(">=").reset();
            mir_binary_opr::cmpand => out.green().out("&&").reset();
            mir_binary_opr::cmpor => out.green().out("||").reset();
            mir_binary_opr::band => out.green().out("&").reset();
            mir_binary_opr::bor => out.green().out("|").reset();
            mir_binary_opr::bxor => out.green().out("^").reset();
        }
        out.out(" ");
        self->base.location.dump(out);

        var n = self->left => mir*;
        n->dump(out, pkg, depth + 1);
        n = self->right => mir*;
        n->dump(out, pkg, depth + 1);
    }
}

pub struct mir_type_convert {
    base: mir,
    source: mir_block*,
    target: type
}

impl mir_type_convert {
    pub func new(l: span*, src: mir_block*, t: type*) -> mir_type_convert* {
        var res = mir_type_convert::__alloc__();
        res->base = mir::instance(mir_kind::mir_type_convert, l);
        res->source = src;
        res->target = t->copy_instance();
        return res;
    }

    pub func delete(self) {
        if (self->source != nil) {
            var n = self->source => mir*;
            n->delete();
            free(n => i8*);
        }
        self->target.delete();
    }

    pub func dump(self, out: io, pkg: package*, depth: u32) {
        out.purple().out("MIRTypeConvert").reset();
        out.light_orange().out(" 0x").out_hex(self => i64).reset();
        var name = self->target.full_path_name(pkg, true);
        out.cyan().out(" [type: ").out(name.c_str).out("]").reset();
        name.delete();

        out.out(" ");
        self->base.location.dump(out);

        var n = self->source => mir*;
        n->dump(out, pkg, depth + 1);
    }
}

pub struct mir_nil {
    base: mir,
    resolved_type: type
}

impl mir_nil {
    pub func new(l: span*, t: type*) -> mir_nil* {
        var res = mir_nil::__alloc__();
        res->base = mir::instance(mir_kind::mir_nil, l);
        res->resolved_type = t->copy_instance();
        return res;
    }

    pub func delete(self) {
        self->resolved_type.delete();
    }

    pub func dump(self, out: io, pkg: package*, depth: u32) {
        out.purple().out("MIRNil").reset();
        out.light_orange().out(" 0x").out_hex(self => i64).reset();
        var tn = self->resolved_type.full_path_name(pkg, true);
        out.cyan().out(" [type: ").out(tn.c_str).out("]").reset();
        tn.delete();

        out.out(" ");
        self->base.location.dump(out);
    }
}

pub struct mir_number {
    base: mir,
    value: str,
    resolved_type: type
}

impl mir_number {
    pub func new(l: span*, num: str*, t: type*) -> mir_number* {
        var res = mir_number::__alloc__();
        res->base = mir::instance(mir_kind::mir_number, l);
        res->value = num->copy_instance();
        res->resolved_type = t->copy_instance();
        return res;
    }

    pub func delete(self) {
        self->value.delete();
        self->resolved_type.delete();
   }

    pub func dump(self, out: io, pkg: package*, depth: u32) {
        out.purple().out("MIRNumber").reset();
        out.light_orange().out(" 0x").out_hex(self => i64).reset();
        var tn = self->resolved_type.full_path_name(pkg, true);
        out.cyan().out(" [type: ").out(tn.c_str).out("]").reset();
        tn.delete();

        out.out(" ").green().out(self->value.c_str).reset();

        out.out(" ");
        self->base.location.dump(out);
    }
}

pub struct mir_string {
    base: mir,
    value: str,
    resolved_type: type
}

impl mir_string {
    pub func new(l: span*, s: str*, t: type*) -> mir_string* {
        var res = mir_string::__alloc__();
        res->base = mir::instance(mir_kind::mir_string, l);
        res->value = s->copy_instance();
        res->resolved_type = t->copy_instance();
        return res;
    }

    pub func delete(self) {
        self->value.delete();
        self->resolved_type.delete();
    }

    pub func dump(self, out: io, pkg: package*, depth: u32) {
        out.purple().out("MIRString").reset();
        out.light_orange().out(" 0x").out_hex(self => i64).reset();

        var tn = self->resolved_type.full_path_name(pkg, true);
        out.cyan().out(" [type: ").out(tn.c_str).out("]").reset();
        tn.delete();
        
        var tmp = llvm_raw_string(self->value.__ptr__());
        out.green().out(" \"").out(tmp.c_str).out("\"").reset();
        tmp.delete();

        out.out(" ");
        self->base.location.dump(out);
    }
}

pub struct mir_char {
    base: mir,
    value: str,
    resolved_type: type
}

impl mir_char {
    pub func new(l: span*, s: str*, t: type*) -> mir_char* {
        var res = mir_char::__alloc__();
        res->base = mir::instance(mir_kind::mir_char, l);
        res->value = s->copy_instance();
        res->resolved_type = t->copy_instance();
        return res;
    }

    pub func delete(self) {
        self->value.delete();
        self->resolved_type.delete();
    }

    pub func dump(self, out: io, pkg: package*, depth: u32) {
        out.purple().out("MIRCharacter").reset();
        out.light_orange().out(" 0x").out_hex(self => i64).reset();
        
        var tmp = llvm_raw_string(self->value.__ptr__());
        out.green().out(" '").out(tmp.c_str).out("'").reset();
        tmp.delete();

        out.out(" ");
        self->base.location.dump(out);
    }
}

pub struct mir_bool {
    base: mir,
    value: bool,
    resolved_type: type
}

impl mir_bool {
    pub func new(l: span*, flag: bool, t: type*) -> mir_bool* {
        var res = mir_bool::__alloc__();
        res->base = mir::instance(mir_kind::mir_bool, l);
        res->value = flag;
        res->resolved_type = t->copy_instance();
        return res;
    }

    pub func delete(self) {
        self->resolved_type.delete();
    }

    pub func dump(self, out: io, pkg: package*, depth: u32) {
        out.purple().out("MIRBoolean").reset();
        out.light_orange().out(" 0x").out_hex(self => i64).reset();
        if (self->value) {
            out.green().out(" true").reset();
        } else {
            out.green().out(" false").reset();
        }

        out.out(" ");
        self->base.location.dump(out);
    }
}

pub struct mir_array {
    base: mir,
    size: u64,
    value: mir_block*,
    resolved_type: type
}

impl mir_array {
    pub func new(l: span*, s: u64, t: type*) -> mir_array* {
        var res = mir_array::__alloc__();
        res->base = mir::instance(mir_kind::mir_array, l);
        res->size = s;
        res->value = nil;
        res->resolved_type = t->copy_instance();
        return res;
    }

    pub func delete(self) {
        if (self->value != nil) {
            var n = self->value => mir*;
            n->delete();
            free(n => i8*);
        }
        self->resolved_type.delete();
    }

    pub func dump(self, out: io, pkg: package*, depth: u32) {
        out.purple().out("MIRArray").reset();
        out.light_orange().out(" 0x").out_hex(self => i64).reset();
        var name = self->resolved_type.full_path_name(pkg, true);
        out.out(" ").out_u64(self->size);
        out.cyan().out(" [type: ").out(name.c_str).out("]").reset();
        name.delete();

        out.out(" ");
        self->base.location.dump(out);

        if (self->value != nil) {
            var n = self->value => mir*;
            n->dump(out, pkg, depth + 1);
        }
    }
}

struct init_field {
    name: str,
    content: mir_block*,
    resolved_type: type
}

impl init_field {
    pub func copy(self) -> init_field* {
        var res = init_field::__alloc__();
        res->name = self->name.copy_instance();
        res->content = self->content;
        res->resolved_type = self->resolved_type.copy_instance();
        return res;
    }

    pub func delete(self) {
        self->name.delete();
        if (self->content != nil) {
            var n = self->content => mir*;
            n->delete();
            free(n => i8*);
        }
        self->resolved_type.delete();
    }

    pub func dump(self, out: io, pkg: package*, depth: u32) {
        for (var j: u32 = 0; j < depth; j += 1) {
            out.out(".");
        }
        out.purple().out("MIRInitField");
        out.light_orange().out(" 0x").out_hex(self => i64).reset();
        out.out(" ").green().out(self->name.c_str).reset().out(" ");
        var tn = self->resolved_type.full_path_name(pkg, true);
        out.cyan().out("[type: ").out(tn.c_str).out("]").reset().endln();
        tn.delete();

        var n = self->content => mir*;
        n->dump(out, pkg, depth + 1);
    }
}

pub struct mir_struct_init {
    base: mir,
    resolved_type: type,
    fields: vec<init_field>
}

impl mir_struct_init {
    pub func new(l: span*, t: type*) -> mir_struct_init* {
        var res = mir_struct_init::__alloc__();
        res->base = mir::instance(mir_kind::mir_struct_init, l);
        res->resolved_type = t->copy_instance();
        res->fields = vec<init_field>::instance();
        return res;
    }

    pub func delete(self) {
        self->resolved_type.delete();
        self->fields.delete();
    }

    pub func add_field(self, n: str*, b: mir_block*, t: type*) {
        var in_fld = init_field {
            name: n->copy_instance(),
            content: b,
            resolved_type: t->copy_instance()
        };
        self->fields.push(in_fld.__ptr__());
        in_fld.content = nil;
        in_fld.delete();
    }

    pub func dump(self, out: io, pkg: package*, depth: u32) {
        out.purple().out("MIRStructInitializer").reset();
        out.light_orange().out(" 0x").out_hex(self => i64).reset();
        var sn = self->resolved_type.full_path_name(pkg, true);
        out.cyan().out(" [type: ").out(sn.c_str).out("]").reset();
        sn.delete();

        out.out(" ");
        self->base.location.dump(out);

        foreach (var i; self->fields) {
            i.get()->dump(out, pkg, depth + 1);
        }
    }
}

pub struct mir_call {
    base: mir,
    content: mir_block*,
    resolved_type: type
}

impl mir_call {
    pub func new(l: span*, b: mir_block*, t: type*) -> mir_call* {
        var res = mir_call::__alloc__();
        res->base = mir::instance(mir_kind::mir_call, l);
        res->content = b;
        res->resolved_type = t->copy_instance();
        return res;
    }

    pub func delete(self) {
        if (self->content != nil) {
            var n = self->content => mir*;
            n->delete();
            free(n => i8*);
        }
        self->resolved_type.delete();
    }

    pub func dump(self, out: io, pkg: package*, depth: u32) {
        out.purple().out("MIRCall").reset();
        out.light_orange().out(" 0x").out_hex(self => i64).reset();
        var tn = self->resolved_type.full_path_name(pkg, true);
        out.cyan().out(" [").out(tn.c_str).out("]").reset();
        tn.delete();

        out.out(" ");
        self->base.location.dump(out);

        var t = self->content => mir*;
        t->dump(out, pkg, depth + 1);
    }
}

pub struct mir_call_id {
    base: mir,
    name: str,
    resolved_type: type
}

impl mir_call_id {
    pub func new(l: span*, n: str*, t: type*) -> mir_call_id* {
        var res = mir_call_id::__alloc__();
        res->base = mir::instance(mir_kind::mir_call_id, l);
        res->name = n->copy_instance();
        res->resolved_type = t->copy_instance();
        return res;
    }

    pub func delete(self) {
        self->name.delete();
        self->resolved_type.delete();
    }

    pub func dump(self, out: io, pkg: package*, depth: u32) {
        out.purple().out("MIRCallId").reset();
        out.light_orange().out(" 0x").out_hex(self => i64).reset();
        out.out(" ").green().out(self->name.c_str).reset();

        var tn = self->resolved_type.full_path_name(pkg, true);
        out.cyan().out(" [type: ").out(tn.c_str).out("]").reset();
        tn.delete();

        out.out(" ");
        self->base.location.dump(out);
    }
}

pub struct mir_call_index {
    base: mir,
    index: mir_block*,
    resolved_type: type
}

impl mir_call_index {
    pub func new(l: span*, idx: mir_block*, t: type*) -> mir_call_index* {
        var res = mir_call_index::__alloc__();
        res->base = mir::instance(mir_kind::mir_call_index, l);
        res->index = idx;
        res->resolved_type = t->copy_instance();
        return res;
    }

    pub func delete(self) {
        if (self->index != nil) {
            var n = self->index => mir*;
            n->delete();
            free(n => i8*);
        }
        self->resolved_type.delete();
    }

    pub func dump(self, out: io, pkg: package*, depth: u32) {
        out.purple().out("MIRCallIndex").reset();
        out.light_orange().out(" 0x").out_hex(self => i64).reset();
        
        var tn = self->resolved_type.full_path_name(pkg, true);
        out.cyan().out(" [type: ").out(tn.c_str).out("]").reset();
        tn.delete();

        out.out(" ");
        self->base.location.dump(out);

        var t = self->index => mir*;
        t->dump(out, pkg, depth + 1);
    }
}

pub struct mir_call_func {
    base: mir,
    args: mir_block*,
    resolved_type: type
}

impl mir_call_func {
    pub func new(l: span*, a: mir_block*, t: type*) -> mir_call_func* {
        var res = mir_call_func::__alloc__();
        res->base = mir::instance(mir_kind::mir_call_func, l);
        res->args = a;
        res->resolved_type = t->copy_instance();
        return res;
    }

    pub func delete(self) {
        if (self->args != nil) {
            var n = self->args => mir*;
            n->delete();
            free(n => i8*);
        }
        self->resolved_type.delete();
    }

    pub func dump(self, out: io, pkg: package*, depth: u32) {
        out.purple().out("MIRCallFunc").reset();
        out.light_orange().out(" 0x").out_hex(self => i64).reset();
        
        var tn = self->resolved_type.full_path_name(pkg, true);
        out.cyan().out(" [type: ").out(tn.c_str).out("]").reset();
        tn.delete();

        out.out(" ");
        self->base.location.dump(out);

        var t = self->args => mir*;
        t->dump(out, pkg, depth + 1);
    }
}

pub struct mir_get_field {
    base: mir,
    name: str,
    resolved_type: type
}

impl mir_get_field {
    pub func new(l: span*, n: str*, t: type*) -> mir_get_field* {
        var res = mir_get_field::__alloc__();
        res->base = mir::instance(mir_kind::mir_get_field, l);
        res->name = n->copy_instance();
        res->resolved_type = t->copy_instance();
        return res;
    }

    pub func delete(self) {
        self->name.delete();
        self->resolved_type.delete();
    }

    pub func dump(self, out: io, pkg: package*, depth: u32) {
        out.purple().out("MIRGetField").reset();
        out.light_orange().out(" 0x").out_hex(self => i64).reset();
        out.out(" ").green().out(self->name.c_str).reset();

        var tn = self->resolved_type.full_path_name(pkg, true);
        out.cyan().out(" [type: ").out(tn.c_str).out("]").reset();
        tn.delete();

        out.out(" ");
        self->base.location.dump(out);
    }
}

pub struct mir_ptr_get_field {
    base: mir,
    name: str,
    resolved_type: type
}

impl mir_ptr_get_field {
    pub func new(l: span*, n: str*, t: type*) -> mir_ptr_get_field* {
        var res = mir_ptr_get_field::__alloc__();
        res->base = mir::instance(mir_kind::mir_ptr_get_field, l);
        res->name = n->copy_instance();
        res->resolved_type = t->copy_instance();
        return res;
    }

    pub func delete(self) {
        self->name.delete();
        self->resolved_type.delete();
    }

    pub func dump(self, out: io, pkg: package*, depth: u32) {
        out.purple().out("MIRPtrGetField").reset();
        out.light_orange().out(" 0x").out_hex(self => i64).reset();
        out.out(" ").green().out(self->name.c_str).reset();

        var tn = self->resolved_type.full_path_name(pkg, true);
        out.cyan().out(" [type: ").out(tn.c_str).out("]").reset();
        tn.delete();

        out.out(" ");
        self->base.location.dump(out);
    }
}

pub struct mir_get_path {
    base: mir,
    name: str,
    resolved_type: type
}

impl mir_get_path {
    pub func new(l: span*, n: str*, t: type*) -> mir_get_path* {
        var res = mir_get_path::__alloc__();
        res->base = mir::instance(mir_kind::mir_get_path, l);
        res->name = n->copy_instance();
        res->resolved_type = t->copy_instance();
        return res;
    }

    pub func delete(self) {
        self->name.delete();
        self->resolved_type.delete();
    }

    pub func dump(self, out: io, pkg: package*, depth: u32) {
        out.purple().out("MIRGetPath").reset();
        out.light_orange().out(" 0x").out_hex(self => i64).reset();
        out.out(" ").green().out(self->name.c_str).reset();

        var tn = self->resolved_type.full_path_name(pkg, true);
        out.cyan().out(" [type: ").out(tn.c_str).out("]").reset();
        tn.delete();

        out.out(" ");
        self->base.location.dump(out);
    }
}

pub struct mir_define {
    base: mir,
    name: str,
    init_value: mir_block*,
    resolved_type: type
}

impl mir_define {
    pub func new(l: span*, n: str*, v: mir_block*, t: type*) -> mir_define* {
        var res = mir_define::__alloc__();
        res->base = mir::instance(mir_kind::mir_define, l);
        res->name = n->copy_instance();
        res->init_value = v;
        res->resolved_type = t->copy_instance();
        return res;
    }

    pub func delete(self) {
        self->name.delete();
        if (self->init_value != nil) {
            var n = self->init_value => mir*;
            n->delete();
            free(n => i8*);
        }
        self->resolved_type.delete();
    }

    pub func dump(self, out: io, pkg: package*, depth: u32) {
        out.purple().out("MIRDefine").reset();
        out.light_orange().out(" 0x").out_hex(self => i64).reset();
        out.out(" ").green().out(self->name.c_str).reset();
        
        var tn = self->resolved_type.full_path_name(pkg, true);
        out.cyan().out(" [type: ").out(tn.c_str).out("]").reset();
        tn.delete();

        out.out(" ");
        self->base.location.dump(out);

        var t = self->init_value => mir*;
        t->dump(out, pkg, depth + 1);
    }
}

pub struct mir_assign {
    base: mir,
    opr: mir_assign_opr,
    left: mir_block*,
    right: mir_block*
}

impl mir_assign {
    pub func new(l: span*,
                 o: mir_assign_opr,
                 lhs: mir_block*,
                 rhs: mir_block*) -> mir_assign* {
        var res = mir_assign::__alloc__();
        res->base = mir::instance(mir_kind::mir_assign, l);
        res->opr = o;
        res->left = lhs;
        res->right = rhs;
        return res;
    }

    pub func delete(self) {
        if (self->left != nil) {
            var n= self->left => mir*;
            n->delete();
            free(n => i8*);
        }
        if (self->right != nil) {
            var n= self->right => mir*;
            n->delete();
            free(n => i8*);
        }
    }

    pub func dump(self, out: io, pkg: package*, depth: u32) {
        out.purple().out("MIRAssign").reset();
        out.light_orange().out(" 0x").out_hex(self => i64).reset();

        match (self->opr) {
            mir_assign_opr::eq => out.green().out(" = ").reset();
            mir_assign_opr::addeq => out.green().out(" += ").reset();
            mir_assign_opr::subeq => out.green().out(" -= ").reset();
            mir_assign_opr::muleq => out.green().out(" *= ").reset();
            mir_assign_opr::diveq => out.green().out(" /= ").reset();
            mir_assign_opr::remeq => out.green().out(" %= ").reset();
            mir_assign_opr::andeq => out.green().out(" &= ").reset();
            mir_assign_opr::oreq => out.green().out(" |= ").reset();
            mir_assign_opr::xoreq => out.green().out(" ^= ").reset();
        }
        self->base.location.dump(out);

        var t = self->left => mir*;
        t->dump(out, pkg, depth + 1);
        t = self->right => mir*;
        t->dump(out, pkg, depth + 1);
    }
}

pub struct mir_if {
    base: mir,
    condition: mir_block*,
    content: mir_block*
}

impl mir_if {
    pub func new(l: span*, cond: mir_block*, ctt: mir_block*) -> mir_if* {
        var res = mir_if::__alloc__();
        res->base = mir::instance(mir_kind::mir_if, l);
        res->condition = cond;
        res->content = ctt;
        return res;
    }

    pub func delete(self) {
        if (self->condition != nil) {
            var n= self->condition => mir*;
            n->delete();
            free(n => i8*);
        }
        if (self->content != nil) {
            var n= self->content => mir*;
            n->delete();
            free(n => i8*);
        }
    }

    pub func dump(self, out: io, pkg: package*, depth: u32) {
        if (self->condition != nil) {
            out.purple().out("MIRIf").reset();
            out.light_orange().out(" 0x").out_hex(self => i64).reset().out(" ");
            self->base.location.dump(out);
            var t = self->condition => mir*;
            t->dump(out, pkg, depth + 1);
        } else {
            out.purple().out("MIRElse").reset();
            out.light_orange().out(" 0x").out_hex(self => i64).reset().out(" ");
            self->base.location.dump(out);
        }

        if (self->content != nil) {
            var t = self->content => mir*;
            t->dump(out, pkg, depth + 1);
        }
    }
}

pub struct mir_branch {
    base: mir,
    branch: primitive_vec<ptr<mir_if>>
}

impl mir_branch {
    pub func new(l: span*) -> mir_branch* {
        var res = mir_branch::__alloc__();
        res->base = mir::instance(mir_kind::mir_branch, l);
        res->branch = primitive_vec<ptr<mir_if>>::instance();
        return res;
    }

    pub func delete(self) {
        foreach (var i; self->branch) {
            var n = i.get().unwrap() => mir*;
            n->delete();
            free(n => i8*);
        }
        self->branch.delete();
    }

    pub func dump(self, out: io, pkg: package*, depth: u32) {
        out.purple().out("MIRBranch").reset();
        out.light_orange().out(" 0x").out_hex(self => i64).reset();
        out.out(" ");
        self->base.location.dump(out);

        foreach (var i; self->branch) {
            var n = i.get().unwrap() => mir*;
            n->dump(out, pkg, depth + 1);
        }
    }
}

pub struct mir_switch_case {
    base: mir,
    value: i64,
    content: mir_block*
}

impl mir_switch_case {
    pub func new(l: span*, i: i64, ctt: mir_block*) -> mir_switch_case* {
        var res = mir_switch_case::__alloc__();
        res->base = mir::instance(mir_kind::mir_switch_case, l);
        res->value = i;
        res->content = ctt;
        return res;
    }

    pub func delete(self) {
        if (self->content != nil) {
            var n= self->content => mir*;
            n->delete();
            free(n => i8*);
        }
    }

    pub func dump(self, out: io, pkg: package*, depth: u32) {
        out.purple().out("MIRSwitchCase").reset();
        out.light_orange().out(" 0x").out_hex(self => i64).reset();
        out.green().out(" ").out_i64(self->value).reset().out(" ");
        self->base.location.dump(out);

        var t = self->content => mir*;
        t->dump(out, pkg, depth + 1);
    }
}

pub struct mir_switch {
    base: mir,
    condition: mir_block*,
    cases: primitive_vec<ptr<mir_switch_case>>,
    default_case: mir_block*
}

impl mir_switch {
    pub func new(l: span*, cond: mir_block*) -> mir_switch* {
        var res = mir_switch::__alloc__();
        res->base = mir::instance(mir_kind::mir_switch, l);
        res->condition = cond;
        res->cases = primitive_vec<ptr<mir_switch_case>>::instance();
        res->default_case = nil;
        return res;
    }

    pub func delete(self) {
        if (self->condition != nil) {
            var n= self->condition => mir*;
            n->delete();
            free(n => i8*);
        }
        foreach (var i; self->cases) {
            var n = i.get().unwrap() => mir*;
            n->delete();
            free(n => i8*);
        }
        self->cases.delete();
        if (self->default_case != nil) {
            var n= self->default_case => mir*;
            n->delete();
            free(n => i8*);
        }
    }

    pub func dump(self, out: io, pkg: package*, depth: u32) {
        out.purple().out("MIRSwitch").reset();
        out.light_orange().out(" 0x").out_hex(self => i64).reset().out(" ");
        self->base.location.dump(out);

        if (self->condition != nil) {
            var t = self->condition => mir*;
            t->dump(out, pkg, depth + 1);
        }
        foreach (var i; self->cases) {
            var n = i.get().unwrap() => mir*;
            n->dump(out, pkg, depth + 1);
        }
        if (self->default_case != nil) {
            var t = self->default_case => mir*;
            t->dump(out, pkg, depth + 1);
        }
    }
}

pub struct mir_break {
    base: mir
}

impl mir_break {
    pub func new(l: span*) -> mir_break* {
        var res = mir_break::__alloc__();
        res->base = mir::instance(mir_kind::mir_break, l);
        return res;
    }

    pub func delete(self) {}

    pub func dump(self, out: io, pkg: package*, depth: u32) {
        out.purple().out("MIRBreak").reset();
        out.light_orange().out(" 0x").out_hex(self => i64).reset().out(" ");
        self->base.location.dump(out);
    }
}

pub struct mir_continue {
    base: mir
}

impl mir_continue {
    pub func new(l: span*) -> mir_continue* {
        var res = mir_continue::__alloc__();
        res->base = mir::instance(mir_kind::mir_continue, l);
        return res;
    }

    pub func delete(self) {}

    pub func dump(self, out: io, pkg: package*, depth: u32) {
        out.purple().out("MIRContinue").reset();
        out.light_orange().out(" 0x").out_hex(self => i64).reset().out(" ");
        self->base.location.dump(out);
    }
}

pub struct mir_loop {
    base: mir,
    condition: mir_block*,
    content: mir_block*,
    update: mir_block*
}

impl mir_loop {
    pub func new(l: span*,
                 cond: mir_block*,
                 ctt: mir_block*,
                 updt: mir_block*) -> mir_loop* {
        var res = mir_loop::__alloc__();
        res->base = mir::instance(mir_kind::mir_loop, l);
        res->condition = cond;
        res->content = ctt;
        res->update = updt;
        return res;
    }

    pub func delete(self) {
        if (self->condition != nil) {
            var n= self->condition => mir*;
            n->delete();
            free(n => i8*);
        }
        if (self->content != nil) {
            var n= self->content => mir*;
            n->delete();
            free(n => i8*);
        }
        if (self->update != nil) {
            var n= self->update => mir*;
            n->delete();
            free(n => i8*);
        }
    }

    pub func dump(self, out: io, pkg: package*, depth: u32) {
        out.purple().out("MIRLoop").reset();
        out.light_orange().out(" 0x").out_hex(self => i64).reset().out(" ");
        self->base.location.dump(out);
        if (self->condition != nil) {
            var t = self->condition => mir*;
            t->dump(out, pkg, depth + 1);
        }
        if (self->content != nil) {
            var t = self->content => mir*;
            t->dump(out, pkg, depth + 1);
        }
        if (self->update != nil) {
            var t = self->update => mir*;
            t->dump(out, pkg, depth + 1);
        }
    }
}

pub struct mir_return {
    base: mir,
    value: mir_block*
}

impl mir_return {
    pub func new(l: span*, v: mir_block*) -> mir_return* {
        var res = mir_return::__alloc__();
        res->base = mir::instance(mir_kind::mir_return, l);
        res->value = v;
        return res;
    }

    pub func delete(self) {
        if (self->value != nil) {
            var n= self->value => mir*;
            n->delete();
        }
    }

    pub func dump(self, out: io, pkg: package*, depth: u32) {
        out.purple().out("MIRRet").reset();
        out.light_orange().out(" 0x").out_hex(self => i64).reset().out(" ");
        self->base.location.dump(out);

        if (self->value != nil) {
            var t = self->value => mir*;
            t->dump(out, pkg, depth + 1);
        }
    }
}
