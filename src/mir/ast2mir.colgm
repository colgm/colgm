use std::str::{ str };
use std::libc::{ free };
use std::io::{ io };
use std::ptr::{ ptr };

use err::report::{ report };
use err::span::{ span };
use err::panic::{ unreachable };

use ast::ast::*;
use ast::dumper::{ ast_dumper };

use sema::type::{ type };
use sema::context::{ sema_context };
use sema::type_resolve::{ type_resolve };

use mir::mir::*;
use mir::context::{ mir_context, mir_struct, mir_func };

use package::{ package };

pub struct ast2mir {
    err: report*,
    ctx: sema_context*,
    tr: type_resolve,
    pkg: package*,

    mctx: mir_context*,
    impl_struct_name: str,
    block: mir_block*
}

impl ast2mir {
    pub func instance(e: report*,
                      c: sema_context*,
                      p: package*,
                      m: mir_context*) -> ast2mir {
        return ast2mir {
            err: e,
            ctx: c,
            tr: type_resolve::instance(e, c, p),
            pkg: p,
            mctx: m,
            impl_struct_name: str::instance(),
            block: nil
        };
    }

    pub func delete(self) {
        self->impl_struct_name.delete();
        if (self->block != nil) {
            var n = self->block => mir*;
            n->delete();
            free(n => i8*);
        }
    }
}

impl ast2mir {
    func visit(self, a: ast*) {
        match (a->kind) {
            ast_kind::ast_null => {}
            ast_kind::ast_root => { unreachable(); }
            ast_kind::ast_unary_operator => {
                self->visit_unary_operator(a => ast_unary_operator*);
            }
            ast_kind::ast_binary_operator => {
                self->visit_binary_operator(a => ast_binary_operator*);
            }
            ast_kind::ast_type_convert => {
                self->visit_type_convert(a => ast_type_convert*);
            }
            ast_kind::ast_nil_literal => {
                self->visit_nil_literal(a => ast_nil_literal*);
            }
            ast_kind::ast_number_literal => {
                self->visit_number_literal(a => ast_number_literal*);
            }
            ast_kind::ast_string_literal => {
                self->visit_string_literal(a => ast_string_literal*);
            }
            ast_kind::ast_char_literal => {
                self->visit_char_literal(a => ast_char_literal*);
            }
            ast_kind::ast_bool_literal => {
                self->visit_bool_literal(a => ast_bool_literal*);
            }
            _ => {}
        }
    }

    func visit_unary_operator(self, n: ast_unary_operator*) {
        // TODO
        self->visit(n->value);
        return;
    }

    func visit_binary_operator(self, n: ast_binary_operator*) {
        // TODO
        self->visit(n->left);
        self->visit(n->right);
        return;
    }

    func visit_type_convert(self, n: ast_type_convert*) {
        // TODO
        self->visit(n->from);
        return;
    }

    func visit_nil_literal(self, n: ast_nil_literal*) {
        var m = mir_nil::new(
            n->base.location,
            n->base.resolved_type.__ptr__()
        );
        self->block->content.push(ptr<mir>::wrap(m => mir*));
        return;
    }

    func visit_number_literal(self, n: ast_number_literal*) {
        var m = mir_number::new(
            n->base.location,
            n->literal.__ptr__(),
            n->base.resolved_type.__ptr__()
        );
        self->block->content.push(ptr<mir>::wrap(m => mir*));
        return;
    }

    func visit_string_literal(self, n: ast_string_literal*) {
        var m = mir_string::new(
            n->base.location,
            n->literal.__ptr__(),
            n->base.resolved_type.__ptr__()
        );
        self->block->content.push(ptr<mir>::wrap(m => mir*));
        return;
    }

    func visit_char_literal(self, n: ast_char_literal*) {
        var m = mir_char::new(
            n->base.location,
            n->literal.__ptr__(),
            n->base.resolved_type.__ptr__()
        );
        self->block->content.push(ptr<mir>::wrap(m => mir*));
        return;
    }

    func visit_bool_literal(self, n: ast_bool_literal*) {
        var m = mir_bool::new(
            n->base.location,
            n->flag,
            n->base.resolved_type.__ptr__()
        );
        self->block->content.push(ptr<mir>::wrap(m => mir*));
        return;
    }
}

impl ast2mir {
    func generate_full_name(self, n: str*, loc: span*) -> str {
        var ty = type::instance();
        ty.name.append_str(n);
        ty.loc_file.append_str(loc->file.__ptr__());
        var name = ty.full_path_name(self->pkg, false);
        ty.delete();
        return name;
    }

    func visit_enum_decl(self, n: ast_enum_decl*) { return; }

    func visit_struct_decl(self, n: ast_struct_decl*) {
        if (n->generic_types != nil) {
            return;
        }

        var st = mir_struct::instance(n->name.__ptr__(), n->base.location);
        for (var i = n->fields.iter(); !i.is_end(); i = i.next()) {
            var f = i.get().unwrap() => ast_struct_field*;
            var t = self->tr.resolve(f->type);
            st.field_type.push(t.__ptr__());
            t.delete();
        }
        self->mctx->structs.push(st.__ptr__());
        st.delete();
    }

    func visit_impl(self, n: ast_impl*) {
        if (n->generic_types != nil) {
            return;
        }
        self->impl_struct_name.clear();
        self->impl_struct_name.append_str(n->name.__ptr__());
        for (var i = n->methods.iter(); !i.is_end(); i = i.next()) {
            var m = i.get().unwrap() => ast_func_decl*;
            self->visit_func_decl(m);
        }
        self->impl_struct_name.clear();
    }
    
    func visit_func_decl(self, n: ast_func_decl*) {
        if (n->generic_types != nil) {
            return;
        }

        var name = n->name.copy_instance();
        if (!self->impl_struct_name.empty()) {
            var tmp_ty_name = self->generate_full_name(
                self->impl_struct_name.__ptr__(),
                n->base.location
            );
            name.clear();
            name.append_str(tmp_ty_name.__ptr__())
                ->append_i8_vec(".")
                ->append_str(n->name.__ptr__());
            tmp_ty_name.delete();
        }

        // global function with is not extern
        if (self->impl_struct_name.empty() && !n->is_extern) {
            var tmp_ty_name = self->generate_full_name(
                n->name.__ptr__(),
                n->base.location
            );
            name.clear();
            name.append_str(tmp_ty_name.__ptr__());
            tmp_ty_name.delete();
        }

        
        var ret_ty = type::instance();
        if (n->return_type != nil) {
            var t = self->tr.resolve(n->return_type);
            ret_ty.reset_with(t.__ptr__());
            t.delete();
        } else {
            var t = type::void_type();
            ret_ty.reset_with(t.__ptr__());
            t.delete();
        }
        var f = mir_func::instance(
            name.__ptr__(),
            n->base.location,
            ret_ty.__ptr__()
        );

        for (var i = n->params->params.iter(); !i.is_end(); i = i.next()) {
            var p = i.get().unwrap() => ast_param*;
            var t = self->tr.resolve(p->type);
            f.param_name.push(p->name->content.__ptr__());
            f.param_type.push(t.__ptr__());
            t.delete();
        }

        ret_ty.delete();
        name.delete();

        if (n->body == nil) {
            self->mctx->decls.push(f.__ptr__());
            f.delete();
            return;
        }

        self->block = mir_block::new(n->body->base.location);
        f.block = self->block;
        for (var i = n->body->stmts.iter(); !i.is_end(); i = i.next()) {
            var stmt = i.get().unwrap();
            self->visit(stmt);
            if (stmt->is(ast_kind::ast_ret_stmt) ||
                stmt->is(ast_kind::ast_break_stmt) ||
                stmt->is(ast_kind::ast_continue_stmt)) {
                break;
            }
        }
        self->block = nil;

        self->mctx->impls.push(f.__ptr__());
        f.delete();
    }
}

impl ast2mir {
    pub func generate(self, r: root*) {
        io::stdout()
            .out("[ast2mir] worker 0x")
            .out_hex(self => i64)
            .out(" generating MIR for <")
            .out(r->base.location->file.c_str)
            .out("> ...")
            .endln();
        for (var i = r->decls.iter(); !i.is_end(); i = i.next()) {
            var n = i.get().unwrap();
            match (n->kind) {
                ast_kind::ast_enum_decl => {
                    self->visit_enum_decl(n => ast_enum_decl*);
                }
                ast_kind::ast_struct_decl => {
                    self->visit_struct_decl(n => ast_struct_decl*);
                }
                ast_kind::ast_impl => {
                    self->visit_impl(n => ast_impl*);
                }
                ast_kind::ast_func_decl => {
                    self->visit_func_decl(n => ast_func_decl*);
                }
                _ => { unreachable(); }
            }
        }
    }
}