use mir::mir::*;
use mir::context::*;

use std::io::{ io };
use std::str::{ str };

pub struct mir2nasal {
    ctx: mir_context*
}

impl mir2nasal {
    pub func instance(ctx: mir_context*) -> mir2nasal {
        return mir2nasal { ctx: ctx };
    }

    func dump_raw_nasal_string(self, out: io, s: str*) {
        var tmp = str::instance();
        defer tmp.delete();

        for (var i: u64 = 0; i < s->size; i += 1) {
            var c = s->c_str[i];
            if (c == '\"') {
                tmp.append("\\\"");
            } elsif (c == '\\') {
                tmp.append("\\\\");
            } elsif (c == '\n') {
                tmp.append("\\n");
            } elsif (c == '\r') {
                tmp.append("\\r");
            } elsif (c == '\t') {
                tmp.append("\\t");
            } elsif (c == '\e') {
                tmp.append("\\e");
            } else {
                tmp.append_char(c);
            }
        }

        out.out(tmp.c_str);
    }

    pub func dump(self, filename: const i8*) {
        var out = io::fileout(filename);
        defer out.close();

        out.out("# generated by colgm\n\n");
        out.out("var colgm_T = {};\n");
        foreach (var i; self->ctx->tagged_unions) {
            self->dump_tagged_union(out, i.get());
        }
        foreach (var i; self->ctx->structs) {
            self->dump_struct(out, i.get());
        }

        out.out("var colgm_F = {};\n");
        foreach (var i; self->ctx->decls) {
            self->dump_func(out, i.get());
        }
        out.out("\n");
        foreach (var i; self->ctx->impls) {
            self->dump_func(out, i.get());
            out.out("\n");
        }
    }
}

impl mir2nasal {
    func dump_tagged_union(self, out: io, t: mir_tagged_union*) {
        out.out("colgm_T[\"");
        self->dump_raw_nasal_string(out, t->name.__ptr__());
        out.out("\"] = { tag: 0, value: nil };\n");
    }

    func dump_struct(self, out: io, s: mir_struct*) {
        out.out("colgm_T[\"");
        self->dump_raw_nasal_string(out, s->name.__ptr__());
        out.out("\"] = {};\n");
    }

    func dump_func(self, out: io, f: mir_func*) {
        out.out("colgm_F[\"");
        self->dump_raw_nasal_string(out, f->name.__ptr__());
        out.out("\"] = func(");
        foreach (var i; f->params) {
            out.out(i.get()->key.c_str);
            if (i.index() < f->params.size - 1) {
                out.out(", ");
            }
        }
        if (f->with_va_args) {
            out.out("...");
        }
        out.out(") ");
        if (f->block == nil) {
            out.out(" {}\n");
            return;
        }
        out.out("{\n");
        self->dump_block(out, f->block, 1);
        out.out("}\n");
    }
}

impl mir2nasal {
    func dump_indent(self, out: io, indent: i64) {
        for (var i = 0; i < indent; i += 1) {
            out.out("  ");
        }
    }

    func dump_mir(self, out: io, n: mir*, indent: i64) {
        match (n->kind) {
            mir_kind::mir_block => self->dump_block(out, n => mir_block*, indent + 1);
            mir_kind::mir_unary => self->dump_unary(out, n => mir_unary*, indent + 1);
            mir_kind::mir_binary => self->dump_binary(out, n => mir_binary*, indent + 1);
            mir_kind::mir_type_convert => {}
            mir_kind::mir_nil => out.out("# nil;\n");
            // mir_kind::mir_number =>
            // mir_kind::mir_string =>
            // mir_kind::mir_char =>
            // mir_kind::mir_bool =>
            // mir_kind::mir_array =>
            // mir_kind::mir_struct_init =>
            // mir_kind::mir_call =>
            // mir_kind::mir_call_id =>
            // mir_kind::mir_call_index =>
            // mir_kind::mir_call_func =>
            // mir_kind::mir_get_field =>
            // mir_kind::mir_get_path =>
            // mir_kind::mir_ptr_get_field =>
            // mir_kind::mir_define =>
            // mir_kind::mir_assign =>
            // mir_kind::mir_if =>
            // mir_kind::mir_branch =>
            // mir_kind::mir_switch_case =>
            // mir_kind::mir_switch =>
            // mir_kind::mir_break =>
            // mir_kind::mir_continue =>
            // mir_kind::mir_loop =>
            // mir_kind::mir_return =>
            _ => {
                self->dump_indent(out, indent);
                out.out("# node kind ").out_i64(n->kind => i64).endln();
            }
        }
    }

    func dump_block(self, out: io, n: mir_block*, indent: i64) {
        self->dump_indent(out, indent);
        foreach (var i; n->content) {
            self->dump_mir(out, i.get(), indent + 1);
        }
    }

    func dump_unary(self, out: io, n: mir_unary*, indent: i64) {
        self->dump_indent(out, indent);
        out.out("# ");
        match (n->op) {
            mir_unary_opr::neg => out.out("-");
            mir_unary_opr::bnot => out.out("~");
            mir_unary_opr::lnot => out.out("!");
        }
        out.out("(");
        self->dump_mir(out, n->value => mir*, indent + 1);
        out.out(")\n");
    }

    func dump_binary(self, out: io, n: mir_binary*, indent: i64) {
        self->dump_indent(out, indent);
        out.out("# (");
        self->dump_mir(out, n->left => mir*, indent + 1);
        out.out(") ");
        match (n->op) {
            mir_binary_opr::add => out.out("+");
            mir_binary_opr::sub => out.out("-");
            mir_binary_opr::mul => out.out("*");
            mir_binary_opr::div => out.out("/");
            mir_binary_opr::rem => out.out("%");
            mir_binary_opr::cmpeq => out.out("==");
            mir_binary_opr::cmpne => out.out("!=");
            mir_binary_opr::less => out.out("<");
            mir_binary_opr::leq => out.out("<=");
            mir_binary_opr::grt => out.out(">");
            mir_binary_opr::geq => out.out(">=");
            mir_binary_opr::cmpand => out.out("&&");
            mir_binary_opr::cmpor => out.out("||");
            mir_binary_opr::band => out.out("&");
            mir_binary_opr::bor => out.out("|");
            mir_binary_opr::bxor => out.out("^");
        }
        out.out(" (");
        self->dump_mir(out, n->right => mir*, indent + 1);
        out.out(")\n");
    }
}