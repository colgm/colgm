use mir::mir::*;
use mir::context::*;

use sema::context::{ global_symbol_table };
use sema::type::{ type };

use util::package::{ package };
use util::cli::{ version };

use std::io::{ io };
use std::str::{ str };
use std::panic::{ unreachable };

pub struct mir2nasal {
    global: global_symbol_table*,
    ctx: mir_context*,
    pkg: package*
}

impl mir2nasal {
    pub func instance(glb: global_symbol_table*,
                      ctx: mir_context*,
                      pkg: package*) -> mir2nasal {
        return mir2nasal { global: glb, ctx: ctx, pkg: pkg };
    }

    func dump_raw_nasal_string(self, out: io&, s: str&) {
        var tmp = str::instance();
        defer tmp.delete();

        for (var i: u64 = 0; i < s.size; i += 1) {
            var c = s.c_str[i];
            if (c == '\"') {
                tmp.append("\\\"");
            } elsif (c == '\'') {
                tmp.append("\\\'");
            } elsif (c == '\\') {
                tmp.append("\\\\");
            } elsif (c == '\n') {
                tmp.append("\\n");
            } elsif (c == '\r') {
                tmp.append("\\r");
            } elsif (c == '\t') {
                tmp.append("\\t");
            } elsif (c == '\e') {
                tmp.append("\\e");
            } elsif (c == '\v') {
                tmp.append("\\v");
            } elsif (c == '\f') {
                tmp.append("\\f");
            } else {
                tmp.append_char(c);
            }
        }

        out.out(tmp.c_str);
    }

    pub func dump(self, filename: const i8*) {
        var out = io::fileout(filename);
        defer out.close();

        out.out("# generated by colgm ").out(version()).out("\n");
        out.out("use std.math;\n\n");

        out.out("var colgm_T = {};\n");
        out.out("var colgm_F = {};\n");

        out.out("\n# basic types\n");
        self.dump_basic(out);
        out.out("\n# tagged union types\n");
        foreach (var i; self.ctx->tagged_unions) {
            self.dump_tagged_union(out, i.get());
        }
        out.out("\n# struct types\n");
        foreach (var i; self.ctx->structs) {
            self.dump_struct(out, i.get());
        }

        foreach (var i; self.ctx->decls) {
            self.dump_func(out, i.get());
        }
        out.out("\n");
        foreach (var i; self.ctx->impls) {
            self.dump_func(out, i.get());
            out.out("\n");
        }

        out.out("exit(colgm_F[\"main\"](1, [\"nasal\"]));\n");
    }
}

impl mir2nasal {
    func dump_basic(self, out: io&) {
        var basic = [
            "i8", "i16", "i32", "i64",
            "u8", "u16", "u32", "u64",
            "f32", "f64", "bool", nil
        ];
        for (var i = 0; basic[i] != nil; i += 1) {
            out.out("colgm_T[\"").out(basic[i]).out("\"] = func { return 0; }\n");
        }
    }

    func dump_tagged_union(self, out: io&, t: mir_tagged_union&) {
        out.out("colgm_T[\"");
        self.dump_raw_nasal_string(out, t.name);
        out.out("\"] = func { return { tag: 0, value: nil }; }\n");
    }

    func dump_struct(self, out: io&, s: mir_struct&) {
        out.out("colgm_T[\"");
        var s_ty = type::instance(s.name.c_str, s.location.file.c_str);
        defer s_ty.delete();
        
        var s_ty_name = s_ty.full_path_name(self.pkg);
        defer s_ty_name.delete();
        self.dump_raw_nasal_string(out, s_ty_name);

        out.out("\"] = ");
        if (s.field_name.empty()) {
            out.out("func { return {}; }\n");
            return;
        }
        out.out("func {\n");
        out.out("  var res = {\n");
        foreach (var i; s.field_name) {
            out.out("    \"").out(i.get().c_str).out("\": ");
            if (s.field_type.get(i.index()).is_pointer()) {
                out.out("nil");
            } else {
                var ty_name = s.field_type.get(i.index()).full_path_name(self.pkg);
                defer ty_name.delete();
                out.out("colgm_T[\"").out(ty_name.c_str).out("\"]()");
            }
            if (i.index() < s.field_name.size - 1) {
                out.out(",");
            }
            out.out("\n");
        }
        out.out("  };\n");

        // load method
        var dm = self.global->domain.get(s.location.file);
        var name_for_search = s_ty.generic_name(self.pkg);
        defer name_for_search.delete();
        var st = dm.structs.get(name_for_search);
        foreach (var i; st.method) {
            if (i.key().startswith("#")) {
                continue;
            }
            if (i.key().eq_const("__ptr__")) {
                out.out("  res.__ptr__ = func { return me; };\n");
                continue;
            }
            out.out("  res.").out(i.value().name.c_str);
            out.out(" = colgm_F[\"").out(s_ty_name.c_str).out(".");
            out.out(i.value().name.c_str).out("\"];\n");
        }

        out.out("  return res;\n");
        out.out("}\n");

        out.out("colgm_F[\"").out(s_ty_name.c_str).out(".__size__\"] = func ");
        out.out("{ return ").out_u64(s.size).out("; }\n");
    }

    func dump_func(self, out: io&, f: mir_func&) {
        out.out("colgm_F[\"");
        self.dump_raw_nasal_string(out, f.name);
        out.out("\"] = func(");

        var has_self = false;
        foreach (var i; f.params) {
            if (i.get().key.eq_const("self")) {
                has_self = true;
                continue;
            }
            out.out(i.get().key.c_str);
            if (i.index() < f.params.size - 1) {
                out.out(", ");
            }
        }
        if (f.with_va_args) {
            out.out("...");
        }
        out.out(") ");
        if (f.block == nil) {
            out.out(" {}\n");
            return;
        }
        out.out("{\n");
        if (has_self) {
            out.out("  var self = me;\n");
        }
        self.dump_code_block(out, f.block, 1);
        out.out("}\n");
    }
}

impl mir2nasal {
    func dump_indent(self, out: io&, indent: i64) {
        for (var i = 0; i < indent; i += 1) {
            out.out("  ");
        }
    }

    func dump_mir(self, out: io&, n: mir*, indent: i64) {
        match (n->kind) {
            mir_kind::mir_block => self.dump_block(out, n => mir_block*, indent);
            mir_kind::mir_unary => self.dump_unary(out, n => mir_unary*, indent);
            mir_kind::mir_binary => self.dump_binary(out, n => mir_binary*, indent);
            mir_kind::mir_type_convert => self.dump_type_convert(out, n => mir_type_convert*, indent);
            mir_kind::mir_nil => out.out("nil");
            mir_kind::mir_number => {
                var t = n => mir_number*;
                out.out(t->value.c_str);
            }
            mir_kind::mir_string => {
                var t = n => mir_string*;
                out.out("\"");
                self.dump_raw_nasal_string(out, t->value);
                out.out("\"");
            }
            mir_kind::mir_char => {
                var t = n => mir_char*;
                out.out("'");
                self.dump_raw_nasal_string(out, t->value);
                out.out("'");
            }
            mir_kind::mir_bool => {
                var t = n => mir_bool*;
                if (t->value) {
                    out.out("true");
                } else {
                    out.out("false");
                }
            }
            mir_kind::mir_array => out.out("[]");
            mir_kind::mir_call => self.dump_call(out, n => mir_call*, indent);
            mir_kind::mir_struct_init => unreachable();
            mir_kind::mir_call_id => unreachable();
            mir_kind::mir_call_index => unreachable();
            mir_kind::mir_call_func => unreachable();
            mir_kind::mir_get_field => unreachable();
            mir_kind::mir_get_path => unreachable();
            mir_kind::mir_ptr_get_field => unreachable();
            mir_kind::mir_define => self.dump_define(out, n => mir_define*, indent);
            mir_kind::mir_assign => self.dump_assign(out, n => mir_assign*, indent);
            mir_kind::mir_if => self.dump_if(out, n => mir_if*, indent);
            mir_kind::mir_branch => self.dump_branch(out, n => mir_branch*, indent);
            mir_kind::mir_switch_case => self.dump_switch_case(out, n => mir_switch_case*, indent);
            mir_kind::mir_switch => self.dump_switch(out, n => mir_switch*, indent);
            mir_kind::mir_break => out.out("break;");
            mir_kind::mir_continue => out.out("continue;");
            mir_kind::mir_loop => self.dump_loop(out, n => mir_loop*, indent);
            mir_kind::mir_return => self.dump_return(out, n => mir_return*, indent);
            _ => {
                out.out("# ").out_i64(n->kind => i64).endln();
            }
        }
    }

    func dump_code_block(self, out: io&, n: mir_block*, indent: i64) {
        foreach (var i; n->content) {
            if (i.get()->kind == mir_kind::mir_block) {
                self.dump_code_block(out, i.get() => mir_block*, indent);
            } else {
                self.dump_indent(out, indent);
                self.dump_mir(out, i.get(), indent);
                if (i.get()->kind == mir_kind::mir_call ||
                    i.get()->kind == mir_kind::mir_define ||
                    i.get()->kind == mir_kind::mir_assign ||
                    i.get()->kind == mir_kind::mir_return) {
                    out.out(";");
                }
                out.out("\n");
            }
        }
    }

    func dump_block(self, out: io&, n: mir_block*, indent: i64) {
        foreach (var i; n->content) {
            self.dump_mir(out, i.get(), indent);
        }
    }

    func dump_expr(self, out: io&, n: mir_block*, indent: i64) {
        if (n->content.size == 1 && (
            n->content.get(0)->kind == mir_kind::mir_call ||
            n->content.get(0)->kind == mir_kind::mir_number ||
            n->content.get(0)->kind == mir_kind::mir_string ||
            n->content.get(0)->kind == mir_kind::mir_nil ||
            n->content.get(0)->kind == mir_kind::mir_bool ||
            n->content.get(0)->kind == mir_kind::mir_char)) {
            self.dump_block(out, n, indent);
            return;
        }
        out.out("(");
        self.dump_block(out, n, indent);
        out.out(")");
    }

    func dump_unary(self, out: io&, n: mir_unary*, indent: i64) {
        out.out("(");
        match (n->op) {
            mir_unary_opr::neg => out.out("-");
            mir_unary_opr::bnot => out.out("~");
            mir_unary_opr::lnot => out.out("!");
        }
        self.dump_mir(out, n->value, indent);
        out.out(")");
    }

    func dump_binary(self, out: io&, n: mir_binary*, indent: i64) {
        if (n->op == mir_binary_opr::rem) {
            out.out("math.mod(");
            self.dump_mir(out, n->left, indent);
            out.out(", ");
            self.dump_mir(out, n->right, indent);
            out.out(")");
            return;
        }

        self.dump_mir(out, n->left, indent);
        out.out(" ");
        match (n->op) {
            mir_binary_opr::add => out.out("+");
            mir_binary_opr::sub => out.out("-");
            mir_binary_opr::mul => out.out("*");
            mir_binary_opr::div => out.out("/");
            mir_binary_opr::rem => {}
            mir_binary_opr::cmpeq => out.out("==");
            mir_binary_opr::cmpne => out.out("!=");
            mir_binary_opr::less => out.out("<");
            mir_binary_opr::leq => out.out("<=");
            mir_binary_opr::grt => out.out(">");
            mir_binary_opr::geq => out.out(">=");
            mir_binary_opr::cmpand => out.out("and");
            mir_binary_opr::cmpor => out.out("or");
            mir_binary_opr::band => out.out("&");
            mir_binary_opr::bor => out.out("|");
            mir_binary_opr::bxor => out.out("^");
        }
        out.out(" ");
        self.dump_mir(out, n->right, indent + 1);
    }

    func dump_type_convert(self, out: io&, n: mir_type_convert*, indent: i64) {
        self.dump_mir(out, n->source, indent);
    }

    func dump_call(self, out: io&, n: mir_call*, indent: i64) {
        var path = str::instance();
        defer path.delete();

        foreach (var i; n->content) {
            match (i.get()->kind) {
                mir_kind::mir_struct_init => {
                    if (!path.empty()) {
                        out.out("colgm_T[\"").out(path.c_str).out("\"]()");
                        path.clear();
                    } else {
                        out.out("{}");
                    }
                }
                mir_kind::mir_call_id => {
                    var t = i.get() => mir_call_id*;
                    if (t->resolved_type.is_global_sym) {
                        var full_name = t->resolved_type.full_path_name(self.pkg);
                        defer full_name.delete();

                        if (t->resolved_type.is_global_func) {
                            var dm = self.global->domain.get(t->resolved_type.loc_file);
                            var name_for_search = t->resolved_type.generic_name(self.pkg);
                            defer name_for_search.delete();

                            if (dm.functions.has(name_for_search) &&
                                dm.functions.get(name_for_search).is_extern) {
                                path.append_str(t->name);
                            } else {
                                path.append_str(full_name);
                            }
                        } else {
                            path.append_str(full_name);
                        }
                    } else {
                        out.out(t->name.c_str);
                    }
                }
                mir_kind::mir_call_index => {
                    var t = i.get() => mir_call_index*;
                    out.out("[");
                    self.dump_mir(out, t->index, indent);
                    out.out("]");
                }
                mir_kind::mir_call_func => {
                    if (!path.empty()) {
                        out.out("colgm_F[\"").out(path.c_str).out("\"]");
                        path.clear();
                    }
                    self.dump_call_func(out, i.get() => mir_call_func*, indent);
                }
                mir_kind::mir_get_field => {
                    var t = i.get() => mir_get_field*;
                    out.out(".").out(t->name.c_str);
                }
                mir_kind::mir_get_path => {
                    var t = i.get() => mir_get_path*;
                    path.append(".").append(t->name.c_str);
                    if (t->resolved_type.is_enum) {
                        var dm = self.global->domain.get(t->resolved_type.loc_file);
                        var em = dm.enums.get(t->resolved_type.name);
                        out.out_i64(em.members.get(t->name));
                        path.clear();
                    }
                }
                mir_kind::mir_ptr_get_field => {
                    var t = i.get() => mir_ptr_get_field*;
                    out.out(".").out(t->name.c_str);
                }
                _ => unreachable();
            }
        }
        if (!path.empty()) {
            if (path.find(':') != str::npos()) {
                unreachable();
            } else {
                out.out(path.c_str);
            }
        }
    }

    func dump_call_func(self, out: io&, n: mir_call_func*, indent: i64) {
        out.out("(");
        foreach (var i; n->args) {
            self.dump_mir(out, i.get(), indent);
            if (i.index() != n->args.size - 1) {
                out.out(", ");
            }
        }
        out.out(")");
    }

    func dump_define(self, out: io&, n: mir_define*, indent: i64) {
        out.out("var ").out(n->name.c_str).out(" = ");
        self.dump_mir(out, n->init_value => mir*, indent);
    }

    func dump_assign(self, out: io&, n: mir_assign*, indent: i64) {
        self.dump_mir(out, n->left => mir*, indent);
        match (n->opr) {
            mir_assign_opr::eq => out.out(" = ");
            mir_assign_opr::addeq => out.out(" += ");
            mir_assign_opr::subeq => out.out(" -= ");
            mir_assign_opr::muleq => out.out(" *= ");
            mir_assign_opr::diveq => out.out(" /= ");
            mir_assign_opr::remeq => out.out(" %= ");
            mir_assign_opr::andeq => out.out(" &= ");
            mir_assign_opr::oreq => out.out(" |= ");
            mir_assign_opr::xoreq => out.out(" ^= ");
        }
        self.dump_mir(out, n->right => mir*, indent);
    }

    func dump_if(self, out: io&, n: mir_if*, indent: i64) {
        if (n->condition != nil) {
            out.out(" (");
            self.dump_mir(out, n->condition, indent);
            out.out(")");
        }
        out.out(" {\n");
        self.dump_code_block(out, n->content, indent + 1);
        self.dump_indent(out, indent);
        out.out("}");
    }

    func dump_branch(self, out: io&, n: mir_branch*, indent: i64) {
        foreach (var i; n->branch) {
            if (i.index() == 0) {
                out.out("if");
            } elsif (i.get()->condition != nil) {
                out.out(" else if");
            } else {
                out.out(" else");
            }
            self.dump_if(out, i.get(), indent);
        }
    }

    func dump_switch_case(self, out: io&, n: mir_switch_case*, indent: i64) {
        out.out("(_ == ").out_i64(n->value).out(") {\n");
        self.dump_code_block(out, n->content, indent + 1);
        self.dump_indent(out, indent);
        out.out("}");
    }

    func dump_switch(self, out: io&, n: mir_switch*, indent: i64) {
        out.out("var _ = ");
        self.dump_mir(out, n->condition, indent);
        out.out(";\n");
        self.dump_indent(out, indent);
        foreach (var i; n->cases) {
            if (i.index() == 0) {
                out.out("if ");
            } else {
                out.out(" elsif ");
            }
            self.dump_switch_case(out, i.get(), indent);
        }
        if (n->default_case != nil) {
            out.out(" else {\n");
            self.dump_code_block(out, n->default_case, indent + 1);
            self.dump_indent(out, indent);
            out.out("}");
        }
    }

    func dump_loop(self, out: io&, n: mir_loop*, indent: i64) {
        if (n->update != nil) {
            out.out("for (; ");
        } else {
            out.out("while (");
        }
        if (n->condition != nil) {
            self.dump_mir(out, n->condition, indent);
        }
        if (n->update != nil) {
            out.out("; ");
            self.dump_block(out, n->update, indent);
        }
        out.out(") {\n");
        self.dump_code_block(out, n->content, indent + 1);
        self.dump_indent(out, indent);
        out.out("}");
    }

    func dump_return(self, out: io&, n: mir_return*, indent: i64) {
        out.out("return");
        if (n->value != nil) {
            out.out(" ");
            self.dump_mir(out, n->value, indent);
        }
    }
}