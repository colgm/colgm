use ast::ast::*;
use ast::dumper::{ ast_dumper };
use err::report::*;
use err::span::{ span };
use lexer::{ lexer, vec_token, tok_kind };
use std::libc::{ free, streq };
use std::io::{ io };
use std::str::{ str };

struct parser {
    err: report*,
    toks: vec_token*,
    root: root*,
    index: i64
}

impl parser {
    func tok_kind_to_content(kind: tok_kind) -> i8* {
        match(kind) {
            tok_kind::tok_null =>       return "<null>";
            tok_kind::tok_num =>        return "<number-literal>";
            tok_kind::tok_str =>        return "<string-literal>";
            tok_kind::tok_ch =>         return "<char-literal>";
            tok_kind::tok_id =>         return "<identifier>";
            tok_kind::tok_true =>       return "true";
            tok_kind::tok_false =>      return "false";
            tok_kind::tok_use =>        return "use";
            tok_kind::tok_enum =>       return "enum";
            tok_kind::tok_for =>        return "for";
            tok_kind::tok_forindex =>   return "forindex";
            tok_kind::tok_foreach =>    return "foreach";
            tok_kind::tok_while =>      return "while";
            tok_kind::tok_var =>        return "var";
            tok_kind::tok_struct =>     return "struct";
            tok_kind::tok_pub =>        return "pub";
            tok_kind::tok_impl =>       return "impl";
            tok_kind::tok_func =>       return "func";
            tok_kind::tok_match =>      return "match";
            tok_kind::tok_break =>      return "break";
            tok_kind::tok_continue =>   return "continue";
            tok_kind::tok_return =>     return "return";
            tok_kind::tok_if =>         return "if";
            tok_kind::tok_elsif =>      return "elsif";
            tok_kind::tok_else =>       return "else";
            tok_kind::tok_nil =>        return "nil";
            tok_kind::tok_lparen =>     return "(";
            tok_kind::tok_rparen =>     return ")";
            tok_kind::tok_lbracket =>   return "[";
            tok_kind::tok_rbracket =>   return "]";
            tok_kind::tok_lbrace =>     return "{";
            tok_kind::tok_rbrace =>     return "}";
            tok_kind::tok_semi =>       return ";";
            tok_kind::tok_op_and =>     return "&&";
            tok_kind::tok_op_or =>      return "||";
            tok_kind::tok_comma =>      return ",";
            tok_kind::tok_dot =>        return ".";
            tok_kind::tok_ellipsis =>   return "...";
            tok_kind::tok_quesmark =>   return "?";
            tok_kind::tok_colon =>      return ":";
            tok_kind::tok_coloncolon => return "::";
            tok_kind::tok_add =>        return "+";
            tok_kind::tok_sub =>        return "-";
            tok_kind::tok_mul =>        return "*";
            tok_kind::tok_div =>        return "/";
            tok_kind::tok_rem =>        return "%";
            tok_kind::tok_floater =>    return "~";
            tok_kind::tok_bit_and =>    return "&";
            tok_kind::tok_bit_or =>     return "|";
            tok_kind::tok_bit_xor =>    return "^";
            tok_kind::tok_op_not =>     return "!";
            tok_kind::tok_eq =>         return "=";
            tok_kind::tok_addeq =>      return "+=";
            tok_kind::tok_subeq =>      return "-=";
            tok_kind::tok_muleq =>      return "*=";
            tok_kind::tok_diveq =>      return "/=";
            tok_kind::tok_remeq =>      return "%=";
            tok_kind::tok_floatereq =>  return "~=";
            tok_kind::tok_bit_and_eq => return "&=";
            tok_kind::tok_bit_or_eq =>  return "|=";
            tok_kind::tok_bit_xor_eq => return "^=";
            tok_kind::tok_cmp_eq =>     return "==";
            tok_kind::tok_neq =>        return "!=";
            tok_kind::tok_less =>       return "<";
            tok_kind::tok_leq =>        return "<=";
            tok_kind::tok_grt =>        return ">";
            tok_kind::tok_geq =>        return ">=";
            tok_kind::tok_arrow =>      return "->";
            tok_kind::tok_wide_arrow => return "=>";
            tok_kind::tok_eof =>        return "<eof>";
        }
        return "<unknown>";
    }
}

impl parser {
    func new(e: report*, l: lexer*) -> parser* {
        var res = parser::__alloc__();
        res->err = e;
        res->toks = l->toks;
        res->root = nil => root*;
        res->index = 0;
        return res;
    }

    func delete(self) {
        if (self->root == (nil => root*)) {
            return;
        }
        io::stderr().out("[").green().out("parse").reset().out("]")
                    .out(" delete parse::root\n");
        self->root->delete();
        free(self->root => i8*);
    }

    func this_tok_loc_copy(self) -> span* {
        return self->toks->get(self->index).location->copy();
    }

    func this_tok_loc(self) -> span* {
        return self->toks->get(self->index).location;
    }

    func lookahead(self, kind: tok_kind) -> bool {
        return self->toks->get(self->index).kind == kind;
    }

    func next(self) {
        if (self->toks->get(self->index).kind == tok_kind::tok_eof) {
            return;
        }
        self->index += 1;
    }

    func match_token(self, kind: tok_kind) {
        var tp = self->toks->get(self->index).kind;
        if (tp == kind) {
            self->next();
            return;
        }
        var loc = self->toks->get(self->index).location;
        match (tp) {
            tok_kind::tok_id => {
                self->err->error(loc, "expected identifier here.");
                self->next();
                return;
            }
            tok_kind::tok_num => {
                self->err->error(loc, "expected number here.");
                self->next();
                return;
            }
            tok_kind::tok_str => {
                self->err->error(loc, "expected string here.");
                self->next();
                return;
            }
        }

        var error_message = str::instance();
        error_message.append_i8_vec("get \"")
                     ->append_str(self->toks->get(self->index).content)
                     ->append_i8_vec("\" here, but expected \"")
                     ->append_i8_vec(parser::tok_kind_to_content(kind))
                     ->append_i8_vec("\".");
        self->err->error(loc, error_message.c_str);
        error_message.delete();
        while (self->toks->get(self->index).kind != tok_kind::tok_eof &&
               self->toks->get(self->index).kind != kind) {
            self->next();
        }
    }
}

impl parser {
    func identifier_gen(self) -> ast_identifier* {
        var res = ast_identifier::new(
            self->this_tok_loc_copy(),
            self->toks->get(self->index).content
        );
        self->match_token(tok_kind::tok_id);
        return res;
    }

    func call_gen(self) -> ast_call* {
        # TODO: unfinished
        return ast_null::new() => ast_call*;
    }

    func nil_gen(self) -> ast_nil_literal* {
        var res = ast_nil_literal::new(self->this_tok_loc_copy());
        self->match_token(tok_kind::tok_nil);
        return res;
    }

    func number_literal_gen(self) -> ast_number_literal* {
        var res = ast_number_literal::new(
            self->this_tok_loc_copy(),
            self->toks->get(self->index).content
        );
        self->match_token(tok_kind::tok_num);
        return res;
    }

    func string_literal_gen(self) -> ast_string_literal* {
        var res = ast_string_literal::new(
            self->this_tok_loc_copy(),
            self->toks->get(self->index).content
        );
        self->match_token(tok_kind::tok_str);
        return res;
    }

    func char_gen(self) -> ast_char_literal* {
        var res = ast_char_literal::new(
            self->this_tok_loc_copy(),
            self->toks->get(self->index).content
        );
        self->match_token(tok_kind::tok_ch);
        return res;
    }

    func bool_gen(self) -> ast_bool_literal* {
        var res = nil => ast_bool_literal*;
        if (streq(self->toks->get(self->index).content->c_str, "true")) {
            res = ast_bool_literal::new(
                self->this_tok_loc_copy(),
                true
            );
            self->match_token(tok_kind::tok_true);
        } else if (streq(self->toks->get(self->index).content->c_str, "false")) {
            res = ast_bool_literal::new(
                self->this_tok_loc_copy(),
                false
            );
            self->match_token(tok_kind::tok_false);
        } else {
            self->err->error(
                self->toks->get(self->index).location,
                "expected \"true\" or \"false\" here."
            );
        }
        return res;
    }

    func scalar_gen(self) -> ast* {
        if (self->lookahead(tok_kind::tok_lparen)) {
            self->match_token(tok_kind::tok_lparen);
            var res = self->calculation_gen();
            self->match_token(tok_kind::tok_rparen);
            return res;
        }
        if (self->lookahead(tok_kind::tok_sub)) {
            return self->unary_neg_gen() => ast*;
        } elsif (self->lookahead(tok_kind::tok_floater)) {
            return self->unary_bnot_gen() => ast*;
        } elsif (self->lookahead(tok_kind::tok_nil)) {
            return self->nil_gen() => ast*;
        } elsif (self->lookahead(tok_kind::tok_num)) {
            return self->number_literal_gen() => ast*;
        } elsif (self->lookahead(tok_kind::tok_str)) {
            return self->string_literal_gen() => ast*;
        } elsif (self->lookahead(tok_kind::tok_ch)) {
            return self->char_gen() => ast*;
        } elsif (self->lookahead(tok_kind::tok_true) ||
                 self->lookahead(tok_kind::tok_false)) {
            return self->bool_gen() => ast*;
        } elsif (self->lookahead(tok_kind::tok_id)) {
            return self->call_gen() => ast*;
        }

        self->err->error(
            self->toks->get(self->index).location,
            "expected scalar here."
        );
        return ast_null::new() => ast*;
    }

    func unary_neg_gen(self) -> ast_unary_operator* {
        var res = ast_unary_operator::new(
            self->this_tok_loc_copy(),
            unary_kind::neg
        );
        self->match_token(tok_kind::tok_sub);
        res->value = self->scalar_gen();
        return res;
    }

    func unary_bnot_gen(self) -> ast_unary_operator* {
        var res = ast_unary_operator::new(
            self->this_tok_loc_copy(),
            unary_kind::bnot
        );
        self->match_token(tok_kind::tok_floater);
        res->value = self->scalar_gen();
        return res;
    }

    func type_convert_gen(self) -> ast* {
        var begin_loc = self->this_tok_loc();
        var result = self->scalar_gen();
        if (self->lookahead(tok_kind::tok_wide_arrow)) {
            var type_cast_node = ast_type_convert::new(begin_loc->copy());
            type_cast_node->from = result;
            type_cast_node->to = self->type_def_gen();
            return type_cast_node => ast*;
        }
        return result;
    }

    func multive_gen(self) -> ast* {
        var begin_loc = self->this_tok_loc();
        var res = self->type_convert_gen();
        while (self->lookahead(tok_kind::tok_mul) ||
               self->lookahead(tok_kind::tok_div) ||
               self->lookahead(tok_kind::tok_rem)) {
            var kind = 0 => binary_kind;
            match(self->toks->get(self->index).kind) {
                tok_kind::tok_mul => kind = binary_kind::mult;
                tok_kind::tok_div => kind = binary_kind::div;
                tok_kind::tok_rem => kind = binary_kind::rem;
            }
            var binary = ast_binary_operator::new(begin_loc->copy(), kind);
            self->match_token(self->toks->get(self->index).kind);
            binary->left = res;
            binary->right = self->type_convert_gen();
            res = binary => ast*;
        }
        return res;
    }

    func additive_gen(self) -> ast* {
        var begin_loc = self->this_tok_loc();
        var res = self->multive_gen();
        while (self->lookahead(tok_kind::tok_add) ||
               self->lookahead(tok_kind::tok_sub)) {
            var binary = nil => ast_binary_operator*;
            match(self->toks->get(self->index).kind) {
                tok_kind::tok_add => {
                    binary = ast_binary_operator::new(
                        begin_loc->copy(),
                        binary_kind::add
                    );
                }
                tok_kind::tok_sub => {
                    binary = ast_binary_operator::new(
                        begin_loc->copy(),
                        binary_kind::sub
                    );
                }
            }
            self->match_token(self->toks->get(self->index).kind);
            binary->left = res;
            binary->right = self->multive_gen();
            res = binary => ast*;
        }
        return res;
    }

    func bitwise_and_gen(self) -> ast* {
        var begin_loc = self->this_tok_loc();
        var res = self->additive_gen();
        while (self->lookahead(tok_kind::tok_bit_and)) {
            var binary = ast_binary_operator::new(
                begin_loc->copy(),
                binary_kind::band
            );
            self->match_token(tok_kind::tok_bit_and);
            binary->left = res;
            binary->right = self->additive_gen();
            res = binary => ast*;
        }
        return res;
    }

    func bitwise_xor_gen(self) -> ast* {
        var begin_loc = self->this_tok_loc();
        var res = self->bitwise_and_gen();
        while (self->lookahead(tok_kind::tok_bit_xor)) {
            var binary = ast_binary_operator::new(
                begin_loc->copy(),
                binary_kind::bxor
            );
            self->match_token(tok_kind::tok_bit_xor);
            binary->left = res;
            binary->right = self->bitwise_and_gen();
            res = binary => ast*;
        }
        return res;
    }

    func bitwise_or_gen(self) -> ast* {
        var begin_loc = self->this_tok_loc();
        var res = self->bitwise_xor_gen();
        while (self->lookahead(tok_kind::tok_bit_or)) {
            var binary = ast_binary_operator::new(
                begin_loc->copy(),
                binary_kind::bor
            );
            self->match_token(tok_kind::tok_bit_or);
            binary->left = res;
            binary->right = self->bitwise_xor_gen();
            res = binary => ast*;
        }
        return res;
    }

    func compare_gen(self) -> ast* {
        var begin_loc = self->this_tok_loc();
        var res = self->type_convert_gen();
        while (self->lookahead(tok_kind::tok_cmp_eq) ||
               self->lookahead(tok_kind::tok_neq) ||
               self->lookahead(tok_kind::tok_less) ||
               self->lookahead(tok_kind::tok_leq) ||
               self->lookahead(tok_kind::tok_grt) ||
               self->lookahead(tok_kind::tok_geq)) {
            # FIXME: directly use `var kind = binary_kind::add;` may cause ir error
            var kind = 0 => binary_kind;
            match (self->toks->get(self->index).kind) {
                tok_kind::tok_cmp_eq => kind = binary_kind::cmpeq;
                tok_kind::tok_neq => kind = binary_kind::cmpneq;
                tok_kind::tok_less => kind = binary_kind::less;
                tok_kind::tok_leq => kind = binary_kind::leq;
                tok_kind::tok_grt => kind = binary_kind::grt;
                tok_kind::tok_geq => kind = binary_kind::geq;
            }
            var binary = ast_binary_operator::new(begin_loc->copy(), kind);
            self->match_token(self->toks->get(self->index).kind);
            binary->left = res;
            binary->right = self->type_convert_gen();
            res = binary => ast*;
        }
        return res;
    }

    func calculation_gen(self) -> ast* {
        # TODO: unfinished
        return ast_null::new() => ast*;
    }

    func type_def_gen(self) -> ast_type_def* {
        var res = ast_type_def::new(self->this_tok_loc_copy());
        res->name = self->identifier_gen();
        while (self->lookahead(tok_kind::tok_mul)) {
            res->pointer_depth += 1;
            self->match_token(tok_kind::tok_mul);
        }
        return res;
    }

    func struct_field_gen(self) -> ast_struct_field* {
        var res = ast_struct_field::new(self->this_tok_loc_copy());
        res->name = self->identifier_gen();
        self->match_token(tok_kind::tok_colon);
        res->type = self->type_def_gen();
        return res;
    }

    func struct_decl_gen(self) -> ast_struct_decl* {
        var begin_loc = self->this_tok_loc_copy();
        self->match_token(tok_kind::tok_struct);
        var res = ast_struct_decl::new(
            begin_loc,
            self->toks->get(self->index).content
        );
        self->match_token(tok_kind::tok_id);
        self->match_token(tok_kind::tok_lbrace);
        while (!self->lookahead(tok_kind::tok_rbrace)) {
            res->fields.push(self->struct_field_gen() => ast*);
            if (self->lookahead(tok_kind::tok_comma)) {
                self->match_token(tok_kind::tok_comma);
            } else {
                break;
            }
        }
        self->match_token(tok_kind::tok_rbrace);
        return res;
    }

    func enum_member_gen(self) -> ast_enum_member* {
        var res = ast_enum_member::new(self->this_tok_loc_copy());
        res->name = self->identifier_gen();
        if (self->lookahead(tok_kind::tok_eq)) {
            self->match_token(tok_kind::tok_eq);
            res->value = self->number_literal_gen();
        }
        return res;
    }

    func enum_decl_gen(self) -> ast_enum_decl* {
        var begin_loc = self->this_tok_loc_copy();
        self->match_token(tok_kind::tok_enum);
        var res = ast_enum_decl::new(
            begin_loc,
            self->toks->get(self->index).content
        );
        self->match_token(tok_kind::tok_id);
        self->match_token(tok_kind::tok_lbrace);
        while (!self->lookahead(tok_kind::tok_rbrace)) {
            res->members.push(self->enum_member_gen() => ast*);
            if (self->lookahead(tok_kind::tok_comma)) {
                self->match_token(tok_kind::tok_comma);
            } else {
                break;
            }
        }
        self->match_token(tok_kind::tok_rbrace);
        return res;
    }

    func use_stmt_gen(self) -> ast_use_stmt* {
        var res = ast_use_stmt::new(self->this_tok_loc_copy());
        self->match_token(tok_kind::tok_use);
        res->module_path.push(self->identifier_gen() => ast*);
        while (self->lookahead(tok_kind::tok_coloncolon)) {
            self->match_token(tok_kind::tok_coloncolon);
            if (self->lookahead(tok_kind::tok_lbrace) ||
                self->lookahead(tok_kind::tok_mul)) {
                break;
            }
            res->module_path.push(self->identifier_gen() => ast*);
        }
        if (self->lookahead(tok_kind::tok_lbrace)) {
            self->match_token(tok_kind::tok_lbrace);
            while (self->lookahead(tok_kind::tok_id)) {
                res->import_symbol.push(self->identifier_gen() => ast*);
                if (self->lookahead(tok_kind::tok_comma)) {
                    self->match_token(tok_kind::tok_comma);
                } else {
                    break;
                }
            }
            self->match_token(tok_kind::tok_rbrace);
        } else if (!self->lookahead(tok_kind::tok_mul)) {
            var last = res->module_path.back();
            res->module_path.pop();
            res->import_symbol.push(last);
        } else {
            self->match_token(tok_kind::tok_mul);
        }
        self->match_token(tok_kind::tok_semi);
        return res;
    }

    func param_gen(self) -> ast_param* {
        var res = ast_param::new(self->this_tok_loc_copy());
        res->name = self->identifier_gen();
        if (self->lookahead(tok_kind::tok_colon)) {
            self->match_token(tok_kind::tok_colon);
            res->type = self->type_def_gen();
        }
        return res;
    }

    func param_list_gen(self) -> ast_param_list* {
        var res = ast_param_list::new(self->this_tok_loc_copy());
        self->match_token(tok_kind::tok_lparen);
        while (!self->lookahead(tok_kind::tok_rparen)) {
            res->params.push(self->param_gen() => ast*);
            if (self->lookahead(tok_kind::tok_comma)) {
                self->match_token(tok_kind::tok_comma);
            } else {
                break;
            }
        }
        self->match_token(tok_kind::tok_rparen);
        return res;
    }

    func function_decl_gen(self) -> ast_func_decl* {
        var begin_loc = self->this_tok_loc_copy();
        self->match_token(tok_kind::tok_func);
        var res = ast_func_decl::new(
            begin_loc,
            self->toks->get(self->index).content
        );
        self->match_token(tok_kind::tok_id);
        res->params = self->param_list_gen();
        if (self->lookahead(tok_kind::tok_arrow)) {
            self->match_token(tok_kind::tok_arrow);
            res->return_type = self->type_def_gen();
        }
        res->body = ast_code_block::new(self->this_tok_loc_copy());
        self->match_token(tok_kind::tok_lbrace);
        while (!self->lookahead(tok_kind::tok_rbrace)) {
            # res->body->stmts.push(self->stmt_gen() => ast*);
            self->next(); # TODO: parse stmt
        }
        self->match_token(tok_kind::tok_rbrace);
        return res;
    }

    func impl_gen(self) -> ast_impl* {
        var begin_loc = self->this_tok_loc_copy();
        self->match_token(tok_kind::tok_impl);
        var res = ast_impl::new(
            begin_loc,
            self->toks->get(self->index).content
        );
        self->match_token(tok_kind::tok_id);
        self->match_token(tok_kind::tok_lbrace);
        while (!self->lookahead(tok_kind::tok_rbrace)) {
            res->methods.push(self->function_decl_gen() => ast*);
        }
        self->match_token(tok_kind::tok_rbrace);
        return res;
    }
}

impl parser {
    func parse(self) {
        self->index = 0;
        self->root = root::new(self->this_tok_loc_copy());
        if (self->lookahead(tok_kind::tok_eof)) {
            return;
        }
        while (self->lookahead(tok_kind::tok_use)) {
            self->root->imports.push(self->use_stmt_gen() => ast*);
        }
        while (!self->lookahead(tok_kind::tok_eof)) {
            match (self->toks->get(self->index).kind) {
                tok_kind::tok_struct => {
                    self->root->decls.push(self->struct_decl_gen() => ast*);
                    continue;
                }
                tok_kind::tok_enum => {
                    self->root->decls.push(self->enum_decl_gen() => ast*);
                    continue;
                }
                tok_kind::tok_func => {
                    self->root->decls.push(self->function_decl_gen() => ast*);
                    continue;
                }
                tok_kind::tok_impl => {
                    self->root->decls.push(self->impl_gen() => ast*);
                    continue;
                }
            }
            self->next();
        }
    }
}

impl parser {
    func dump(self) {
        var dumper = ast_dumper::instance();
        dumper.dump(self->root => ast*, io::stdout());
        dumper.delete();
    }
}