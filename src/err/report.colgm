use err::span::*;
use std::str::str;
use std::io::{ readfile_into_string, io };
use std::libc::{ malloc, free, itoa, strlen };

struct file_lines {
    source: str*,
    size: i64,
    alloc_size: i64
}

impl file_lines {
    func init(self: file_lines*) {
        self->source = malloc((128 => u64)*str::__size__()) => str*;
        self->size = 0;
        self->alloc_size = 128;

        var index = 0;
        while(index < self->alloc_size) {
            self->source[index].init();
            index += 1;
        }
        return;
    }

    func delete(self: file_lines*) {
        var index = 0;
        while(index < self->size) {
            self->source[index].delete();
            index += 1;
        }
        free(self->source => i8*);
        return;
    }

    func clear(self: file_lines*) {
        var index = 0;
        while(index < self->size) {
            self->source[index].clear();
            index += 1;
        }
        self->size = 0;
        return;
    }

    func push(self: file_lines*, line: str*) {
        if (self->size == self->alloc_size) {
            self->alloc_size *= 2;
            var tmp = malloc((self->alloc_size => u64)*str::__size__()) => str*;
            var index = 0;
            while(index < self->size) {
                tmp[index] = self->source[index];
                index += 1;
            }
            while(index < self->alloc_size) {
                tmp[index].init();
                index += 1;
            }
            free(self->source => i8*);
            self->source = tmp;
        }

        self->source[self->size].append_str(line->c_str);
        self->size += 1;
        return;
    }
}

struct report {
    filename: str,
    source: file_lines,
    error_count: i64
}

impl report {
    func new() -> report* {
        var res = report::__alloc__();
        res->filename.init();
        res->source.init();
        res->error_count = 0;
        return res;
    }

    func delete(self: report*) {
        self->filename.delete();
        self->source.delete();
        return;
    }
}

impl report {
    func load_file_source(self: report*, filename: i8*) {
        self->filename.clear();
        self->filename.append_str(filename);

        var source = str::new();
        readfile_into_string(filename, source);

        var pos = 0 => u64;
        var tmp = str::new();
        while(pos < source->size) {
            if (source->get(pos)=='\n') {
                self->source.push(tmp);
                tmp->clear();
                pos += 1 => u64;
                continue;
            }
            tmp->append_char(source->get(pos));
            pos += 1 => u64;
        }
        if (tmp->size > (0 => u64)) {
            self->source.push(tmp);
            tmp->clear();
        }

        source->delete();
        free(source => i8*);
        tmp->delete();
        free(tmp => i8*);
        return;
    }
}

impl report {
    func get_number_length(num: i64) -> i64 {
        if (num <= 0) {
            return 1;
        }
        var length = 0;
        while(num > 0) {
            num /= 10;
            length += 1;
        }
        return length;
    }

    func left_pad(padding: i64) -> str* {
        var res = str::new();
        while((res->size => i64) < padding) {
            res->append_char(' ');
        }
        return res;
    }

    func to_str(num: i64, padding: i64) -> str* {
        var tmp = malloc(256 => u64);
        itoa(num, tmp, 10);
        var res = str::new();
        var index = strlen(tmp);
        while(index < padding) {
            res->append_char(' ');
            index += 1;
        }
        res->append_str(tmp);
        free(tmp);
        return res;
    }

    func print_file_line(self: report*, location: span*, is_error: bool) {
        var index = location->begin_line;
        var max_line_number_length = report::get_number_length(location->end_line);
        var pad_str = report::left_pad(max_line_number_length);

        io::stderr()->cyan()->out(pad_str->c_str)->out(" | ")->reset()->endln();

        while(index <= location->end_line && index < self->source.size) {
            var tmp_str_const = self->source.source[index].c_str;
            var padding_num = report::to_str(index, max_line_number_length);
            io::stderr()->cyan()->out(padding_num->c_str)->out(" | ")
                        ->reset()->out(tmp_str_const)
                        ->endln();
            index += 1;

            padding_num->delete();
            free(padding_num => i8*);
        }

        io::stderr()->cyan()->out(pad_str->c_str)->out(" | ")->reset()->endln();

        pad_str->delete();
        free(pad_str => i8*);
        return;
    }

    func error(self: report*, location: span*, message: i8*) {
        if (location->file.eq_const(self->filename.c_str)==false) {
            self->load_file_source(location->file.c_str);
        }
        self->error_count += 1;

        io::stderr()->red()->out("Error: ")->reset()->end();
        io::stderr()->white()->out(message)->reset()->endln();
        io::stderr()->cyan()->out("  --> ")->end();
        io::stderr()->red()->out(location->file.c_str)
            ->out_ch(':')->out_i64(location->begin_line)
            ->out_ch(':')->out_i64(location->begin_column + 1)
            ->reset()->endln();
        self->print_file_line(location, true);
        return;
    }

    func warn(self: report*, location: span*, message: i8*) {
        if (location->file.eq_const(self->filename.c_str)==false) {
            self->load_file_source(location->file.c_str);
        }
        self->error_count += 1;

        io::stderr()->orange()->out("Warn: ")->reset()->end();
        io::stderr()->white()->out(message)->reset()->endln();
        io::stderr()->cyan()->out("  --> ")->end();
        io::stderr()->orange()->out(location->file.c_str)
            ->out_ch(':')->out_i64(location->begin_line)
            ->out_ch(':')->out_i64(location->begin_column + 1)
            ->reset()->endln();
        self->print_file_line(location, false);
        return;
    }
}