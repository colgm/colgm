use err::span::{ span };
use err::panic::{ panic };

use std::str::{ str };
use std::io::{ readfile, io };
use std::libc::{ itoa, strlen };
use std::fs::{ fs };
use std::vec::{ vec };

pub struct report {
    filename: str,
    source: vec<str>,
    error_count: i64
}

impl report {
    pub func new() -> report* {
        var res = report::__alloc__();
        if (res == nil) {
            panic("failed to allocate memory");
        }
        res->filename = str::instance();
        res->source = vec<str>::instance();
        res->error_count = 0;
        return res;
    }

    pub func delete(self) {
        self->filename.delete();
        self->source.delete();
    }
}

impl report {
    pub func load_file_source(self, filename: i8*) {
        if (!fs::exists(filename)) {
            self->error_count += 1;
            io::stderr().red().out("Error: ").reset();
            io::stderr().out("failed to load file <").out(filename)
                        .out(">, check if it exists and is readable\n");
            return;
        }

        self->filename.clear();
        self->filename.append_i8_vec(filename);
        self->source.clear();

        var source = readfile(filename);

        var tmp = str::instance();
        foreach (var ch; source) {
            if (ch.get() =='\n') {
                self->source.push(tmp.__ptr__());
                tmp.clear();
                continue;
            }
            tmp.append_char(ch.get());
        }
        if (tmp.size > 0) {
            self->source.push(tmp.__ptr__());
            tmp.clear();
        }

        source.delete();
        tmp.delete();
    }
}

impl report {
    func get_number_length(num: i64) -> i64 {
        if (num <= 0) {
            return 1;
        }
        var length = 0;
        while (num > 0) {
            num /= 10;
            length += 1;
        }
        return length;
    }

    func left_pad(padding: i64) -> str {
        var res = str::instance();
        while ((res.size => i64) < padding) {
            res.append_char(' ');
        }
        return res;
    }

    func to_str(num: i64, padding: i64) -> str {
        var tmp: [i8; 256] = [];
        itoa(num, tmp, 10);
        var res = str::instance();
        for (var index = strlen(tmp); index < padding; index += 1) {
            res.append_char(' ');
        }
        res.append_i8_vec(tmp);
        return res;
    }

    func print_file_line(self, location: span*, is_error: bool) {
        if (!location->file.eq_const(self->filename.c_str)) {
            self->load_file_source(location->file.c_str);
        }

        var index = location->begin_line;
        var max_line_number_length = report::get_number_length(location->end_line + 1);
        var pad_str = report::left_pad(max_line_number_length);

        io::stderr().cyan().out(pad_str.c_str).out(" | ").reset().endln();

        var omit_line_printed = false;

        while (index <= location->end_line) {
            if (index > location->begin_line && index < location->end_line) {
                if (!omit_line_printed) {
                    io::stderr().cyan().out(pad_str.c_str).out(" | ").reset();
                    io::stderr().out("  ...").endln();
                    io::stderr().cyan().out(pad_str.c_str).out(" | ").reset().endln();
                    omit_line_printed = true;
                }
                index += 1;
                continue;
            }
            var this_line: i8* = nil;
            var len: i64 = 0;
            if ((index => u64) < self->source.size) {
                this_line = self->source.get(index => u64)->c_str;
                len = self->source.get(index => u64)->size => i64;
            } else {
                this_line = " ";
                len = 1;
            }

            // print line number, for example:
            //
            //     1 | <source>
            //       | ...
            //    12 | <source>
            var pad_num = report::to_str(index + 1, max_line_number_length);
            io::stderr().cyan().out(pad_num.c_str).out(" | ")
                        .reset().out(this_line).endln();

            var underline = str::instance();
            if (index == location->begin_line) {
                for (var i = 0; i < len; i += 1) {
                    if (location->begin_line==location->end_line &&
                        i == location->end_column) {
                        break;
                    }
                    if (i < location->begin_column && this_line[i] != '\t') {
                        underline.append_char(' ');
                    }
                    if (i < location->begin_column && this_line[i] == '\t') {
                        underline.append_char('\t');
                    }
                    if (i >= location->begin_column && this_line[i] != '\t') {
                        underline.append_char('^');
                    }
                    if (i >= location->begin_column && this_line[i] == '\t') {
                        underline.append_i8_vec("^^^^");
                    }
                }
            } elsif (index == location->end_line) {
                // for case eof, len == 1, this_line = " "
                // sometimes the end_column is 0, but we still need one char
                // to mark the end of line
                if (len == 1 && location->end_column == 0) {
                    underline.append_char('^');
                }
                for (var i = 0; i < len; i += 1) {
                    // in fact this should be unreachable
                    if (location->begin_line==location->end_line &&
                        i < location->begin_column) {
                        continue;
                    }
                    if (i < location->end_column && this_line[i] != '\t') {
                        underline.append_char('^');
                    }
                    if (i < location->end_column && this_line[i] == '\t') {
                        underline.append_i8_vec("^^^^");
                    }
                    if (i >= location->end_column && this_line[i] != '\t') {
                        underline.append_char(' ');
                    }
                    if (i >= location->end_column && this_line[i] == '\t') {
                        underline.append_char('\t');
                    }
                }
            } else {
                for (var i = 0; i < len; i += 1) {
                    if (this_line[i] == '\t') {
                        underline.append_i8_vec("^^^^");
                    } elsif (this_line[i] != '\r' && this_line[i] != '\n') {
                        underline.append_char('^');
                    }
                }
            }

            index += 1;
            
            if (is_error) {
                io::stderr().cyan().out(pad_str.c_str).out(" | ")
                            .red().out(underline.c_str)
                            .reset().endln();
            } else {
                io::stderr().cyan().out(pad_str.c_str).out(" | ")
                            .orange().out(underline.c_str)
                            .reset().endln();
            }

            underline.delete();
            pad_num.delete();
        }

        io::stderr().endln();

        pad_str.delete();
    }
}

impl report {
    pub func unimplemented(self, location: span*) {
        self->error(location, "unimplemented");
    }

    pub func error(self, location: span*, message: i8*) {
        self->error_count += 1;

        io::stderr().red().out("Error: ").reset();
        io::stderr().white().out(message).reset().endln();
        if (location != nil) {
            io::stderr().cyan().out("  --> ").red().out(location->file.c_str);
            io::stderr().out_ch(':').out_i64(location->begin_line + 1);
            io::stderr().out_ch(':').out_i64(location->begin_column + 1);
            io::stderr().reset().endln();
            self->print_file_line(location, true);
        }
    }

    pub func warn(self, location: span*, message: i8*) {
        io::stderr().orange().out("Warn: ").reset();
        io::stderr().white().out(message).reset().endln();
        if (location != nil) {
            io::stderr().cyan().out("  --> ").orange().out(location->file.c_str);
            io::stderr().out_ch(':').out_i64(location->begin_line + 1);
            io::stderr().out_ch(':').out_i64(location->begin_column + 1);
            io::stderr().reset().endln();
            self->print_file_line(location, false);
        }
    }
}