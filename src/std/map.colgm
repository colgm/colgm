use std::str::{ str };
use std::libc::{ malloc, free, streq };
use std::list::{ list, list_iter };

pub struct pair<K, V> {
    key: K*,
    value: V*
}

impl pair<K, V> {
    pub func delete(self) {
        self->key->delete();
        self->value->delete();
        free(self->key => i8*);
        free(self->value => i8*);
    }

    pub func copy(self) -> pair<K, V>* {
        var res = pair<K, V>::__alloc__();
        res->key = self->key->copy();
        res->value = self->value->copy();
        return res;
    }
}

pub struct hashmap<K, V> {
    size: u64,
    data_capacity: u64,
    data: list<pair<K, V>>*
}

impl hashmap<K, V> {
    pub func new() -> hashmap<K, V>* {
        var res = hashmap<K, V>::__alloc__();
        res->init();
        return res;
    }

    pub func instance() -> hashmap<K, V> {
        var res = hashmap<K, V> {};
        res.init();
        return res;
    }

    func init(self) {
        self->size = 0 => u64;
        self->data_capacity = 1024 => u64;
        self->data = malloc(self->data_capacity
                            * list<pair<K, V>>::__size__())
                            => list<pair<K, V>>*;
        for (var i = 0 => u64; i < self->data_capacity; i += 1 => u64) {
            self->data[i] = list<pair<K, V>>::instance();
        }
    }

    pub func delete(self) {
        for (var i = 0 => u64; i < self->data_capacity; i += 1 => u64) {
            self->data[i].delete();
        }
        free(self->data => i8*);
        self->size = 0 => u64;
        self->data_capacity = 0 => u64;
        self->data = nil => list<pair<K, V>>*;
    }
}

impl hashmap<K, V> {
    pub func has(self, key: K*) -> bool {
        var hash = key->hash() % (1024 => u64);
        var bucket = self->data[hash].__ptr__();
        for (var i = bucket->iter(); !i.is_end(); i = i.next()) {
            if (i.elem()->key->eq(key)) {
                return true;
            }
        }
        return false;
    }

    pub func get(self, key: K*) -> V* {
        var hash = key->hash() % (1024 => u64);
        var bucket = self->data[hash].__ptr__();
        for (var i = bucket->iter(); !i.is_end(); i = i.next()) {
            if (i.elem()->key->eq(key)) {
                return i.elem()->value;
            }
        }
       return nil => V*;
    }

    pub func insert(self, key: K*, value: V*) {
        var hash = key->hash() % self->data_capacity;
        var bucket = self->data[hash].__ptr__();
        for (var i = bucket->iter(); !i.is_end(); i = i.next()) {
            if (i.elem()->key->eq(key)) {
                var tmp = i.elem();
                tmp->value->delete();
                free(tmp->value => i8*);
                tmp->value = value->copy();
                return;
            }
        }
        
        var tmp_pair = pair<K, V> {
            key: key,
            value: value
        };
        // do copy in insert method
        bucket->insert(tmp_pair.__ptr__());
        self->size += 1 => u64;
    }
}

pub struct hashmap_iter<K, V> {
    map: hashmap<K, V>*,
    bucket_index: u64,
    bucket_list_iter: list_iter<pair<K, V>>
}

impl hashmap_iter<K, V> {
    func instance(map: hashmap<K, V>*) -> hashmap_iter<K, V> {
        var res = hashmap_iter<K, V> {
            map: map,
            bucket_index: 0 => u64,
            bucket_list_iter: map->data[0].iter()
        };
        while (res.bucket_list_iter.is_end()) {
            res.bucket_index += 1 => u64;
            if (res.bucket_index >= map->data_capacity) {
                return res;
            }
            res.bucket_list_iter = map->data[res.bucket_index].iter();
        }
        return res;
    }

    pub func next(self) -> hashmap_iter<K, V> {
        if (!self->bucket_list_iter.is_end()) {
            self->bucket_list_iter = self->bucket_list_iter.next();
        }

        while (self->bucket_list_iter.is_end()) {
            self->bucket_index += 1 => u64;
            if (self->bucket_index >= self->map->data_capacity) {
                break;
            }
            self->bucket_list_iter = self->map->data[self->bucket_index].iter();
        }

        return hashmap_iter<K, V> {
            map: self->map,
            bucket_index: self->bucket_index,
            bucket_list_iter: self->bucket_list_iter,
        };
    }

    pub func is_end(self) -> bool {
        return self->bucket_index >= self->map->data_capacity &&
               self->bucket_list_iter.is_end();
    }

    pub func key(self) -> K* {
        return self->bucket_list_iter.elem()->key;
    }

    pub func value(self) -> V* {
        return self->bucket_list_iter.elem()->value;
    }
}

impl hashmap<K, V> {
    pub func iter(self) -> hashmap_iter<K, V> {
        return hashmap_iter<K, V>::instance(self);
    }
}