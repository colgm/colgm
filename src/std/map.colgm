use std::str::{ str };
use std::libc::{ malloc, free, streq };
use std::list::{ list };

// pub struct primitive_pair<K, V> {
//     key: K,
//     value: V*
// }

// FIXME: support this syntax
// pub struct primitive_hashmap<K, V> {
//     size: i64,
//     data: list<primitive_pair<K, V>>*
// }

pub struct pair<T> {
    key: str*,
    value: T*
}

pub struct bucket<T> {
    pair: pair<T>,
    next: bucket<T>*
}

pub struct hashmap<T> {
    size: i64,
    data: bucket<T>**
}

impl hashmap<T> {
    pub func new() -> hashmap<T>* {
        var res = malloc(hashmap<T>::__size__()) => hashmap<T>*;
        res->size = 0;
        res->data = malloc((1024 * 8) => u64) => bucket<T>**;
        for (var i = 0; i < 1024; i+=1) {
            res->data[i] = nil => bucket<T>*;
        }
        return res;
    }

    pub func delete(self) {
        free(self->data => i8*);
    }
}

impl hashmap<T> {
    pub func insert(self, key: str*, value: T*) {
        var hash = 0 => u64;
        for (var i = 0 => u64; i < key->size; i += 1 => u64) {
            hash = hash * (31 => u64) + (key->c_str[i] => u64);
        }
        hash = hash % 1024 => u64;
        var bucket_list = self->data[hash] => bucket<T>*;
        while (bucket_list => i8* != nil) {
            if (streq(bucket_list->pair.key->c_str, key->c_str)) {
                bucket_list->pair.value = value;
                return;
            }
            bucket_list = bucket_list->next;
        }
    }
}