use std::libc::{ malloc, realloc, free };
use err::panic::{ panic };
use std::ptr::{ ptr_size };

pub struct vec<T> {
    data: T**,
    size: u64,
    capacity: u64
}

pub struct primitive_vec<T> {
    data: T*,
    size: u64,
    capacity: u64
}

impl vec<T> {
    pub func new() -> vec<T>* {
        var res = vec<T>::__alloc__();
        res->size = 0;
        res->capacity = 4;
        res->data = malloc(res->capacity * ptr_size()) => T**;
        for (var i: u64 = 0; i < res->capacity; i += 1) {
            res->data[i] = nil;
        }
        return res;
    }

    pub func instance() -> vec<T> {
        var res = vec<T> {
            size: 0,
            capacity: 4,
            data: nil
        };
        res.data = malloc(res.capacity * ptr_size()) => T**;
        for (var i: u64 = 0; i < res.capacity; i += 1) {
            res.data[i] = nil;
        }
        return res;
    }

    pub func copy(self) -> vec<T>* {
        var res = vec<T>::new();
        for (var i: u64 = 0; i < self->size; i += 1) {
            res->push(self->data[i]);
        }
        return res;
    }

    pub func copy_instance(self) -> vec<T> {
        var res = vec<T>::instance();
        for (var i: u64 = 0; i < self->size; i += 1) {
            res.push(self->data[i]);
        }
        return res;
    }

    pub func delete(self) {
        for (var i: u64 = 0; i < self->size; i += 1) {
            self->data[i]->delete();
            free(self->data[i] => i8*);
        }
        free(self->data => i8*);
        self->data = nil;
        self->size = 0;
        self->capacity = 0;
    }

    func extend_capacity(self) {
        self->capacity *= 2;
        self->data = realloc(
            self->data => i8*,
            self->capacity * ptr_size()
        ) => T**;
    }

    pub func push(self, item: T*) {
        if (self->size >= self->capacity) {
            self->extend_capacity();
        }
        self->data[self->size] = item->copy();
        self->size += 1;
    }

    pub func get(self, index: u64) -> T* {
        if (index >= self->size) {
            panic("std::vec::get: index out of bounds");
        }
        return self->data[index];
    }
}

impl primitive_vec<T> {
    pub func new() -> primitive_vec<T>* {
        var res = primitive_vec<T>::__alloc__();
        res->size = 0;
        res->capacity = 4;
        res->data = malloc(res->capacity * T::__size__()) => T*;
        return res;
    }

    pub func instance() -> primitive_vec<T> {
        var res = primitive_vec<T> {
            size: 0,
            capacity: 4,
            data: nil
        };
        res.data = malloc(res.capacity * T::__size__()) => T*;
        return res;
    }

    pub func copy(self) -> primitive_vec<T>* {
        var res = primitive_vec<T>::new();
        for (var i: u64 = 0; i < self->size; i += 1) {
            res->push(self->data[i]);
        }
        return res;
    }

    pub func copy_instance(self) -> primitive_vec<T> {
        var res = primitive_vec<T>::instance();
        for (var i: u64 = 0; i < self->size; i += 1) {
            res.push(self->data[i]);
        }
        return res;
    }

    pub func delete(self) {
        free(self->data => i8*);
        self->data = nil;
        self->size = 0;
        self->capacity = 0;
    }

    func extend_capacity(self) {
        self->capacity *= 2;
        self->data = realloc(self->data => i8*, self->capacity * T::__size__()) => T*;
    }

    pub func push(self, item: T) {
        if (self->size >= self->capacity) {
            self->extend_capacity();
        }
        self->data[self->size] = item;
        self->size += 1;
    }

    pub func get(self, index: u64) -> T {
        return self->data[index];
    }

    pub func back(self) -> T {
        if (self->size == 0) {
            panic("std::primitive_vec::back: empty vector");
        }
        return self->data[self->size - 1];
    }

    pub func pop_back(self) {
        if (self->size == 0) {
            panic("std::primitive_vec::pop_back: empty vector");
        }
        self->size -= 1;
    }
}