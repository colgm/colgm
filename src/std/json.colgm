use std::io::{ io };
use std::str::{ str };
use std::vec::{ vec };
use std::map::{ hashmap };
use std::libc::{ free };
use std::string_utils::{ is_alpha_letter, is_digit };

use err::panic::{ panic };

use util::to_num::{ to_f64 };

pub enum json_kind {
    json_object,
    json_array,
    json_string,
    json_number,
    json_bool,
    json_null,
    json_error
}

pub union(json_kind) json {
    json_object: hashmap<str, json*>,
    json_array: vec<json*>,
    json_string: str,
    json_number: f64,
    json_bool: bool,
    json_null: i8,
    json_error: str
}

impl json {
    pub func delete(self) {
        match (self) {
            json_kind::json_object => {
                foreach (var i; self->json_object) {
                    i.value()->delete();
                    free(i.value() => i8*);
                }
                self->json_object.delete();
            }
            json_kind::json_array => {
                foreach (var i; self->json_array) {
                    i.get()->delete();
                    free(i.get() => i8*);
                }
                self->json_array.delete();
            }
            json_kind::json_string => {
                self->json_string.delete();
            }
            json_kind::json_error => {
                self->json_error.delete();
            }
            _ => {}
        }
    }
}

impl json {
    pub func obj() -> json* {
        var res = json::__alloc__();
        res[0] = json { json_object: hashmap<str, json*>::instance() };
        return res;
    }

    pub func arr() -> json* {
        var res = json::__alloc__();
        res[0] = json { json_array: vec<json*>::instance() };
        return res;
    }

    pub func str(s: const i8*) -> json* {
        var res = json::__alloc__();
        res[0] = json { json_string: str::from(s) };
        return res;
    }

    pub func num(n: f64) -> json* {
        var res = json::__alloc__();
        res[0] = json { json_number: n };
        return res;
    }

    pub func bool(flag: bool) -> json* {
        var res = json::__alloc__();
        res[0] = json { json_bool: flag };
        return res;
    }

    pub func null() -> json* {
        var res = json::__alloc__();
        res[0] = json { json_null: 0 };
        return res;
    }

    pub func error(s: const i8*) -> json* {
        var res = json::__alloc__();
        res[0] = json { json_error: str::from(s) };
        return res;
    }
}

impl json {
    pub func to_string(self) -> str {
        match (self) {
            json_kind::json_object => {
                var res = str::from("{");
                foreach (var i; self->json_object) {
                    if (!res.eq_const("{")) {
                        res.append(",");
                    }
                    res.append("\"");
                    res.append(i.key()->c_str);
                    res.append("\":");
                    var temp = i.value()->to_string();
                    defer temp.delete();
                    res.append(temp.c_str);
                }
                res.append("}");
                return res;
            }
            json_kind::json_array => {
                var res = str::from("[");
                foreach (var i; self->json_array) {
                    if (!res.eq_const("[")) {
                        res.append(",");
                    }
                    var temp = i.get()->to_string();
                    defer temp.delete();
                    res.append(temp.c_str);
                }
                res.append("]");
                return res;
            }
            json_kind::json_string => {
                var res = str::from("\"");
                res.append(self->json_string.c_str);
                res.append("\"");
                return res;
            }
            json_kind::json_number => {
                return str::from_f64(self->json_number);
            }
            json_kind::json_bool => {
                if (self->json_bool) {
                    return str::from("true");
                } else {
                    return str::from("false");
                }
            }
            json_kind::json_null => {
                return str::from("null");
            }
            _ => {
                panic("json::to_string: reach json error");
            }
        }
        return str::from("null");
    }

    pub func tokenizer(src: str*) -> tokenizer {
        return tokenizer::instance(src);
    }
}

enum json_token_kind {
    tok_left_brace,
    tok_right_brace,
    tok_left_bracket,
    tok_right_bracket,
    tok_comma,
    tok_colon,
    tok_string,
    tok_number,
    tok_bool,
    tok_null,
    tok_empty_result,
    tok_error,
    tok_eof
}

struct json_token {
    kind: json_token_kind,
    value: str
}

impl json_token {
    pub func instance(k: json_token_kind, s: const i8*) -> json_token {
        return json_token {
            kind: k,
            value: str::from(s)
        };
    }

    pub func delete(self) {
        self->value.delete();
    }

    pub func copy_instance(self) -> json_token {
        return json_token {
            kind: self->kind,
            value: self->value.copy_instance()
        };
    }

    pub func is_error(self) -> bool {
        return self->kind == json_token_kind::tok_error;
    }

    pub func is_eof(self) -> bool {
        return self->kind == json_token_kind::tok_eof;
    }

    pub func is_null(self) -> bool {
        return self->kind == json_token_kind::tok_null;
    }

    pub func is_empty(self) -> bool {
        return self->kind == json_token_kind::tok_empty_result;
    }

    pub func is_string(self) -> bool {
        return self->kind == json_token_kind::tok_string;
    }

    pub func is_number(self) -> bool {
        return self->kind == json_token_kind::tok_number;
    }

    pub func is_bool(self) -> bool {
        return self->kind == json_token_kind::tok_bool;
    }

    pub func is_object_start(self) -> bool {
        return self->kind == json_token_kind::tok_left_brace;
    }

    pub func is_object_end(self) -> bool {
        return self->kind == json_token_kind::tok_right_brace;
    }

    pub func is_array_start(self) -> bool {
        return self->kind == json_token_kind::tok_left_bracket;
    }

    pub func is_array_end(self) -> bool {
        return self->kind == json_token_kind::tok_right_bracket;
    }

    pub func dump(self) {
        if (self->is_string()) {
            io::stdout().out("\"");
            foreach (var i; self->value) {
                if (i.get() == '"') {
                    io::stdout().out("\\\"");
                } elsif (i.get() == '\\') {
                    io::stdout().out("\\\\");
                } elsif (i.get() == '\n') {
                    io::stdout().out("\\n");
                } elsif (i.get() == '\r') {
                    io::stdout().out("\\r");
                } elsif (i.get() == '\t') {
                    io::stdout().out("\\t");
                } else {
                    var buff = [i.get(), '\0'];
                    io::stdout().out(buff);
                }
            }
            io::stdout().out("\" ");
            return;
        }
        io::stdout().out(self->value.c_str);
        io::stdout().out(" ");
    }
}

struct tokenizer {
    index: u64,
    source: str*
}

impl tokenizer {
    pub func instance(src: str*) -> tokenizer {
        return tokenizer {
            index: 0,
            source: src
        };
    }
}

impl tokenizer {
    func is_string_quote(c: i8) -> bool {
        return c == '"';
    }

    func is_identifier_head(c: i8) -> bool {
        return is_alpha_letter(c) || c == '_';
    }

    func is_number_head(c: i8) -> bool {
        return is_digit(c) || c == '-' || c == '+';
    }

    func is_number_body(c: i8) -> bool {
        return is_digit(c) || c == '.' || c == 'e' || c == 'E';
    }

    func next_token(self) -> json_token {
        var input = self->source;
        var i = self->index;

        if (i >= input->size || input->c_str[i] == 0) {
            return json_token::instance(json_token_kind::tok_eof, "<eof>");
        }

        defer self->index = i + 1;

        if (input->c_str[i] == '{') {
            return json_token::instance(json_token_kind::tok_left_brace, "{");
        } elsif (input->c_str[i] == '}') {
            return json_token::instance(json_token_kind::tok_right_brace, "}");
        } elsif (input->c_str[i] == '[') {
            return json_token::instance(json_token_kind::tok_left_bracket, "[");
        } elsif (input->c_str[i] == ']') {
            return json_token::instance(json_token_kind::tok_right_bracket, "]");
        } elsif (input->c_str[i] == ',') {
            return json_token::instance(json_token_kind::tok_comma, ",");
        } elsif (input->c_str[i] == ':') {
            return json_token::instance(json_token_kind::tok_colon, ":");
        } elsif (tokenizer::is_string_quote(input->c_str[i])) {
            var start = input->c_str[i];
            i += 1;
            var content = str::instance();
            defer content.delete();
            while (input->c_str[i] != 0 && input->c_str[i] != start) {
                content.append_char(input->c_str[i]);
                if (input->c_str[i] == '\\') {
                    i += 1;
                    if (input->c_str[i] == 0) {
                        return json_token::instance(
                            json_token_kind::tok_error,
                            "invalid escape sequence"
                        );
                    }
                    if (input->c_str[i] == 'n') {
                        content.append_char('\n');
                    } elsif (input->c_str[i] == 't') {
                        content.append_char('\t');
                    } elsif (input->c_str[i] == 'r') {
                        content.append_char('\r');
                    } elsif (input->c_str[i] == '\\') {
                        content.append_char('\\');
                    } elsif (input->c_str[i] == '"') {
                        content.append_char('"');
                    } else {
                        content.append_char(input->c_str[i]);
                    }
                }
                i += 1;
            }
            if (input->c_str[i] == 0) {
                return json_token::instance(
                    json_token_kind::tok_error,
                    "unterminated string"
                );
            }
            var tok = json_token::instance(json_token_kind::tok_string, content.c_str);
            return tok;
        } elsif (tokenizer::is_number_head(input->c_str[i])) {
            var content = str::instance();
            defer content.delete();

            content.append_char(input->c_str[i]);
            i += 1;

            while (input->c_str[i] != 0 && tokenizer::is_number_body(input->c_str[i])) {
                content.append_char(input->c_str[i]);
                i += 1;
            }
            if (input->c_str[i] != 0) {
                i -= 1;
            }
            var tok = json_token::instance(json_token_kind::tok_number, content.c_str);
            return tok;
        } elsif (tokenizer::is_identifier_head(input->c_str[i])) {
            var content = str::instance();
            defer content.delete();

            content.append_char(input->c_str[i]);
            i += 1;

            while (input->c_str[i] != 0 &&
                    (tokenizer::is_identifier_head(input->c_str[i]) ||
                    is_digit(input->c_str[i]))) {
                content.append_char(input->c_str[i]);
                i += 1;
            }
            if (input->c_str[i] != 0) {
                i -= 1;
            }

            if (content.eq_const("true")) {
                return json_token::instance(json_token_kind::tok_bool, "true");
            } elsif (content.eq_const("false")) {
                return json_token::instance(json_token_kind::tok_bool, "false");
            } elsif (content.eq_const("null")) {
                return json_token::instance(json_token_kind::tok_null, "null");
            }
            
            return json_token::instance(json_token_kind::tok_error, "invalid token");
        } else {
            while (input->c_str[i] != 0 &&
                   input->c_str[i] != '{' &&
                   input->c_str[i] != '}' &&
                   input->c_str[i] != '[' &&
                   input->c_str[i] != ']' &&
                   input->c_str[i] != ',' &&
                   input->c_str[i] != ':' &&
                   !tokenizer::is_string_quote(input->c_str[i]) &&
                   !tokenizer::is_number_head(input->c_str[i]) &&
                   !tokenizer::is_identifier_head(input->c_str[i])) {
                i += 1;
            }
            i -= 1;
            return json_token::instance(json_token_kind::tok_empty_result, "<empty>");
        }

        return json_token::instance(json_token_kind::tok_error, "invalid token");
    }

    pub func next(self) -> json_token {
        var tok = self->next_token();

        if (tok.is_eof()) {
            return tok;
        }

        while (tok.is_empty()) {
            tok.delete();
            tok = self->next_token();
        }
        return tok;
    }

    pub func tokenize(self) {
        self->index = 0;

        var tok = self->next();
        tok.dump();
        defer tok.delete();

        while (!tok.is_eof() && !tok.is_error()) {
            tok.delete();
            tok = self->next();
            tok.dump();
        }
        io::stdout().out("\n");
    }
}

struct parser {
    tkn: tokenizer
}

impl parser {
    func parse_object(self) -> json* {
        var result = json::obj();
        
        var tok = self->tkn.next();
        defer tok.delete();

        while (!tok.is_eof() && !tok.is_error() && !tok.is_object_end()) {
            // TODO: parse key
        }

        return result;
    }

    func parse_array(self) -> json* {
        var result = json::arr();

        var tok = self->tkn.next();
        defer tok.delete();

        while (!tok.is_eof() && !tok.is_error() && !tok.is_array_end()) {
            // TODO: parse value
        }

        return result;
    }

    func parse_value(self) -> json* {
        var tok = self->tkn.next();
        defer tok.delete();

        if (tok.is_error()) {
            var result = json::error(tok.value.c_str);
            return result;
        }

        if (tok.is_bool()) {
            var result = json::bool(tok.value.eq_const("true"));
            return result;
        } elsif (tok.is_null()) {
            var result = json::null();
            return result;
        } elsif (tok.is_number()) {
            var result = json::num(to_f64(tok.value.c_str));
            return result;
        } elsif (tok.is_string()) {
            var result = json::str(tok.value.c_str);
            return result;
        } elsif (tok.is_object_start()) {
            return self->parse_object();
        } elsif (tok.is_array_start()) {
            return self->parse_array();
        }

        var result = json::error("invalid token");
        return result;
    }

    func parse(self, s: str*) -> json* {
        self->tkn = tokenizer::instance(s);
        return self->parse_value();
    }
}
