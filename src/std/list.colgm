use std::libc::{ free };

struct node<T> {
    elem: T*,
    next: node<T>*,
    prev: node<T>*
}

struct primitive_node<T> {
    elem: T,
    next: primitive_node<T>*,
    prev: primitive_node<T>*
}

pub struct list<T> {
    head: node<T>*,
    tail: node<T>*,
    size: u64
}

pub struct primitive_list<T> {
    head: primitive_node<T>*,
    tail: primitive_node<T>*,
    size: u64
}

impl list<T> {
    pub func new() -> list<T>* {
        var res = list<T>::__alloc__();
        res->head = nil => node<T>*;
        res->tail = nil => node<T>*;
        res->size = 0 => u64;
        return res;
    }

    pub func instance() -> list<T> {
        return list<T> {
            head: nil => node<T>*,
            tail: nil => node<T>*,
            size: 0 => u64
        };
    }

    pub func delete(self) {
        var curr = self->head;
        while (curr != nil => node<T>*) {
            var next = curr->next;
            curr->elem->delete();
            free(curr => i8*);
            curr = next;
        }
        self->head = nil => node<T>*;
        self->tail = nil => node<T>*;
        self->size = 0 => u64;
    }

    pub func insert(self, elem: T*) {
        var new_node = node<T>::__alloc__();
        new_node->elem = elem->copy();
        new_node->next = nil => node<T>*;
        new_node->prev = self->tail;

        if (self->tail != nil => node<T>*) {
            self->tail->next = new_node;
        } else {
            self->head = new_node;
        }

        self->tail = new_node;
        self->size += 1 => u64;
        return;
    }
}

impl primitive_list<T> {
    pub func new() -> primitive_list<T>* {
        var res = primitive_list<T>::__alloc__();
        res->head = nil => primitive_node<T>*;
        res->tail = nil => primitive_node<T>*;
        res->size = 0 => u64;
        return res;
    }

    pub func instance() -> primitive_list<T> {
        return primitive_list<T> {
            head: nil => primitive_node<T>*,
            tail: nil => primitive_node<T>*,
            size: 0 => u64
        };
    }

    pub func delete(self) {
        var curr = self->head;
        while (curr != nil => primitive_node<T>*) {
            var next = curr->next;
            free(curr => i8*);
            curr = next;
        }
        self->head = nil => primitive_node<T>*;
        self->tail = nil => primitive_node<T>*;
        self->size = 0 => u64;
    }

    pub func insert(self, elem: T) {
        var new_node = primitive_node<T>::__alloc__();
        new_node->elem = elem;
        new_node->next = nil => primitive_node<T>*;
        new_node->prev = self->tail;

        if (self->tail != nil => primitive_node<T>*) {
            self->tail->next = new_node;
        } else {
            self->head = new_node;
        }

        self->tail = new_node;
        self->size += 1 => u64;
        return;
    }
}