use std::libc::{ free };

use err::panic::{ panic };

struct node<T> {
    elem: T*,
    next: node<T>*,
    prev: node<T>*
}

struct primitive_node<T> {
    elem: T,
    next: primitive_node<T>*,
    prev: primitive_node<T>*
}

pub struct list<T> {
    head: node<T>*,
    tail: node<T>*,
    size: u64
}

pub struct list_iter<T> {
    list: list<T>*,
    current: node<T>*
}

pub struct primitive_list<T> {
    head: primitive_node<T>*,
    tail: primitive_node<T>*,
    size: u64
}

impl list_iter<T> {
    func instance(list: list<T>*) -> list_iter<T> {
        return list_iter<T> {
            list: list,
            current: list->head
        };
    }

    pub func is_end(self) -> bool {
        return self->current == nil;
    }

    pub func elem(self) -> T* {
        return self->current->elem;
    }

    pub func next(self) -> list_iter<T> {
        return list_iter<T> {
            list: self->list,
            current: self->current->next
        };
    }
}

impl list<T> {
    pub func new() -> list<T>* {
        var res = list<T>::__alloc__();
        if (res == nil) {
            panic("list<T>::new: failed to allocate memory");
        }
        res->head = nil;
        res->tail = nil;
        res->size = 0;
        return res;
    }

    pub func instance() -> list<T> {
        return list<T> {
            head: nil,
            tail: nil,
            size: 0
        };
    }

    pub func delete(self) {
        var curr = self->head;
        while (curr != nil) {
            var next = curr->next;
            curr->elem->delete();
            free(curr => i8*);
            curr = next;
        }
        self->head = nil;
        self->tail = nil;
        self->size = 0;
    }

    pub func insert(self, elem: T*) {
        var new_node = node<T>::__alloc__();
        if (new_node == nil) {
            panic("list<T>::insert: failed to allocate memory");
        }
        new_node->elem = elem->copy();
        new_node->next = nil;
        new_node->prev = self->tail;

        if (self->tail != nil) {
            self->tail->next = new_node;
        } else {
            self->head = new_node;
        }

        self->tail = new_node;
        self->size += 1;
        return;
    }

    pub func iter(self) -> list_iter<T> {
        return list_iter<T>::instance(self);
    }
}

impl primitive_list<T> {
    pub func new() -> primitive_list<T>* {
        var res = primitive_list<T>::__alloc__();
        if (res == nil) {
            panic("primitive_list<T>::new: failed to allocate memory");
        }
        res->head = nil;
        res->tail = nil;
        res->size = 0;
        return res;
    }

    pub func instance() -> primitive_list<T> {
        return primitive_list<T> {
            head: nil,
            tail: nil,
            size: 0
        };
    }

    pub func delete(self) {
        var curr = self->head;
        while (curr != nil) {
            var next = curr->next;
            free(curr => i8*);
            curr = next;
        }
        self->head = nil;
        self->tail = nil;
        self->size = 0;
    }

    pub func insert(self, elem: T) {
        var new_node = primitive_node<T>::__alloc__();
        if (new_node == nil) {
            panic("primitive_list<T>::insert: failed to allocate memory");
        }
        new_node->elem = elem;
        new_node->next = nil;
        new_node->prev = self->tail;

        if (self->tail != nil) {
            self->tail->next = new_node;
        } else {
            self->head = new_node;
        }

        self->tail = new_node;
        self->size += 1;
        return;
    }
}