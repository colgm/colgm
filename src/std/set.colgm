use std::str::{ str };
use std::libc::{ malloc, free, streq };
use std::list::{ list, list_iter };
use std::io::{ io };

pub struct hashset<T> {
    size: u64,
    data_capacity: u64,
    data: list<T>*
}

impl hashset<T> {
    pub func new() -> hashset<T>* {
        var res = hashset<T>::__alloc__();
        res->size = 0 => u64;
        res->data_capacity = 1024 => u64;
        res->data = malloc(res->data_capacity * list<T>::__size__()) => list<T>*;
        for (var i = 0 => u64; i < res->data_capacity; i += 1 => u64) {
            res->data[i] = list<T>::instance();
        }
        return res;
    }

    pub func instance() -> hashset<T> {
        var res = hashset<T> {
            size: 0 => u64,
            data_capacity: 1024 => u64,
            data: nil => list<T>*
        };
        res.data = malloc(res.data_capacity * list<T>::__size__()) => list<T>*;
        for (var i = 0 => u64; i < res.data_capacity; i += 1 => u64) {
            res.data[i] = list<T>::instance();
        }
        return res;
    }

    pub func delete(self) {
        for (var i = 0 => u64; i < self->data_capacity; i += 1 => u64) {
            self->data[i].delete();
        }
        free(self->data => i8*);
        self->size = 0 => u64;
        self->data_capacity = 0 => u64;
        self->data = nil => list<T>*;
    }
}

impl hashset<T> {
    pub func has(self, item: T*) -> bool {
        var hash = item->hash() % self->data_capacity;
        var bucket = self->data[hash];
        var tmp = bucket.head;
        while (tmp => i8* != nil) {
            if (tmp->elem->eq(item)) {
                return true;
            }
            tmp = tmp->next;
        }
        return false;
    }

    pub func insert(self, item: T*) {
        var hash = item->hash() % self->data_capacity;
        var bucket = self->data[hash];
        var tmp = bucket.head;
        while (tmp => i8* != nil) {
            if (tmp->elem->eq(item)) {
                return;
            }
            tmp = tmp->next;
        }
        bucket.insert(item);
        self->size += 1 => u64;
    }
}

pub struct hashset_iter<T> {
    set: hashset<T>*,
    bucket_index: u64,
    bucket_list_iter: list_iter<T>
}

impl hashset_iter<T> {
    func instance(set: hashset<T>*) -> hashset_iter<T> {
        var index = 0 => u64;
        var iter = set->data[0].iter();
        while (iter.is_end()) {
            index += 1 => u64;
            if (index >= set->data_capacity) {
                break;
            }
            iter = set->data[index].iter();
        }
        return hashset_iter<T> {
            set: set,
            bucket_index: index,
            bucket_list_iter: iter
        };
    }

    pub func is_end(self) -> bool {
        return self->bucket_index >= self->set->data_capacity &&
               self->bucket_list_iter.is_end();
    }

    pub func elem(self) -> T* {
        return self->bucket_list_iter.elem();
    }

    pub func next(self) -> hashset_iter<T> {
        if (!self->bucket_list_iter.is_end()) {
            self->bucket_list_iter = self->bucket_list_iter.next();
        }

        while (self->bucket_list_iter.is_end()) {
            self->bucket_index += 1 => u64;
            if (self->bucket_index >= self->set->data_capacity) {
                break;
            }
            self->bucket_list_iter = self->set->data[self->bucket_index].iter();
        }

        return hashset_iter<T> {
            set: self->set,
            bucket_index: self->bucket_index,
            bucket_list_iter: self->bucket_list_iter,
        };
    }
}

impl hashset<T> {
    pub func iter(self) -> hashset_iter<T> {
        return hashset_iter<T>::instance(self);
    }
}