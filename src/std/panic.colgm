use std::libc::{ write, strlen, free, itoa, abort };
use std::execinfo::{ backtrace, backtrace_symbols };

func stderr_put(s: const i8*) {
    write(2, s, strlen(s));
}

pub func print_backtrace() {
    var stack_info_buffer: [i8*; 256] = [];
    var trace_size = backtrace(stack_info_buffer, 256);
    var trace_strings = backtrace_symbols(stack_info_buffer, trace_size);

    if (trace_size == 0) {
        stderr_put("[colgm] stack trace is empty\n");
        return;
    }
    if (trace_strings == nil) {
        stderr_put("[colgm] failed to get stack trace\n");
        return;
    }

    // convert trace_size to string
    var number_buffer: [i8; 128] = [];
    itoa(trace_size => i64, number_buffer, 10);

    stderr_put("[colgm] stack trace with ");
    stderr_put(number_buffer);
    stderr_put(" frames:\n");

    for (var i: i32 = 0; i < trace_size; i += 1) {
        itoa((trace_size - i) => i64, number_buffer, 10);
        stderr_put("  ");
        stderr_put(number_buffer);
        stderr_put(":\t");
        stderr_put(trace_strings[i]);
        stderr_put("\n");
    }

    // free memory allocated by backtrace_symbols
    free(trace_strings => i8*);
}

pub func panic(info: const i8*) {
    stderr_put("\n[colgm] panic: ");
    stderr_put(info);
    stderr_put("\n");

    print_backtrace();

    // directly raise SIGABRT, so user could use gdb or lldb to debug
    abort();
}

pub func unreachable() {
    panic("unreachable");
}

pub func unimplemented() {
    panic("unimplemented");
}

pub func assert(condition: bool, info: const i8*) {
    if (condition) {
        return;
    }
    if (info == nil) {
        panic("assertion failed");
        return;
    }
    panic(info);
}
