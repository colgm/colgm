use std::io::{ io };
use std::str::{ str };
use std::vec::{ vec };
use std::fs::{ fs };
use std::result::{ result };

use util::platform::{ is_windows };

pub struct module_finder {
    path: vec<str>
}

impl module_finder {
    pub func instance(library: const i8*) -> module_finder {
        return module_finder { path: module_finder::generate_paths(library) };
    }

    func normalize(path: str&) {
        // remove trailing slash
        if (path.size > 1 && (path.endswith("\\") || path.endswith("/"))) {
            path.pop_back();
        }
        // remove leading slash
        if (path.size > 2 && (path.startswith(".\\") || path.startswith("./"))) {
            path.pop_front();
            path.pop_front();
        }
    }

    func generate_paths(library: const i8*) -> vec<str> {
        var PATH = fs::getpath();
        defer PATH.delete();

        var cwd = str::from(".");
        defer cwd.delete();

        var res = vec<str>::instance();
        if (library != nil) {
            var path = str::from(library);
            module_finder::normalize(path);
            defer path.delete();
            res.push(path);
        }
        res.push(cwd);
        foreach (var p; PATH) {
            res.push(p.get());
        }

        return res;
    }

    pub func delete(self) {
        self.path.delete();
    }

    pub func dump_search_order(self) {
        if (self.path.size > 0) {
            io::stdout().green().out("     COLGM ").reset();
            io::stdout().out("Module search order:\n");
        }
        foreach (var p; self.path) {
            io::stdout().green().out("     COLGM ").reset();
            io::stdout().out("==> ").out(p.get().c_str).endln();
        }
    }

    pub func find(self, name: str&) -> result<str> {
        foreach (var p; self.path) {
            var possible_path = p.get().clone();
            defer possible_path.delete();

            if (is_windows()) {
                possible_path.append("\\");
            } else {
                possible_path.append("/");
            }
            if (p.get().empty() || p.get().eq_const(".")) {
                possible_path.clear();
            }
            possible_path.append_str(name);

            if (fs::exists(possible_path.c_str)) {
                var res = result<str>::ok(possible_path);
                return res;
            }
        }
        return result<str>::err();
    }
}