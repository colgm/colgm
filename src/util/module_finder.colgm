use std::io::{ io };
use std::str::{ str };
use std::vec::{ vec };
use std::fs::{ fs };
use std::result::{ result };

use util::platform::{ is_windows };

pub struct module_finder {
    path: vec<str>
}

impl module_finder {
    pub func instance(library: const i8*) -> module_finder {
        var PATH = fs::getpath();
        defer PATH.delete();

        var cwd = str::from(".");
        defer cwd.delete();

        var res = vec<str>::instance();
        if (library != nil) {
            var path = str::from(library);
            defer path.delete();
            res.push(path);
        }
        res.push(cwd);
        foreach (var p; PATH) {
            res.push(p.get());
        }

        return module_finder { path: res };
    }

    pub func delete(self) {
        self.path.delete();
    }

    pub func find(self, name: str&) -> result<str> {
        foreach (var p; self.path) {
            var possible_path = p.get().clone();
            defer possible_path.delete();

            if (is_windows()) {
                possible_path.append("\\");
            } else {
                possible_path.append("/");
            }
            if (p.get().empty() || p.get().eq_const(".")) {
                possible_path.clear();
            }
            possible_path.append_str(name);

            if (fs::exists(possible_path.c_str)) {
                var res = result<str>::ok(possible_path);
                return res;
            }
        }
        return result<str>::err();
    }
}