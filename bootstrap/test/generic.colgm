use data::{ A, B, Test };

extern func malloc(size: u64) -> i8*;
extern func free(ptr: i8*);

struct Vec<T> {
    __size: u64,
    __data: T*
}

impl Vec<T> {
    pub func create() -> Vec<T> {
        var res = Vec<T> {
            __size: 0,
            __data: nil => T*
        };
        res.__size = 1024;
        res.__data = malloc(T::__size__() * 1024) => T*;
        return res;
    }
    pub func delete(self) {
        free(self->__data => i8*);
    }
    func c_data() -> T* {
        return __data;
    }
}

pub extern func new<T>(size: u64) -> Vec<T> {
    return Vec<T> {
        __size: size,
        __data: malloc(size * T::__size__()) => T*
    };
}

struct Base<A, B, C> {
    a: A,
    b: B,
    c: C
}

pub func add_test<T>(a: T, b: T) -> T {
    return a + b;
}

func main() -> i64 {
    var a = Base<i64, i64, i64> { a: 1, b: 2, c: 3 };
    var b = Base<i32, i64, f32> { a: 4 => i32, b: 5, c: 6.0 => f32 };
    var c = Vec<i32>::create();
    var d = Vec<A>::create();
    var e = Vec<B>::create();
    a.a = 2;
    c.__data[0] = b.a;
    d.__data[0] = A {a: 1, b: 2 => i32};
    e.__data[0] = B {a: 3 => i32, b: 4};
    var f = new<A>(1024 => u64);
    var g = Test<i32> { test: 1 => i32 };

    add_test<i64>(1, 2);
    add_test<f64>(1.0, 2.0);
    return a.a;
}