use data::{ A, B, Test };

extern func malloc(size: u64) -> i8*;
extern func free(ptr: i8*);
extern func puts(str: i8*);

struct Vec<T> {
    __size: i64,
    __data: T*
}

impl Vec<T> {
    pub func create() -> Vec<T> {
        var res = Vec<T> {
            __size: 0,
            __data: nil => T*
        };
        res.__size = 1024;
        res.__data = malloc(T::__size__() * (1024 => u64)) => T*;
        return res;
    }
    pub func delete(self) {
        free(self->__data => i8*);
    }
    func c_data(self) -> T* {
        return self->__data;
    }
}

pub func new<T>(size: i64) -> Vec<T> {
    return Vec<T> {
        __size: size,
        __data: malloc((size => u64) * T::__size__()) => T*
    };
}

struct Base<TA, TB, TC> {
    a: TA,
    b: TB,
    c: TC
}

impl Base<TA, TB, TC> {
    pub func new(a: TA, b: TB, c: TC) -> Base<TA, TB, TC> {
        return Base<TA, TB, TC> {
            a: a,
            b: b,
            c: c
        };
    }

    pub func get(self) -> TA {
        return self->a;
    }
}

pub func add_test<T>(a: T, b: T) -> T {
    return a + b;
}

func main() -> i64 {
    var a = Base<i64, i64, i64> { a: 1, b: 2, c: 3 };
    var b = Base<i32, i64, f32> { a: 4 => i32, b: 5, c: 6.0 => f32 };
    # var c = Vec<i32>::create();
    var d = Vec<A>::create();
    var e = Vec<B>::create();
    a.a = 2;
    # c.__data[0] = b.a;
    d.__data[0] = A {a: 1, b: 2 => i32};
    e.__data[0] = B {a: 3 => i32, b: 4};
    var f = new<A>(1024);
    var g = Test<i32> { test: 1 => i32 };

    a.get();
    b.get();

    add_test<i64>(1, 2);
    add_test<f64>(1.0, 2.0);

    puts("[generic.colgm] success");
    return 0;
}