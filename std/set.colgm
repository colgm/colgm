use std::libc::{ malloc, realloc, free };
use std::ptr::{ __ptr_size };
use std::io::{ io };
use std::pair::{ pair };
use std::panic::{ panic };

struct set_node<T> {
    elem: T,
    next: set_node<T>*
}

impl set_node<T> {
    #[is_trivial(T)]
    pub func new(elem: T) -> set_node<T>* {
        var res = set_node<T>::__alloc__();
        if (res == nil) {
            panic("failed to allocate memory");
        }
        res->elem = elem;
        res->next = nil;
        return res;
    }

    #[is_non_trivial(T)]
    pub func new(elem: T&) -> set_node<T>* {
        var res = set_node<T>::__alloc__();
        if (res == nil) {
            panic("failed to allocate memory");
        }
        res->elem = elem.clone();
        res->next = nil;
        return res;
    }

    #[is_trivial(T)]
    pub func delete(self) {}

    #[is_non_trivial(T)]
    pub func delete(self) {
        self.elem.delete();
    }
}

pub struct hashset<T> {
    size: u64,
    capacity: u64,
    bucket: set_node<T>**
}

impl hashset<T> {
    pub func new() -> hashset<T>* {
        var res = hashset<T>::__alloc__();
        if (res == nil) {
            panic("failed to allocate memory");
        }
        res->init();
        return res;
    }

    pub func instance() -> hashset<T> {
        var res = hashset<T> {};
        res.init();
        return res;
    }

    pub func clone(self) -> hashset<T> {
        var res = hashset<T>::instance();
        foreach (var i; self) {
            res.insert(i.elem());
        }
        return res;
    }

    func init(self) {
        self.size = 0;
        self.capacity = 4;
        self.bucket = malloc(self.capacity * __ptr_size()) => set_node<T>**;
        for (var i: u64 = 0; i < self.capacity; i += 1) {
            self.bucket[i] = nil;
        }
    }

    func clear_bucket(bucket: set_node<T>*) {
        var curr = bucket;
        while (curr != nil) {
            var tmp = curr;
            curr = curr->next;
            tmp->delete();
            free(tmp => i8*);
        }
    }

    pub func clear(self) {
        for (var i: u64 = 0; i < self.capacity; i += 1) {
            hashset<T>::clear_bucket(self.bucket[i]);
            self.bucket[i] = nil;
        }
        self.size = 0;
    }

    pub func delete(self) {
        for (var i: u64 = 0; i < self.capacity; i += 1) {
            hashset<T>::clear_bucket(self.bucket[i]);
            self.bucket[i] = nil;
        }
        free(self.bucket => i8*);
        self.bucket = nil;

        self.size = 0;
        self.capacity = 0;
    }
}

impl hashset<T> {
    #[is_non_trivial(T)]
    pub func has(self, item: T&) -> bool {
        if (self.capacity == 0) {
            panic("capacity is 0");
        }
        var hash = item.hash() % self.capacity;
        var bucket = self.bucket[hash];
        while (bucket != nil) {
            if (bucket->elem.eq(item)) {
                return true;
            }
            bucket = bucket->next;
        }
        return false;
    }

    #[is_trivial(T)]
    pub func has(self, item: T) -> bool {
        if (self.capacity == 0) {
            panic("capacity is 0");
        }
        var hash = item.hash() % self.capacity;
        var bucket = self.bucket[hash];
        while (bucket != nil) {
            if (bucket->elem.eq(item)) {
                return true;
            }
            bucket = bucket->next;
        }
        return false;
    }

    pub func empty(self) -> bool {
        return self.size == 0;
    }

    #[is_non_trivial(T)]
    pub func insert(self, item: T&) {
        var hash = item.hash() % self.capacity;
        var bucket = self.bucket[hash];

        while (bucket != nil) {
            if (bucket->elem.eq(item)) {
                return;
            }
            bucket = bucket->next;
        }

        var node = set_node<T>::new(item);
        node->next = self.bucket[hash];
        self.bucket[hash] = node;
        self.size += 1;

        if ((self.size => f64) > (self.capacity => f64) * 0.75) {
            self.rehash();
        }
    }

    #[is_trivial(T)]
    pub func insert(self, item: T) {
        var hash = item.hash() % self.capacity;
        var bucket = self.bucket[hash];

        while (bucket != nil) {
            if (bucket->elem.eq(item)) {
                return;
            }
            bucket = bucket->next;
        }

        var node = set_node<T>::new(item);
        node->next = self.bucket[hash];
        self.bucket[hash] = node;
        self.size += 1;

        if ((self.size => f64) > (self.capacity => f64) * 0.75) {
            self.rehash();
        }
    }

    func rehash_pre_work(self) -> set_node<T>* {
        var temp: set_node<T>* = nil;
        for (var i: u64 = 0; i < self.capacity; i += 1) {
            var head = self.bucket[i];
            var curr = head;
            while (curr != nil && curr->next != nil) {
                curr = curr->next;
            }
            if (curr != nil) {
                curr->next = temp;
                temp = head;
            }
            self.bucket[i] = nil;
        }

        self.capacity *= 2;
        self.bucket = realloc(
            self.bucket => i8*,
            self.capacity * __ptr_size()
        ) => set_node<T>**;
        for (var i = self.capacity / 2; i < self.capacity; i += 1) {
            self.bucket[i] = nil;
        }

        return temp;
    }

    func rehash(self) {
        var temp = self.rehash_pre_work();

        var curr = temp;
        while (curr != nil) {
            var hash = curr->elem.hash() % self.capacity;
            var tmp = curr->next;
            curr->next = self.bucket[hash];
            self.bucket[hash] = curr;
            curr = tmp;
        }
    }
}

struct iter<T> {
    set: hashset<T>*,
    bucket_index: u64,
    node: set_node<T>*
}

impl iter<T> {
    func instance(set: hashset<T>*) -> iter<T> {
        var res = iter<T> {
            set: set,
            bucket_index: 0,
            node: set->bucket[0]
        };
        while (res.node == nil) {
            res.bucket_index += 1;
            if (res.bucket_index >= set->capacity) {
                return res;
            }
            res.node = set->bucket[res.bucket_index];
        }
        return res;
    }

    pub func is_end(self) -> bool {
        return self.bucket_index >= self.set->capacity;
    }

    #[is_non_trivial(T)]
    pub func elem(self) -> T& {
        return self.node->elem;
    }

    #[is_trivial(T)]
    pub func elem(self) -> T {
        return self.node->elem;
    }

    pub func next(self) -> iter<T> {
        if (self.node != nil) {
            self.node = self.node->next;
        }

        while (self.node == nil) {
            self.bucket_index += 1;
            if (self.bucket_index >= self.set->capacity) {
                break;
            }
            self.node = self.set->bucket[self.bucket_index];
        }

        return iter<T> {
            set: self.set,
            bucket_index: self.bucket_index,
            node: self.node,
        };
    }
}

impl hashset<T> {
    pub func iter(self) -> iter<T> {
        return iter<T>::instance(self.__ptr__());
    }
}