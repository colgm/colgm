use std::libc::{ malloc, realloc, free };
use std::ptr::{ __ptr_size };
use std::panic::{ panic };

pub struct vec<T> {
    data: T*,
    size: u64,
    capacity: u64
}

impl vec<T> {
    #[is_non_pointer(T)]
    pub func new() -> vec<T>* {
        var res = vec<T>::__alloc__();
        if (res == nil) {
            panic("failed to allocate memory");
        }
        res->size = 0;
        res->capacity = 1;
        res->data = malloc(res->capacity * T::__size__()) => T*;
        return res;
    }

    #[is_pointer(T)]
    pub func new() -> vec<T>* {
        var res = vec<T>::__alloc__();
        if (res == nil) {
            panic("failed to allocate memory");
        }
        res->size = 0;
        res->capacity = 1;
        res->data = malloc(res->capacity * __ptr_size()) => T*;
        return res;
    }

    #[is_non_pointer(T)]
    pub func instance() -> vec<T> {
        var res = vec<T> {
            size: 0,
            capacity: 1,
            data: nil
        };
        res.data = malloc(res.capacity * T::__size__()) => T*;
        return res;
    }

    #[is_pointer(T)]
    pub func instance() -> vec<T> {
        var res = vec<T> {
            size: 0,
            capacity: 1,
            data: nil
        };
        res.data = malloc(res.capacity * __ptr_size()) => T*;
        return res;
    }

    #[is_non_trivial(T)]
    pub func clone(self) -> vec<T> {
        var res = vec<T>::instance();
        for (var i: u64 = 0; i < self.size; i += 1) {
            res.push(self.data[i]);
        }
        return res;
    }

    #[is_trivial(T)]
    pub func clone(self) -> vec<T> {
        var res = vec<T>::instance();
        for (var i: u64 = 0; i < self.size; i += 1) {
            res.push(self.data[i]);
        }
        return res;
    }

    #[is_non_trivial(T)]
    pub func clear(self) {
        for (var i: u64 = 0; i < self.size; i += 1) {
            self.data[i].delete();
        }
        self.size = 0;
    }

    #[is_trivial(T)]
    pub func clear(self) {
        self.size = 0;
    }

    #[is_non_trivial(T)]
    pub func delete(self) {
        for (var i: u64 = 0; i < self.size; i += 1) {
            self.data[i].delete();
        }
        free(self.data => i8*);
        self.data = nil;
        self.size = 0;
        self.capacity = 0;
    }

    #[is_trivial(T)]
    pub func delete(self) {
        free(self.data => i8*);
        self.data = nil;
        self.size = 0;
        self.capacity = 0;
    }

    pub func empty(self) -> bool {
        return self.size == 0;
    }

    #[is_non_pointer(T)]
    func extend_capacity(self) {
        self.capacity *= 2;
        self.data = realloc(
            self.data => i8*,
            self.capacity * T::__size__()
        ) => T*;
    }

    #[is_pointer(T)]
    func extend_capacity(self) {
        self.capacity *= 2;
        self.data = realloc(
            self.data => i8*,
            self.capacity * __ptr_size()
        ) => T*;
    }

    #[is_non_trivial(T)]
    pub func push(self, item: T&) {
        if (self.size >= self.capacity) {
            self.extend_capacity();
        }
        self.data[self.size] = item.clone();
        self.size += 1;
    }

    #[is_trivial(T)]
    pub func push(self, item: T) {
        if (self.size >= self.capacity) {
            self.extend_capacity();
        }
        self.data[self.size] = item;
        self.size += 1;
    }

    #[is_non_trivial(T)]
    pub func pop_back(self) {
        if (self.size == 0) {
            return;
        }
        self.size -= 1;
        self.data[self.size].delete();
    }

    #[is_trivial(T)]
    pub func pop_back(self) {
        if (self.size == 0) {
            panic("empty vector");
        }
        self.size -= 1;
    }

    #[is_non_trivial(T)]
    pub func back(self) -> T& {
        if (self.size == 0) {
            panic("empty vector");
        }
        return self.data[self.size - 1];
    }

    #[is_trivial(T)]
    pub func back(self) -> T {
        if (self.size == 0) {
            panic("empty vector");
        }
        return self.data[self.size - 1];
    }

    #[is_non_trivial(T)]
    pub func get(self, index: u64) -> T& {
        if (index >= self.size) {
            panic("index out of bounds");
        }
        return self.data[index];
    }

    #[is_non_trivial(T)]
    pub func set(self, index: u64, item: T&) {
        if (index >= self.size) {
            panic("index out of bounds");
        }
        self.data[index].delete();
        self.data[index] = item.clone();
    }

    #[is_trivial(T)]
    pub func get(self, index: u64) -> T {
        if (index >= self.size) {
            panic("index out of bounds");
        }
        return self.data[index];
    }

    #[is_trivial(T)]
    pub func set(self, index: u64, item: T) {
        if (index >= self.size) {
            panic("index out of bounds");
        }
        self.data[index] = item;
    }

    pub func swap(self, other: vec<T>&) {
        var data = self.data;
        var size = self.size;
        var capacity = self.capacity;

        self.data = other.data;
        self.size = other.size;
        self.capacity = other.capacity;

        other.data = data;
        other.size = size;
        other.capacity = capacity;
    }

    pub func c_data(self) -> T* {
        return self.data;
    }

    pub func iter(self) -> iter<T> {
        return iter<T>::instance(self.__ptr__());
    }

    pub func iter_size(self) -> u64 {
        return self.size;
    }
}

struct iter<T> {
    _vec: vec<T>*,
    _index: u64
}

impl iter<T> {
    pub func instance(v: vec<T>*) -> iter<T> {
        return iter<T> {
            _vec: v,
            _index: 0
        };
    }

    pub func is_end(self) -> bool {
        return self._index >= self._vec->size;
    }

    pub func next(self) -> iter<T> {
        if (self._index >= self._vec->size) {
            return iter<T> {
                _vec: self._vec,
                _index: self._index
            };
        }
        return iter<T> {
            _vec: self._vec,
            _index: self._index + 1
        };
    }

    #[is_non_trivial(T)]
    pub func get(self) -> T& {
        return self._vec->get(self._index);
    }

    #[is_trivial(T)]
    pub func get(self) -> T {
        return self._vec->get(self._index);
    }

    pub func index(self) -> u64 {
        return self._index;
    }
}
