use std::libc::{ malloc, realloc, free };
use std::ptr::{ __ptr_size };
use std::io::{ io };
use std::pair::{ pair };
use std::panic::{ panic };

struct map_node<K, V> {
    key: K,
    value: V,
    next: map_node<K, V>*
}

impl map_node<K, V> {
    #[is_trivial(K, V)]
    pub func new(key: K, value: V) -> map_node<K, V>* {
        var res = map_node<K, V>::__alloc__();
        if (res == nil) {
            panic("failed to allocate memory");
        }
        res->key = key;
        res->value = value;
        res->next = nil;
        return res;
    }

    #[is_trivial(K)]
    #[is_non_trivial(V)]
    pub func new(key: K, value: V&) -> map_node<K, V>* {
        var res = map_node<K, V>::__alloc__();
        if (res == nil) {
            panic("failed to allocate memory");
        }
        res->key = key;
        res->value = value.clone();
        res->next = nil;
        return res;
    }

    #[is_non_trivial(K)]
    #[is_trivial(V)]
    pub func new(key: K&, value: V) -> map_node<K, V>* {
        var res = map_node<K, V>::__alloc__();
        if (res == nil) {
            panic("failed to allocate memory");
        }
        res->key = key.clone();
        res->value = value;
        res->next = nil;
        return res;
    }

    #[is_non_trivial(K, V)]
    pub func new(key: K&, value: V&) -> map_node<K, V>* {
        var res = map_node<K, V>::__alloc__();
        if (res == nil) {
            panic("failed to allocate memory");
        }
        res->key = key.clone();
        res->value = value.clone();
        res->next = nil;
        return res;
    }

    #[is_trivial(K)]
    func delete_key(self) {}

    #[is_non_trivial(K)]
    func delete_key(self) {
        self.key.delete();
    }

    #[is_trivial(V)]
    func delete_value(self) {}

    #[is_non_trivial(V)]
    func delete_value(self) {
        self.value.delete();
    }

    pub func delete(self) {
        self.delete_key();
        self.delete_value();
    }
}

pub struct hashmap<K, V> {
    size: u64,
    capacity: u64,
    bucket: map_node<K, V>**
}

impl hashmap<K, V> {
    pub func new() -> hashmap<K, V>* {
        var res = hashmap<K, V>::__alloc__();
        if (res == nil) {
            panic("failed to allocate memory");
        }
        res->init();
        return res;
    }

    pub func instance() -> hashmap<K, V> {
        var res = hashmap<K, V> {};
        res.init();
        return res;
    }

    pub func clone(self) -> hashmap<K, V> {
        var res = hashmap<K, V>::instance();
        foreach (var i; self) {
            res.insert(i.key(), i.value());
        }
        return res;
    }

    func init(self) {
        self.size = 0;
        self.capacity = 4;
        self.bucket = malloc(self.capacity * __ptr_size()) => map_node<K, V>**;
        for (var i: u64 = 0; i < self.capacity; i += 1) {
            self.bucket[i] = nil;
        }
    }

    func clear_bucket(bucket: map_node<K, V>*) {
        var curr = bucket;
        while (curr != nil) {
            var tmp = curr;
            curr = curr->next;
            tmp->delete();
            free(tmp => i8*);
        }
    }

    pub func clear(self) {
        for (var i: u64 = 0; i < self.capacity; i += 1) {
            hashmap<K, V>::clear_bucket(self.bucket[i]);
            self.bucket[i] = nil;
        }
        self.size = 0;
    }

    pub func delete(self) {
        for (var i: u64 = 0; i < self.capacity; i += 1) {
            hashmap<K, V>::clear_bucket(self.bucket[i]);
            self.bucket[i] = nil;
        }
        free(self.bucket => i8*);
        self.bucket = nil;

        self.size = 0;
        self.capacity = 0;
    }
}

impl hashmap<K, V> {
    pub func has(self, key: K&) -> bool {
        if (self.capacity == 0) {
            panic("capacity is 0");
        }
        var hash = key.hash() % self.capacity;
        var bucket = self.bucket[hash];
        while (bucket != nil) {
            if (bucket->key.eq(key)) {
                return true;
            }
            bucket = bucket->next;
        }
        return false;
    }

    #[is_non_trivial(V)]
    pub func get(self, key: K&) -> V& {
        if (self.capacity == 0) {
            panic("capacity is 0");
        }
        var hash = key.hash() % self.capacity;
        var bucket = self.bucket[hash];

        while (bucket != nil) {
            if (bucket->key.eq(key)) {
                break;
            }
            bucket = bucket->next;
        }
        if (bucket == nil) {
            panic("key not found");
        }
        return bucket->value;
    }

    #[is_trivial(V)]
    pub func get(self, key: K&) -> V {
        if (self.capacity == 0) {
            panic("capacity is 0");
        }
        var hash = key.hash() % self.capacity;
        var bucket = self.bucket[hash];

        while (bucket != nil) {
            if (bucket->key.eq(key)) {
                break;
            }
            bucket = bucket->next;
        }
        if (bucket == nil) {
            panic("key not found");
        }
        return bucket->value;
    }

    #[is_non_trivial(V)]
    pub func insert(self, key: K&, value: V&) {
        var hash = key.hash() % self.capacity;
        var bucket = self.bucket[hash];

        while (bucket != nil) {
            if (bucket->key.eq(key)) {
                bucket->value.delete();
                bucket->value = value.clone();
                return;
            }
            bucket = bucket->next;
        }

        var node = map_node<K, V>::new(key, value);
        node->next = self.bucket[hash];
        self.bucket[hash] = node;
        self.size += 1;

        if ((self.size => f64) > (self.capacity => f64) * 0.75) {
            self.rehash();
        }
    }

    #[is_trivial(V)]
    pub func insert(self, key: K&, value: V) {
        var hash = key.hash() % self.capacity;
        var bucket = self.bucket[hash];

        while (bucket != nil) {
            if (bucket->key.eq(key)) {
                bucket->value = value;
                return;
            }
            bucket = bucket->next;
        }

        var node = map_node<K, V>::new(key, value);
        node->next = self.bucket[hash];
        self.bucket[hash] = node;
        self.size += 1;

        if ((self.size => f64) > (self.capacity => f64) * 0.75) {
            self.rehash();
        }
    }

    func rehash_pre_work(self) -> map_node<K, V>* {
        var temp: map_node<K, V>* = nil;
        for (var i: u64 = 0; i < self.capacity; i += 1) {
            var head = self.bucket[i];
            var curr = head;
            while (curr != nil && curr->next != nil) {
                curr = curr->next;
            }
            if (curr != nil) {
                curr->next = temp;
                temp = head;
            }
            self.bucket[i] = nil;
        }

        self.capacity *= 2;
        self.bucket = realloc(
            self.bucket => i8*,
            self.capacity * __ptr_size()
        ) => map_node<K, V>**;
        for (var i = self.capacity / 2; i < self.capacity; i += 1) {
            self.bucket[i] = nil;
        }

        return temp;
    }

    func rehash(self) {
        var temp = self.rehash_pre_work();

        var curr = temp;
        while (curr != nil) {
            var hash = curr->key.hash() % self.capacity;
            var tmp = curr->next;
            curr->next = self.bucket[hash];
            self.bucket[hash] = curr;
            curr = tmp;
        }
    }

    pub func remove(self, key: K&) {
        var hash = key.hash() % self.capacity;
        var prev: map_node<K, V>* = nil;
        var curr = self.bucket[hash];

        while (curr != nil) {
            if (curr->key.eq(key)) {
                if (prev != nil) {
                    prev->next = curr->next;
                } else {
                    self.bucket[hash] = curr->next;
                }
                curr->delete();
                free(curr => i8*);
                self.size -= 1;
                break;
            }
            prev = curr;
            curr = curr->next;
        }
    }

    pub func empty(self) -> bool {
        return self.size == 0;
    }
}

struct iter<K, V> {
    map: hashmap<K, V>*,
    bucket_index: u64,
    node: map_node<K, V>*
}

impl iter<K, V> {
    func instance(map: hashmap<K, V>*) -> iter<K, V> {
        var res = iter<K, V> {
            map: map,
            bucket_index: 0,
            node: map->bucket[0]
        };
        while (res.node == nil) {
            res.bucket_index += 1;
            if (res.bucket_index >= map->capacity) {
                return res;
            }
            res.node = map->bucket[res.bucket_index];
        }
        return res;
    }

    pub func next(self) -> iter<K, V> {
        if (self.node != nil) {
            self.node = self.node->next;
        }

        while (self.node == nil) {
            self.bucket_index += 1;
            if (self.bucket_index >= self.map->capacity) {
                break;
            }
            self.node = self.map->bucket[self.bucket_index];
        }

        return iter<K, V> {
            map: self.map,
            bucket_index: self.bucket_index,
            node: self.node,
        };
    }

    pub func is_end(self) -> bool {
        return self.bucket_index >= self.map->capacity;
    }

    pub func key(self) -> K& {
        return self.node->key;
    }

    #[is_non_trivial(V)]
    pub func value(self) -> V& {
        return self.node->value;
    }

    #[is_trivial(V)]
    pub func value(self) -> V {
        return self.node->value;
    }
}

impl hashmap<K, V> {
    pub func iter(self) -> iter<K, V> {
        return iter<K, V>::instance(self.__ptr__());
    }
}