use std::io::{ io };

struct mir_block {
    a: u8,  // 1 align 1
            // 1
    b: u16, // 2 align 2
            // 4
    c: u64  // 8 align 8
} // 16 align 8

struct mir_num {
    a: [u8; 127]
}

struct mir_str {}

pub enum mir_tag {
    m_block = 0x0010,
    m_num = 0x0100,
    m_str = 0x1000
}

// type {
//     i64,           // 8 align 8
//     mir_block      // 16 align 8
//     [u8; 127 - 16] // 111 align 1
//                    // 1 for alignment
// }                  // 136 align 8
pub union(mir_tag) mir {
    m_block: mir_block,
    m_num: mir_num,
    m_str: mir_str
}

func test() {
    var a = mir { m_block: mir_block {a: 1, b: 2, c: 3} };
    var b = mir { m_num: mir_num {} };
    b.m_num.a[0] = 1;
    var c = mir { m_str: mir_str {} };

    match (mir { m_str: mir_str {} }) {
        mir_tag::m_str => { io::stdout().out("mir_tag::m_str branch\n"); }
        _ => { io::stdout().out("default branch\n"); }
    }
}


union(enum) tagged_union_without_ref_enum {
    aaa: i32,
    bbb: i8*,
    ccc: f32
}

impl tagged_union_without_ref_enum {
    pub func _aaa(self) -> i32 {
        self[0].aaa = 0;
        match (self) {
            aaa => return self->aaa;
            _ => {}
        }
        return -1;
    }

    pub func _bbb(self) -> i8* {
        self[0].bbb = nil;
        return self->bbb;
    }

    pub func _ccc(self) -> f32 {
        self[0].ccc = 0.0;
        return self->ccc;
    }

    pub func static() -> i32 {
        return 0;
    }
}

enum Tag {
    aaa,
    bbb,
    ccc
}

union(Tag) tagged_union_with_ref_enum {
    aaa: i32,
    bbb: i8*,
    ccc: f32
}

impl tagged_union_with_ref_enum {
    pub func _aaa(self) -> i32 {
        self[0].aaa = 0;
        match (self) {
            Tag::aaa => return self->aaa;
            _ => {}
        }
        return -1;
    }

    pub func _bbb(self) -> i8* {
        self[0].bbb = nil;
        return self->bbb;
    }

    pub func _ccc(self) -> f32 {
        self[0].ccc = 0.0;
        return self->ccc;
    }

    pub func static() -> i32 {
        return 0;
    }
}

func main() -> i32 {
    test();

    var a = tagged_union_without_ref_enum { bbb: nil };
    var b = tagged_union_with_ref_enum { ccc: 0.0 };

    a._aaa() + b._aaa();

    match (a) {
        aaa => {
            a.aaa;
            io::stdout().out("unexpected aaa branch\n");
        }
        bbb => {
            a.bbb;
            io::stdout().out("expected bbb branch\n");
        }
        ccc => {
            a.ccc;
            io::stdout().out("unexpected ccc branch\n");
        }
    }

    match (b) {
        Tag::aaa => {
            b.aaa;
            io::stdout().out("unexpected aaa branch\n");
        }
        Tag::bbb => {
            b.bbb;
            io::stdout().out("unexpected bbb branch\n");
        }
        Tag::ccc => {
            b.ccc;
            io::stdout().out("expected ccc branch\n");
        }
    }

    return tagged_union_without_ref_enum::static() +
           tagged_union_with_ref_enum::static();
}
